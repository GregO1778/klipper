# Neko.vecter <Vecterfang@icloud.com>, 2021, 2022.
# Yifei Ding <dingyifeiair@gmail.com>, 2021, 2022.
# Arda <pengfei.fu@gmail.com>, 2022.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2022-08-08 09:23+0000\n"
"Last-Translator: Neko.vecter <Vecterfang@icloud.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/klipper/protocol/zh_Hans/>\n"
"Language: zh_Hans\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14-dev\n"

msgid ""
"The Klipper messaging protocol is used for low-level communication between "
"the Klipper host software and the Klipper micro-controller software. At a "
"high level the protocol can be thought of as a series of command and "
"response strings that are compressed, transmitted, and then processed at the"
" receiving side. An example series of commands in uncompressed human-"
"readable format might look like:"
msgstr ""
"Klipper消息协议用于Klipper主机软件和Klipper微控制器软件之间的低层通信。在上层看，该协议可以被认为是一系列的命令和响应字符串，它们被压缩、传输，然后在接收方进行处理。以下是一个例子，包含一组未经压缩的人类可读格式的命令："

msgid ""
"See the [mcu commands](MCU_Commands.md) document for information on "
"available commands. See the [debugging](Debugging.md) document for "
"information on how to translate a G-Code file into its corresponding human-"
"readable micro-controller commands."
msgstr ""
"有关可用命令的信息，请参阅 [mcu 命令](MCU_Commands.md)文档。有关如何将 G-Code "
"文件转换为其相应的可读的微控制器命令信息，请参阅[调试](Debugging.md)文档。"

msgid ""
"This page provides a high-level description of the Klipper messaging "
"protocol itself. It describes how messages are declared, encoded in binary "
"format (the \"compression\" scheme), and transmitted."
msgstr "本页提供了Klipper消息传递协议本身的高层描述。它描述了消息是如何被声明、以二进制格式编码（\"压缩 \"方案）和传输的。"

msgid ""
"The goal of the protocol is to enable an error-free communication channel "
"between the host and micro-controller that is low-latency, low-bandwidth, "
"and low-complexity for the micro-controller."
msgstr "该协议的目标是在主机和微控制器之间建立一个无错误的通信通道，对微控制器来说是低延迟、低带宽和低复杂度的。"

msgid "Micro-controller Interface"
msgstr "微控制器接口"

msgid ""
"The Klipper transmission protocol can be thought of as a "
"[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) mechanism between"
" micro-controller and host. The micro-controller software declares the "
"commands that the host may invoke along with the response messages that it "
"can generate. The host uses that information to command the micro-controller"
" to perform actions and to interpret the results."
msgstr ""
"Klipper传输协议可以被认为是微控制器和主机之间的一个[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call)机制。微控制器软件声明了主机可以调用的命令，以及它可以产生的响应信息。主机使用这些信息来命令微控制器执行动作并解释结果。"

msgid "Declaring commands"
msgstr "宣布命令"

msgid ""
"The micro-controller software declares a \"command\" by using the "
"DECL_COMMAND() macro in the C code. For example:"
msgstr "微控制器软件通过使用C代码中的DECL_COMMAND()宏来声明一个 “命令”。例如："

msgid ""
"The above declares a command named \"update_digital_out\". This allows the "
"host to \"invoke\" this command which would cause the "
"command_update_digital_out() C function to be executed in the micro-"
"controller. The above also indicates that the command takes two integer "
"parameters. When the command_update_digital_out() C code is executed, it "
"will be passed an array containing these two integers - the first "
"corresponding to the 'oid' and the second corresponding to the 'value'."
msgstr ""
"以上声明了一个名为 \"update_digital_out \"的命令。这允许主机 "
"“invoke”这个命令，这将使得command_update_digital_out()C函数在微控制器中被执行。上述内容还表明，该命令需要两个整数参数。当command_update_digital_out()C代码被执行时，它将被传递一个包含这两个整数的数组"
"--第一个对应于 \"oid\"，第二个对应于 \"value\"。"

msgid ""
"In general, the parameters are described with printf() style syntax (eg, "
"\"%u\"). The formatting directly corresponds to the human-readable view of "
"commands (eg, \"update_digital_out oid=7 value=1\"). In the above example, "
"\"value=\" is a parameter name and \"%c\" indicates the parameter is an "
"integer. Internally, the parameter name is only used as documentation. In "
"this example, the \"%c\" is also used as documentation to indicate the "
"expected integer is 1 byte in size (the declared integer size does not "
"impact the parsing or encoding)."
msgstr ""
"一般来说，参数是用printf()风格的语法描述的（例如，\"%u\"）。这种格式化直接对应于人类可读的命令（例如，\"update_digital_out"
" oid=7 value=1\"）。在上面的例子中，\"value=\"是一个参数名称，\"%c "
"\"表示该参数是一个整数。在内部，参数名只作为记录使用。在这个例子中，\"%c "
"\"也是作为记录使用的，表示预期的整数是1字节宽度（声明的整数宽度不影响编解码）。"

msgid ""
"The micro-controller build will collect all commands declared with "
"DECL_COMMAND(), determine their parameters, and arrange for them to be "
"callable."
msgstr "微控制器固件构建的时候包含所有用DECL_COMMAND()声明的命令，确定其参数，并使得它们可以被调用。"

msgid "Declaring responses"
msgstr "声明响应"

msgid ""
"To send information from the micro-controller to the host a \"response\" is "
"generated. These are both declared and transmitted using the sendf() C "
"macro. For example:"
msgstr "当从微控制器向主机发送信息时会产生一个 \"响应\"。这些都是使用sendf()C语言宏来声明和发送的。例如："

msgid ""
"The above transmits a \"status\" response message that contains two integer "
"parameters (\"clock\" and \"status\"). The micro-controller build "
"automatically finds all sendf() calls and generates encoders for them. The "
"first parameter of the sendf() function describes the response and it is in "
"the same format as command declarations."
msgstr ""
"以上传输了一个 \"状态 \"响应消息，其中包含两个整数参数（\"时钟 \"和 "
"\"状态\"）。微控制器的构建会自动找到所有sendf()的调用，并为其生成编码器。sendf()函数的第一个参数描述了响应，它的格式与命令声明相同。"

msgid ""
"The host can arrange to register a callback function for each response. So, "
"in effect, commands allow the host to invoke C functions in the micro-"
"controller and responses allow the micro-controller software to invoke code "
"in the host."
msgstr "主机可以为每个响应注册一个回调函数。因此，实际上，命令允许主机在微控制器上调用C函数，响应允许微控制器软件在主机上调用代码。"

msgid ""
"The sendf() macro should only be invoked from command or task handlers, and "
"it should not be invoked from interrupts or timers. The code does not need "
"to issue a sendf() in response to a received command, it is not limited in "
"the number of times sendf() may be invoked, and it may invoke sendf() at any"
" time from a task handler."
msgstr ""
"sendf()宏只能从命令或任务处理程序中调用，而不能从中断或定时器中调用。代码不需要在收到命令的响应中发出sendf()，代码也不限制sendf()的调用次数，任务处理程序在在任何时候都可以调用sendf()。"

msgid "Output responses"
msgstr "输出响应"

msgid ""
"To simplify debugging, there is also an output() C function. For example:"
msgstr "为了简化调试，也有一个output()C函数。例如："

msgid ""
"The output() function is similar in usage to printf() - it is intended to "
"generate and format arbitrary messages for human consumption."
msgstr "output()函数的用法与printf()相似–它的目的是生成和格式化任意的信息供人阅读。"

msgid "Declaring enumerations"
msgstr "声明枚举"

msgid ""
"Enumerations allow the host code to use string identifiers for parameters "
"that the micro-controller handles as integers. They are declared in the "
"micro-controller code - for example:"
msgstr "枚举允许主机代码对微控制器作为整数处理的参数使用字符串标识。它们在微控制器代码中被声明-例如："

msgid ""
"If the first example, the DECL_ENUMERATION() macro defines an enumeration "
"for any command/response message with a parameter name of \"spi_bus\" or "
"parameter name with a suffix of \"_spi_bus\". For those parameters the "
"string \"spi\" is a valid value and it will be transmitted with an integer "
"value of zero."
msgstr ""
"在第一个例子中，DECL_ENUMERATION()宏定义了一个枚举量可以用于任意的命令/响应消息，这个枚举量的参数名称为 \"spi_bus "
"\"或参数名称后缀为\"_spi_bus \"。对于此参数，字符串 \"spi \"是一个有效的值，它将以一个零的整数值被传递。"

msgid ""
"It's also possible to declare an enumeration range. In the second example, a"
" \"pin\" parameter (or any parameter with a suffix of \"_pin\") would accept"
" PC0, PC1, PC2, ..., PC7 as valid values. The strings will be transmitted "
"with integers 16, 17, 18, ..., 23."
msgstr ""
"也可以声明一个枚举范围。在第二个例子中，\"pin \"参数（或任何后缀为\"_pin "
"\"的参数）将接受PC0、PC1、PC2、...、PC7作为有效值。字符串将被转化成整数16、17、18...23进行传输。"

msgid "Declaring constants"
msgstr "声明常量"

msgid "Constants can also be exported. For example, the following:"
msgstr "常量也可以被导出。例子如下："

msgid ""
"would export a constant named \"SERIAL_BAUD\" with a value of 250000 from "
"the micro-controller to the host. It is also possible to declare a constant "
"that is a string - for example:"
msgstr "可以从微控制器向主机输出一个名为 \"SERIAL_BAUD \"，值为250000的常数。也可以将字符串声明成常量-例如："

msgid "Low-level message encoding"
msgstr "底层消息编码"

msgid ""
"To accomplish the above RPC mechanism, each command and response is encoded "
"into a binary format for transmission. This section describes the "
"transmission system."
msgstr "为了实现上述RPC机制，每个命令和响应都被编码成二进制格式进行传输。本节介绍这个传输系统。"

msgid "Message Blocks"
msgstr "消息块"

msgid ""
"All data sent from host to micro-controller and vice-versa are contained in "
"\"message blocks\". A message block has a two byte header and a three byte "
"trailer. The format of a message block is:"
msgstr "所有从主机到微控制器以及从微控制器到主机的数据都包含在 \"消息块 \"中。一个消息块有一个两字节的头和一个三字节的尾。信息块的格式如下："

msgid ""
"The length byte contains the number of bytes in the message block including "
"the header and trailer bytes (thus the minimum message length is 5 bytes). "
"The maximum message block length is currently 64 bytes. The sequence byte "
"contains a 4 bit sequence number in the low-order bits and the high-order "
"bits always contain 0x10 (the high-order bits are reserved for future use). "
"The content bytes contain arbitrary data and its format is described in the "
"following section. The crc bytes contain a 16bit CCITT "
"[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) of the message "
"block including the header bytes but excluding the trailer bytes. The sync "
"byte is 0x7e."
msgstr ""
"长度字节指示消息块中的字节数，包括头和尾的字节（因此消息的最短长度为5字节）。目前最大的消息块长度为64字节。序号字节的低4位是序列号，高4位总是0x10（高4位保留给未来用）。内容字节包含任意数据，其格式在下一节中描述。crc字节包含消息块的16位CCITT[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)，CRC计算包括头字节但不包括尾字节。同步字节为0x7e。"

msgid ""
"The format of the message block is inspired by "
"[HDLC](https://en.wikipedia.org/wiki/High-Level_Data_Link_Control) message "
"frames. Like in HDLC, the message block may optionally contain an additional"
" sync character at the start of the block. Unlike in HDLC, a sync character "
"is not exclusive to the framing and may be present in the message block "
"content."
msgstr ""
"消息块的格式是受[HDLC](https://en.wikipedia.org/wiki/High-"
"Level_Data_Link_Control)消息帧的启发。与HDLC一样，消息块在开始时可以选择包含一个额外的同步字符。与HDLC不同的是，同步字符并不专属于框架，也可以出现在消息块内容中（不需要转义）。"

msgid "Message Block Contents"
msgstr "消息块内容"

msgid ""
"Each message block sent from host to micro-controller contains a series of "
"zero or more message commands in its contents. Each command starts with a "
"[Variable Length Quantity](#variable-length-quantities) (VLQ) encoded "
"integer command-id followed by zero or more VLQ parameters for the given "
"command."
msgstr ""
"每个从主机发送至微控制器的消息块，其内容都包含一系列零个或多个消息命令。每条命令以[可变长度数值](#variable-length-"
"quantities)(VLQ)编码的整数command-id开始，后面是这个命令的零或多个VLQ参数。"

msgid ""
"As an example, the following four commands might be placed in a single "
"message block:"
msgstr "例如，以下四个命令可以被放在一个消息块中："

msgid "and encoded into the following eight VLQ integers:"
msgstr "并编码为下面八个VLQ整数："

msgid ""
"In order to encode and parse the message contents, both the host and micro-"
"controller must agree on the command ids and the number of parameters each "
"command has. So, in the above example, both the host and micro-controller "
"would know that \"id_update_digital_out\" is always followed by two "
"parameters, and \"id_get_config\" and \"id_get_clock\" have zero parameters."
" The host and micro-controller share a \"data dictionary\" that maps the "
"command descriptions (eg, \"update_digital_out oid=%c value=%c\") to their "
"integer command-ids. When processing the data, the parser will know to "
"expect a specific number of VLQ encoded parameters following a given command"
" id."
msgstr ""
"为了对信息内容进行编解码，主机和微控制器都必须确保使用的命令的ID和每个命令对应的参数数量一致。因此，在上面的例子中，主机和微控制器都知道 "
"\"id_update_digital_out \"后面总是跟着两个参数，而 \"id_get_config \"和 \"id_get_clock "
"\"没有参数。主机和微控制器共享一个 \"数据字典\"，这个数据字典将命令描述（例如，\"update_digital_out oid=%c "
"value=%c\"）映射到它们的整数命令ID。当处理数据时，解析器将知道一个给定的命令ID后预期有特定数量的VLQ编码参数。"

msgid ""
"The message contents for blocks sent from micro-controller to host follow "
"the same format. The identifiers in these messages are \"response ids\", but"
" they serve the same purpose and follow the same encoding rules. In "
"practice, message blocks sent from the micro-controller to the host never "
"contain more than one response in the message block contents."
msgstr ""
"从微控制器发送到主机的块的消息内容遵循相同的格式。这些消息中的标识符是 "
"\"响应ID\"，但它们的作用相同，并遵循相同的编码规则。事实上，从微控制器发送到主机的消息块在消息块内容中只包含一个响应。"

msgid "Variable Length Quantities"
msgstr "可变长度数值"

msgid ""
"See the [wikipedia article](https://en.wikipedia.org/wiki/Variable-"
"length_quantity) for more information on the general format of VLQ encoded "
"integers. Klipper uses an encoding scheme that supports both positive and "
"negative integers. Integers close to zero use less bytes to encode and "
"positive integers typically encode using less bytes than negative integers. "
"The following table shows the number of bytes each integer takes to encode:"
msgstr ""
"关于VLQ编码的整数的一般格式的更多信息，请参见[wikipedia "
"article](https://en.wikipedia.org/wiki/Variable-"
"length_quantity)。Klipper使用支持正负整数的编码方案。接近零的整数使用较少的字节来编码，正整数的编码通常比负整数的使用字节更少。下表显示了每个整数的编码所需的字节数："

msgid "Integer"
msgstr "整数"

msgid "Encoded size"
msgstr "编码长度"

msgid "-32 .. 95"
msgstr "-32 .. 95"

msgid "1"
msgstr "1"

msgid "-4096 .. 12287"
msgstr "-4096 .. 12287"

msgid "2"
msgstr "2"

msgid "-524288 .. 1572863"
msgstr "-524288 .. 1572863"

msgid "3"
msgstr "3"

msgid "-67108864 .. 201326591"
msgstr "-67108864 .. 201326591"

msgid "4"
msgstr "4"

msgid "-2147483648 .. 4294967295"
msgstr "-2147483648 .. 4294967295"

msgid "5"
msgstr "5"

msgid "Variable length strings"
msgstr "可变长度字符串"

msgid ""
"As an exception to the above encoding rules, if a parameter to a command or "
"response is a dynamic string then the parameter is not encoded as a simple "
"VLQ integer. Instead it is encoded by transmitting the length as a VLQ "
"encoded integer followed by the contents itself:"
msgstr ""
"作为上述编码规则的例外，如果一个命令或响应的参数是一个动态字符串，那么该参数不会被编码为一个简单的VLQ整数。相反，它的编码方式是将长度作为一个VLQ编码的整数并跟着内容本身来传输："

msgid ""
"The command descriptions found in the data dictionary allow both the host "
"and micro-controller to know which command parameters use simple VLQ "
"encoding and which parameters use string encoding."
msgstr "在数据字典中的命令描述使主机和微控制器都知道哪些命令参数使用简单的VLQ编码，哪些参数使用字符串编码。"

msgid "Data Dictionary"
msgstr "数据字典"

msgid ""
"In order for meaningful communications to be established between micro-"
"controller and host, both sides must agree on a \"data dictionary\". This "
"data dictionary contains the integer identifiers for commands and responses "
"along with their descriptions."
msgstr "为了在微控制器和主机之间建立有意义的通信，双方必须商定一个 \"数据字典\"。这个数据字典包含了命令和响应的整数标识符及它们的描述。"

msgid ""
"The micro-controller build uses the contents of DECL_COMMAND() and sendf() "
"macros to generate the data dictionary. The build automatically assigns "
"unique identifiers to each command and response. This system allows both the"
" host and micro-controller code to seamlessly use descriptive human-readable"
" names while still using minimal bandwidth."
msgstr ""
"微控制器构建使用DECL_COMMAND()和sendf()宏的内容来生成数据字典。构建会自动为每个命令和响应分配唯一的标识符。这个系统允许主机和微控制器代码既使用人类可读的描述性名称又占用最小的传输带宽。"

msgid ""
"The host queries the data dictionary when it first connects to the micro-"
"controller. Once the host downloads the data dictionary from the micro-"
"controller, it uses that data dictionary to encode all commands and to parse"
" all responses from the micro-controller. The host must therefore handle a "
"dynamic data dictionary. However, to keep the micro-controller software "
"simple, the micro-controller always uses its static (compiled in) data "
"dictionary."
msgstr ""
"当主机第一次连接到微控制器时，会查询数据字典。一旦主机从微控制器中下载了数据字典，它就使用该数据字典对所有命令进行编码，并解析来自微控制器的所有响应。因此，主机必须能处理动态的数据字典。然而，为了保持微控制器软件的简单性，微控制器总是使用静态（编译的）数据字典。"

msgid ""
"The data dictionary is queried by sending \"identify\" commands to the "
"micro-controller. The micro-controller will respond to each identify command"
" with an \"identify_response\" message. Since these two commands are needed "
"prior to obtaining the data dictionary, their integer ids and parameter "
"types are hard-coded in both the micro-controller and the host. The "
"\"identify_response\" response id is 0, the \"identify\" command id is 1. "
"Other than having hard-coded ids the identify command and its response are "
"declared and transmitted the same way as other commands and responses. No "
"other command or response is hard-coded."
msgstr ""
"数据字典是通过向微控制器发送 \"identify\"命令来查询的。微控制器将用一个 \"identify_response "
"\"消息来回应每条识别命令。由于在获取数据字典之前需要这两条命令，它们的整数id和参数类型在微控制器和主机中都是硬编码的。\"identify_response"
" "
"\"的响应id是0，\"identify\"的命令id是1。除了有硬编码的id外，识别命令及其响应的声明和传输方式与其他命令和响应相同。除此之外没有其他命令或响应是硬编码的。"

msgid ""
"The format of the transmitted data dictionary itself is a zlib compressed "
"JSON string. The micro-controller build process generates the string, "
"compresses it, and stores it in the text section of the micro-controller "
"flash. The data dictionary can be much larger than the maximum message block"
" size - the host downloads it by sending multiple identify commands "
"requesting progressive chunks of the data dictionary. Once all chunks are "
"obtained the host will assemble the chunks, uncompress the data, and parse "
"the contents."
msgstr ""
"传输的数据字典本身的格式是一个zlib压缩的JSON字符串。微控制器的构建过程会生成该字符串，对其进行压缩，并将其存储在微控制器闪存的text部分。数据字典可以比最大的消息块大得多"
"--主机通过发送多个识别命令来分块下载数据字典。一旦获得所有的数据块，主机将把这些数据块组合起来，解压缩数据并解析内容。"

msgid ""
"In addition to information on the communication protocol, the data "
"dictionary also contains the software version, enumerations (as defined by "
"DECL_ENUMERATION), and constants (as defined by DECL_CONSTANT)."
msgstr "除了通信协议的信息外，数据字典还包含软件版本、枚举值（由DECL_ENUMERATION定义）和常量（由DECL_CONSTANT定义）。"

msgid "Message flow"
msgstr "消息流"

msgid ""
"Message commands sent from host to micro-controller are intended to be "
"error-free. The micro-controller will check the CRC and sequence numbers in "
"each message block to ensure the commands are accurate and in-order. The "
"micro-controller always processes message blocks in-order - should it "
"receive a block out-of-order it will discard it and any other out-of-order "
"blocks until it receives blocks with the correct sequencing."
msgstr ""
"从主机到微控制器发送的信息命令应该是无差错的。微控制器将检查每个信息块中的CRC和顺序号，以确保命令的准确性和顺序性。微控制器总是按顺序处理信息块--"
"如果它收到一个不按顺序的信息块，它将丢弃它和其他不按顺序的信息块，直到它收到具有正确顺序号的信息块。"

msgid ""
"The low-level host code implements an automatic retransmission system for "
"lost and corrupt message blocks sent to the micro-controller. To facilitate "
"this, the micro-controller transmits an \"ack message block\" after each "
"successfully received message block. The host schedules a timeout after "
"sending each block and it will retransmit should the timeout expire without "
"receiving a corresponding \"ack\". In addition, if the micro-controller "
"detects a corrupt or out-of-order block it may transmit a \"nak message "
"block\" to facilitate fast retransmission."
msgstr ""
"低层的主机代码为发送到微控制器的丢失和损坏的消息块实现了一个自动重传系统。为此，微控制器在每次成功接收的消息块之后都会发送一个 \"ack "
"message block\"。主机在发送每个块后会启动超时等待，如果超时后没有收到相应的 "
"\"ack\"，它将重新发送。此外，如果微控制器检测到一个损坏或顺序错误的块，它可以发送一个 \"nak message block\"实现快速重传。"

msgid ""
"An \"ack\" is a message block with empty content (ie, a 5 byte message "
"block) and a sequence number greater than the last received host sequence "
"number. A \"nak\" is a message block with empty content and a sequence "
"number less than the last received host sequence number."
msgstr ""
"“ack \"是一个内容为空的消息块（即一个5字节的消息块），其顺序号大于最后收到的主机消息顺序号。一个 \"nak "
"\"是一个内容为空的消息块，其顺序号小于最后收到的主机消息顺序号。"

msgid ""
"The protocol facilitates a \"window\" transmission system so that the host "
"can have many outstanding message blocks in-flight at a time. (This is in "
"addition to the many commands that may be present in a given message block.)"
" This allows maximum bandwidth utilization even in the event of transmission"
" latency. The timeout, retransmit, windowing, and ack mechanism are inspired"
" by similar mechanisms in "
"[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)."
msgstr ""
"协议实现了 \"窗口 "
"\"传输系统，因此主机可以在同一时间允许多未完成的消息块在发送。(这是对一个消息块中可以包含多个命令的补充）。通过这种方式，即使在传输延迟的情况下也能最大化地利用带宽。超时、重传、窗口化和响应机制是受到[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)中类似机制的启发。"

msgid ""
"In the other direction, message blocks sent from micro-controller to host "
"are designed to be error-free, but they do not have assured transmission. "
"(Responses should not be corrupt, but they may go missing.) This is done to "
"keep the implementation in the micro-controller simple. There is no "
"automatic retransmission system for responses - the high-level code is "
"expected to be capable of handling an occasional missing response (usually "
"by re-requesting the content or setting up a recurring schedule of response "
"transmission). The sequence number field in message blocks sent to the host "
"is always one greater than the last received sequence number of message "
"blocks received from the host. It is not used to track sequences of response"
" message blocks."
msgstr ""
"另一方向，从微控制器发送到主机的信息块被设计成无差错，但并不保证传输。(响应不会出错，但可能会丢失。)这样做是为了保持微控制器的实现简单。响应没有自动重传系统"
"--"
"高层代码应该能够处理偶尔丢失的响应（通常通过重新请求内容或设置响应传输的循环调度）。发送给主机的信息块中的顺序号字段总是比从主机收到的信息块的最后接收顺序号大1。顺序号并不用于跟踪响应消息块的顺序。"

msgid ""
"set_digital_out pin=PA3 value=1\n"
"set_digital_out pin=PA7 value=1\n"
"schedule_digital_out oid=8 clock=4000000 value=0\n"
"queue_step oid=7 interval=7458 count=10 add=331\n"
"queue_step oid=7 interval=11717 count=4 add=1281\n"
msgstr ""
"set_digital_out pin=PA3 value=1\n"
"set_digital_out pin=PA7 value=1\n"
"schedule_digital_out oid=8 clock=4000000 value=0\n"
"queue_step oid=7 interval=7458 count=10 add=331\n"
"queue_step oid=7 interval=11717 count=4 add=1281\n"

msgid ""
"DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c "
"value=%c\");\n"
msgstr ""
"DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c "
"value=%c\");\n"

msgid ""
"sendf(\"status clock=%u status=%c\", sched_read_time(), "
"sched_is_shutdown());\n"
msgstr ""
"sendf(\"status clock=%u status=%c\", sched_read_time(), "
"sched_is_shutdown());\n"

msgid "output(\"The value of %u is %s with size %u.\", x, buf, buf_len);\n"
msgstr "output(\"The value of %u is %s with size %u.\", x, buf, buf_len);\n"

msgid ""
"DECL_ENUMERATION(\"spi_bus\", \"spi\", 0);\n"
"\n"
"DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8);\n"
msgstr ""
"DECL_ENUMERATION(\"spi_bus\", \"spi\", 0);\n"
"\n"
"DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8);\n"

msgid "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"
msgstr "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"

msgid "DECL_CONSTANT_STR(\"MCU\", \"pru\");\n"
msgstr "DECL_CONSTANT_STR(\"MCU\", \"pru\");\n"

msgid ""
"<1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync>\n"
msgstr ""
"<1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync>\n"

msgid ""
"update_digital_out oid=6 value=1\n"
"update_digital_out oid=5 value=0\n"
"get_config\n"
"get_clock\n"
msgstr ""
"update_digital_out oid=6 value=1\n"
"update_digital_out oid=5 value=0\n"
"get_config\n"
"get_clock\n"

msgid ""
"<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock>\n"
msgstr ""
"<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock>\n"

msgid "<VLQ encoded length><n-byte contents>\n"
msgstr "<VLQ encoded length><n-byte contents>\n"

#: docs/Protocol.md:block 1 (header)
msgid "Protocol"
msgstr "协议"
