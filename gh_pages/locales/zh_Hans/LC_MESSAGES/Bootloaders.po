# Yifei Ding <dingyifeiair@gmail.com>, 2021, 2022.
# Neko.vecter <Vecterfang@icloud.com>, 2021, 2022.
# mirokymac <toufubomb@gmail.com>, 2021.
# Arda <pengfei.fu@gmail.com>, 2022.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2022-08-08 09:23+0000\n"
"Last-Translator: Neko.vecter <Vecterfang@icloud.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/klipper/bootloaders/zh_Hans/>\n"
"Language: zh_Hans\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14-dev\n"

msgid ""
"This document provides information on common bootloaders found on micro-"
"controllers that Klipper supports."
msgstr "本文档介绍Klipper支持的用于微控制器的底层引导程序（bootloader）。"

msgid ""
"The bootloader is 3rd-party software that runs on the micro-controller when "
"it is first powered on. It is typically used to flash a new application (eg,"
" Klipper) to the micro-controller without requiring specialized hardware. "
"Unfortunately, there is no industry wide standard for flashing a micro-"
"controller, nor is there a standard bootloader that works across all micro-"
"controllers. Worse, it is common for each bootloader to require a different "
"set of steps to flash an application."
msgstr ""
"引导程序是第三方软件，在微控制器上电后优先运行。该程序可以在不需要特殊硬件（如烧录器）下对微控制器的程序进行刷写（如写入Klipper程序）。然而，目前还没有一刷写微控制器的工业标准，也没有一个适用于所有微控制器的标准引导程序。更麻烦的是，每种引导加载程序需要不同的步骤以触发刷写功能。"

msgid ""
"If one can flash a bootloader to a micro-controller then one can generally "
"also use that mechanism to flash an application, but care should be taken "
"when doing this as one may inadvertently remove the bootloader. In contrast,"
" a bootloader will generally only permit a user to flash an application. It "
"is therefore recommended to use a bootloader to flash an application where "
"possible."
msgstr ""
"如果能用某种方式将 bootloader 刷写到微控制器，使用该方式通常也能完成程序刷写操作，但是，这种直接刷写可能会将 bootloader "
"覆盖掉。相对地，bootloader 只允许用户刷写应用程序区域。因此，尽可能使用 bootloader 完成程序的刷写。"

msgid ""
"This document attempts to describe common bootloaders, the steps needed to "
"flash a bootloader, and the steps needed to flash an application. This "
"document is not an authoritative reference; it is intended as a collection "
"of useful information that the Klipper developers have accumulated."
msgstr ""
"该文档将尽可能介绍常见的bootloaders，刷入bootloader所需的步骤和触发bootloader进行程序刷写的流程。该文档亦非官方指引，这只是在Klipper开发人员使用过程中收集到的有用信息。"

msgid "AVR micro-controllers"
msgstr "AVR 微控制器"

msgid ""
"To flash a bootloader itself, the AVR chips require an external hardware "
"flashing tool (which communicates with the chip using SPI). This tool can be"
" purchased (for example, do a web search for \"avr isp\", \"arduino isp\", "
"or \"usb tiny isp\"). It is also possible to use another Arduino or "
"Raspberry Pi to flash an AVR bootloader (for example, do a web search for "
"\"program an avr using raspberry pi\"). The examples below are written "
"assuming an \"AVR ISP Mk2\" type device is in use."
msgstr ""
"要刷写引导程序本身，AVR 芯片需要一个外部硬件刷写工具（它使用 SPI 与芯片进行通信）。这个工具可以购买（例如，在网上搜索 \"avr "
"isp\"、\"arduino isp \"或 \"usb tiny isp\"）。也可以使用另一个Arduino或Raspberry "
"Pi来闪存AVR引导程序（例如，在网上搜索 \"用raspberry pi编程AVR\"）。下面的例子是在假设使用 \"AVR ISP Mk2 "
"\"类型的设备的情况下编写的。"

msgid ""
"The \"avrdude\" program is the most common tool used to flash atmega chips "
"(both bootloader flashing and application flashing)."
msgstr "\"avrdude \"程序是最常用的工具，用于刷写atmega芯片（包括引导程序刷写和应用程序刷写）。"

msgid "Atmega2560"
msgstr "Atmega2560"

msgid ""
"This chip is typically found in the \"Arduino Mega\" and is very common in "
"3d printer boards."
msgstr "这个芯片通常出现在 \"Arduino Mega\" 中，在3D打印机主板中也十分普遍。"

msgid "To flash the bootloader itself use something like:"
msgstr "要刷写引导程序本身，请使用类似以下的方法："

msgid "To flash an application use something like:"
msgstr "要刷写一个应用程序使用："

msgid "Atmega1280"
msgstr "Atmega1280"

msgid "This chip is typically found in earlier versions of the \"Arduino Mega\"."
msgstr "这个芯片通常出现在早期版本的 \"Arduino Mega \"中。"

msgid "Atmega1284p"
msgstr "Atmega1284p"

msgid "This chip is commonly found in \"Melzi\" style 3d printer boards."
msgstr "这种芯片通常出现在 \"Melzi \"式的3D打印机主板上。"

msgid ""
"Note that a number of \"Melzi\" style boards come preloaded with a "
"bootloader that uses a baud rate of 57600. In this case, to flash an "
"application use something like this instead:"
msgstr "注意，一些 \"Melzi \"风格的板子预载了一个使用57600波特率的引导程序。在这种情况下，要刷写一个应用程序，请使用类似这样的东西来代替："

msgid "At90usb1286"
msgstr "At90usb1286"

msgid ""
"This document does not cover the method to flash a bootloader to the "
"At90usb1286 nor does it cover general application flashing to this device."
msgstr "本文件不包括向At90usb1286刷写引导程序的方法，也不包括向该设备刷写一般应用。"

msgid "Atmega168"
msgstr "Atmega168"

msgid ""
"The atmega168 has limited flash space. If using a bootloader, it is "
"recommended to use the Optiboot bootloader. To flash that bootloader use "
"something like:"
msgstr "atmega168的闪存空间有限。如果使用引导程序，建议使用Optiboot bootloader。要刷写该引导程序，请使用这个的方法："

msgid ""
"To flash an application via the Optiboot bootloader use something like:"
msgstr "要通过Optiboot bootloader 刷写一个应用程序，请使用以下方法："

msgid "SAM3 micro-controllers (Arduino Due)"
msgstr "SAM3 微控制器 (Arduino Due)"

msgid ""
"It is not common to use a bootloader with the SAM3 mcu. The chip itself has "
"a ROM that allows the flash to be programmed from 3.3V serial port or from "
"USB."
msgstr "通常在 SAM 3 微控制器上不使用引导程序。芯片自带一个允许从3.3V 串口或从USB进行编程的ROM。"

msgid ""
"To enable the ROM, the \"erase\" pin is held high during a reset, which "
"erases the flash contents, and causes the ROM to run. On an Arduino Due, "
"this sequence can be accomplished by setting a baud rate of 1200 on the "
"\"programming usb port\" (the USB port closest to the power supply)."
msgstr ""
"为了启用ROM，将\"erase\"引脚在复位过程中保持高电平，这将擦除闪存的内容，并使ROM运行。在Arduino Due上，这个程序可以通过在 "
"\"programming usb port\"（编程USB口，最靠近电源的USB端口）上设置1200的波特率来完成。"

msgid "SAM4 micro-controllers (Duet Wifi)"
msgstr "SAM4 微控制器 (Duet Wifi)"

msgid ""
"It is not common to use a bootloader with the SAM4 mcu. The chip itself has "
"a ROM that allows the flash to be programmed from 3.3V serial port or from "
"USB."
msgstr "通常在 SAM4 微控制器中不使用引导程序。芯片自带一个可以从 3.3V 串口或 USB 进行编程的ROM。"

msgid ""
"To enable the ROM, the \"erase\" pin is held high during a reset, which "
"erases the flash contents, and causes the ROM to run."
msgstr "为了启用ROM，在复位过程中要将\"erase\"引脚保持为高电平，这将擦除闪存内容，并使ROM运行。"

msgid "SAMD21 micro-controllers (Arduino Zero)"
msgstr "SAMD21微控制器（Arduino Zero）"

msgid ""
"The SAMD21 bootloader is flashed via the ARM Serial Wire Debug (SWD) "
"interface. This is commonly done with a dedicated SWD hardware dongle. "
"Alternatively, one can use a [Raspberry Pi with OpenOCD](#running-openocd-"
"on-the-raspberry-pi)."
msgstr ""
"SAMD21 引导加载程序通过 ARM 串行线调试 （SWD） 接口进行刷写，通常需要一个专用的 SWD 硬件转换器或者使用[安装了 OpenOCD 的"
" Raspberry Pi](#running-openocd-on-the-raspberry-pi)来完成。"

msgid "To flash a bootloader with OpenOCD use the following chip config:"
msgstr "要使用 OpenOCD 刷写引导加载程序，请使用以下芯片配置："

msgid "Obtain a bootloader - for example:"
msgstr "获取引导加载程序 - 例如："

msgid "Flash with OpenOCD commands similar to:"
msgstr "使用类似下面的 OpenOCD 命令来刷写："

msgid ""
"The most common bootloader on the SAMD21 is the one found on the \"Arduino "
"Zero\". It uses an 8KiB bootloader (the application must be compiled with a "
"start address of 8KiB). One can enter this bootloader by double clicking the"
" reset button. To flash an application use something like:"
msgstr ""
"SAMD21上最常见的启动引导程序可以在 \"Arduino Zero \"上找到。它使用一个 8KiB 的引导程序（应用程序必须以 8KiB "
"的起始地址进行编译），按下复位按钮两次就可以进入。要刷写一个程序，请使用类似以下的方法："

msgid ""
"In contrast, the \"Arduino M0\" uses a 16KiB bootloader (the application "
"must be compiled with a start address of 16KiB). To flash an application on "
"this bootloader, reset the micro-controller and run the flash command within"
" the first few seconds of boot - something like:"
msgstr ""
"相比之下，\"Arduino M0 \"使用一个 16KiB 的启动引导程序（程序必须用 16KiB "
"的起始地址进行编译）。使用这个启动引导程序来刷写一个程序，请重置微控制器，并在启动的头几秒钟内运行刷写命令--类似如下命令："

msgid "SAMD51 micro-controllers (Adafruit Metro-M4 and similar)"
msgstr "SAMD51 微控制器(Adafruit Metro-M4及类似的开发板)"

msgid ""
"Like the SAMD21, the SAMD51 bootloader is flashed via the ARM Serial Wire "
"Debug (SWD) interface. To flash a bootloader with [OpenOCD on a Raspberry "
"Pi](#running-openocd-on-the-raspberry-pi) use the following chip config:"
msgstr ""
"和 SAMD21 一样，SAMD51 的启动引导程序也是通过 ARM 串行线调试（SWD）接口刷写的。要用[运行 OpenOCD的 Raspberry "
"Pi](#running-openocd-on-the-raspberry-pi)刷写引导程序，请使用以下芯片配置："

msgid ""
"The SAMD51 uses a 16KiB bootloader (the application must be compiled with a "
"start address of 16KiB). To flash an application use something like:"
msgstr "SAMD51 使用 16KiB 的启动引导程序（应用程序必须以16KiB的起始地址进行编译）。要刷写一个应用程序，请使用类似以下的方法："

msgid "STM32F103 micro-controllers (Blue Pill devices)"
msgstr "STM32F103 微控制器（Blue Pill 开发板）"

msgid ""
"After flashing, set both \"boot 0\" and \"boot 1\" back to low so that "
"future resets boot from flash."
msgstr "刷写后，将 \"boot 0 \"和 \"boot 1 \"都恢复设为低电平，以便在复位后从闪存启动。"

msgid "STM32F103 with stm32duino bootloader"
msgstr "带有 stm32duino 引导加载程序的 STM32F103"

msgid "This bootloader can be flashed via 3.3V serial with something like:"
msgstr "这个引导程序可以通过3.3V的串口用类似以下的命令来刷写："

msgid ""
"This bootloader uses 8KiB of flash space (the application must be compiled "
"with a start address of 8KiB). Flash an application with something like:"
msgstr "这个引导程序使用 8KiB 的闪存空间（应用程序必须以 8KiB 的起始地址编译）。刷写应用程序需要使用类似以下的命令："

msgid ""
"The bootloader typically runs for only a short period after boot. It may be "
"necessary to time the above command so that it runs while the bootloader is "
"still active (the bootloader will flash a board led while it is running). "
"Alternatively, set the \"boot 0\" pin to low and \"boot 1\" pin to high to "
"stay in the bootloader after a reset."
msgstr ""
"启动引导程序通常只在启动后的一小段时间运行。在输入以上命令的时候，需要确保启动引导程序还在运行（启动引导程序运行的时候会控制板上的led闪烁）。此外，启动后如果设置“boot"
" 0”引脚为低，设置“boot 1”引脚为高则可以一直停留在启动引导程序。"

msgid "STM32F103 with HID bootloader"
msgstr "带有 HID 引导程序的STM32F103"

msgid ""
"For generic STM32F103 boards such as the blue pill it is possible to flash "
"the bootloader via 3.3v serial using stm32flash as noted in the stm32duino "
"section above, substituting the file name for the desired hid bootloader "
"binary (ie: hid_generic_pc13.bin for the blue pill)."
msgstr ""
"对于常见的STM32F103板，如Blue Pill，和 stm32duino 章节中一样，可以通过 3.3v 串行用stm32flash "
"刷写启动引导程序，将文件名替换为所需的 hid引导程序二进制文件（例如Blue Pill 使用的 hid_generic_pc13.bin）。"

msgid ""
"It is not possible to use stm32flash for the SKR Mini E3 as the boot0 pin is"
" tied directly to ground and not broken out via header pins. It is "
"recommended to use a STLink V2 with STM32Cubeprogrammer to flash the "
"bootloader. If you don't have access to a STLink it is also possible to use "
"a [Raspberry Pi and OpenOCD](#running-openocd-on-the-raspberry-pi) with the "
"following chip config:"
msgstr ""
"SKR Mini E3无法使用stm32flash ，因为boot 0引脚被直接接到GND且没有跳线断开。推荐使用STLink "
"V2通过STM32Cubeprogrammer刷写启动引导程序。如果你没有STLink "
"，也可以按照以下芯片配置使用[树莓派和OpenOCD](#running-openocd-on-the-raspberry-pi) 刷写："

msgid ""
"If you wish you can make a backup of the current flash with the following "
"command. Note that it may take some time to complete:"
msgstr "如果你愿意，可以使用下面的命令备份当前闪存上的程序。请注意，这可能需要一些时间来完成备份："

msgid "finally, you can flash with commands similar to:"
msgstr "最后，你可以用类似以下的命令刷写固件："

msgid "NOTES:"
msgstr "注意："

msgid ""
"The example above erases the chip then programs the bootloader. Regardless "
"of the method chosen to flash it is recommended to erase the chip prior to "
"flashing."
msgstr "上面的例子是先擦除芯片，然后再写入引导程序。无论选择哪种方法刷写，都建议在刷写前擦除芯片。"

msgid ""
"Prior flashing the SKR Mini E3 with this bootloader you should be aware that"
" you will no longer be able to update firmware via the sdcard."
msgstr "在用这个引导程序刷写SKR Mini E3之前，你需要知道之后你将不能再通过SD卡更新固件。"

msgid ""
"This bootloader requires 2KiB of flash space (the application must be "
"compiled with a start address of 2KiB)."
msgstr "这个引导程序需要2KiB的闪存空间（应用程序必须以2KiB的起始地址进行编译）。"

msgid ""
"The hid-flash program is used to upload a binary to the bootloader. You can "
"install this software with the following commands:"
msgstr "hid-flash程序是用来上传二进制文件到启动引导程序的。你可以用以下命令安装这个软件："

msgid "If the bootloader is running you can flash with something like:"
msgstr "如果bootloader正在运行，你可以用这个来刷写："

msgid "alternatively, you can use `make flash` to flash klipper directly:"
msgstr "或者，你可以使用`make flash`来直接刷写klipper："

msgid "OR if klipper has been previously flashed:"
msgstr "或者，如果klipper之前已经被写入过："

msgid ""
"It may be necessary to manually enter the bootloader, this can be done by "
"setting \"boot 0\" low and \"boot 1\" high. On the SKR Mini E3 \"Boot 1\" is"
" not available, so it may be done by setting pin PA2 low if you flashed "
"\"hid_btt_skr_mini_e3.bin\". This pin is labeld \"TX0\" on the TFT header in"
" the SKR Mini E3's \"PIN\" document. There is a ground pin next to PA2 which"
" you can use to pull PA2 low."
msgstr ""
"可能需要手动进入引导程序，这可以通过设置 \"boot 0 \"的低电平和 \"boot 1 \"的高电平来完成。在SKR Mini "
"E3上，\"Boot 1 "
"\"是不可用的，所以如果你写入过\"hid_btt_skr_mini_e3.bin\"，可以通过设置PA2的低电平来完成。在SKR Mini E3的 "
"\"PIN \"文件中，这个引脚在TFT插座上被标记为 \"TX0\"。在PA2旁边有一个接地引脚，你可以用它来把PA2拉低。"

msgid "STM32F4 micro-controllers (SKR Pro 1.1)"
msgstr "STM32F4 微控制器 (SKR Pro 1.1)"

msgid ""
"Unless your board is DFU capable the most accessable flashing method is "
"likely via 3.3v serial, which follows the same procedure as [flashing the "
"STM32F103 using stm32flash](#stm32f103-micro-controllers-blue-pill-devices)."
" For example:"
msgstr ""
"除非你的板子有DFU功能，否则最容易的写入方法可能是通过3.3v的串口，这与[使用stm32flash刷写STM32F103](#stm32f103-micro-"
"controllers-blue-pill-devices)的步骤相同。例如："

msgid ""
"This bootloader requires 16Kib of flash space on the STM32F4 (the "
"application must be compiled with a start address of 16KiB)."
msgstr "这个引导程序在STM32F4上需要16Kib的闪存空间（应用程序必须以16KiB的起始地址进行编译）。"

msgid ""
"As with the STM32F1, the STM32F4 uses the hid-flash tool to upload binaries "
"to the MCU. See the instructions above for details on how to build and use "
"hid-flash."
msgstr ""
"与STM32F1一样，STM32F4使用hid-flash工具来上传二进制文件到MCU。关于如何构建和使用hid-flash的细节，请参见上面的说明。"

msgid ""
"It may be necessary to manually enter the bootloader, this can be done by "
"setting \"boot 0\" low, \"boot 1\" high and plugging in the device. After "
"programming is complete unplug the device and set \"boot 1\" back to low so "
"the application will be loaded."
msgstr ""
"可能需要手动进入引导程序，这可以通过设置 \"boot 0 \"为低电平，\"boot 1 \"为高电平并上电来完成。编程完成后，设备断电，将 "
"\"boot 1 \"重设为低电平，这样应用程序就会被加载。"

msgid "LPC176x micro-controllers (Smoothieboards)"
msgstr "LPC176x微控制器（Smoothieboards）"

msgid "Running OpenOCD on the Raspberry PI"
msgstr "在树莓派上运行OpenOCD"

msgid ""
"OpenOCD is a software package that can perform low-level chip flashing and "
"debugging. It can use the GPIO pins on a Raspberry Pi to communicate with a "
"variety of ARM chips."
msgstr "OpenOCD是一个软件包，可以进行底层的芯片编程和调试。它可以使用树莓派上的GPIO引脚与各种ARM芯片通信。"

msgid ""
"Begin by downloading and compiling the software (each step may take several "
"minutes and the \"make\" step may take 30+ minutes):"
msgstr "开始下载和编译软件（每个步骤可能需要数分钟，\"make \"步骤可能需要30分钟以上）："

msgid "Configure OpenOCD"
msgstr "配置OpenOCD"

msgid "Create an OpenOCD config file:"
msgstr "创建一个OpenOCD配置文件："

msgid "Use a config similar to the following:"
msgstr "使用类似于以下的配置："

msgid "Wire the Raspberry Pi to the target chip"
msgstr "将树莓派与目标芯片相连"

msgid ""
"Poweroff both the the Raspberry Pi and the target chip before wiring! Verify"
" the target chip uses 3.3V prior to connecting to a Raspberry Pi!"
msgstr "在接线之前，请关闭树莓派和目标芯片的电源! 在连接到树莓派之前，请确认目标芯片使用3.3V电压!"

msgid ""
"Connect GND, SWDCLK, SWDIO, and RST on the target chip to GND, GPIO25, "
"GPIO24, and GPIO18 respectively on the Raspberry Pi."
msgstr "将目标芯片上的GND、SWDCLK、SWDIO和RST分别连接到树莓派上的GND、GPIO25、GPIO24和GPIO18。"

msgid "Then power up the Raspberry Pi and provide power to the target chip."
msgstr "然后给树莓派上电，再给目标芯片供电。"

msgid "Run OpenOCD"
msgstr "运行OpenOCD"

msgid "Run OpenOCD:"
msgstr "运行OpenOCD："

msgid ""
"The above should cause OpenOCD to emit some text messages and then wait (it "
"should not immediately return to the Unix shell prompt). If OpenOCD exits on"
" its own or if it continues to emit text messages then double check the "
"wiring."
msgstr ""
"上述操作应该使OpenOCD输出一些文本信息，然后等待（它不会立即返回到Unix "
"shell提示符）。如果OpenOCD自己退出或继续输出文本信息，那么请仔细检查接线。"

msgid ""
"Once OpenOCD is running and is stable, one can send it commands via telnet. "
"Open another ssh session and run the following:"
msgstr "一旦OpenOCD运行稳定，就可以通过telnet向它发送命令。打开另一个ssh会话，运行下面的命令："

msgid ""
"(One can exit telnet by pressing ctrl+] and then running the \"quit\" "
"command.)"
msgstr "(可以按ctrl+]退出telnet，然后运行 \"quit \"命令。)"

msgid "OpenOCD and gdb"
msgstr "OpenOCD和gdb"

msgid ""
"It is possible to use OpenOCD with gdb to debug Klipper. The following "
"commands assume one is running gdb on a desktop class machine."
msgstr "可以使用OpenOCD和gdb来调试Klipper。下面的命令假设是在台式机上运行gdb。"

msgid "Add the following to the OpenOCD config file:"
msgstr "在OpenOCD的配置文件中加入以下内容："

msgid ""
"Restart OpenOCD on the Raspberry Pi and then run the following Unix command "
"on the desktop machine:"
msgstr "在树莓派上重新启动OpenOCD，然后在台式机上运行以下Unix命令："

msgid "Within gdb run:"
msgstr "在gdb中运行："

msgid ""
"(Replace \"octopi\" with the host name of the Raspberry Pi.) Once gdb is "
"running it is possible to set breakpoints and to inspect registers."
msgstr "(用树莓派的主机名替换 \"octopi\"）一旦gdb运行，就可以设置断点并检查寄存器。"

msgid ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/stk500v2/stk500boot_v2_mega2560.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:stk500boot_v2_mega2560.hex\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/stk500v2/stk500boot_v2_mega2560.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:stk500boot_v2_mega2560.hex\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:ATmegaBOOT_168_atmega1280.hex\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:ATmegaBOOT_168_atmega1280.hex\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid ""
"wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/optiboot_atmega1284p.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega1284p.hex\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/optiboot_atmega1284p.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega1284p.hex\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid "teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v\n"
msgstr "teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v\n"

msgid ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid ""
"bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b\n"
"bossac -U -p /dev/ttyACM0 -R\n"
msgstr ""
"bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b\n"
"bossac -U -p /dev/ttyACM0 -R\n"

msgid "bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin\n"
msgstr "bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin\n"

msgid "source [find target/at91samdXX.cfg]\n"
msgstr "source [find target/at91samdXX.cfg]\n"

msgid ""
"wget 'https://github.com/arduino/ArduinoCore-"
"samd/raw/1.8.3/bootloaders/zero/samd21_sam_ba.bin'\n"
msgstr ""
"wget 'https://github.com/arduino/ArduinoCore-"
"samd/raw/1.8.3/bootloaders/zero/samd21_sam_ba.bin'\n"

msgid ""
"at91samd bootloader 0\n"
"program samd21_sam_ba.bin verify\n"
msgstr ""
"at91samd bootloader 0\n"
"program samd21_sam_ba.bin verify\n"

msgid "bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R\n"
msgstr "bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R\n"

msgid ""
"avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid "source [find target/atsame5x.cfg]\n"
msgstr "source [find target/atsame5x.cfg]\n"

msgid ""
"wget "
"'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/bootloader-"
"itsybitsy_m4-v3.7.0.bin'\n"
msgstr ""
"wget "
"'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/bootloader-"
"itsybitsy_m4-v3.7.0.bin'\n"

msgid ""
"at91samd bootloader 0\n"
"program bootloader-itsybitsy_m4-v3.7.0.bin verify\n"
"at91samd bootloader 16384\n"
msgstr ""
"at91samd bootloader 0\n"
"program bootloader-itsybitsy_m4-v3.7.0.bin verify\n"
"at91samd bootloader 16384\n"

msgid "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"
msgstr "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"

msgid "stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0\n"
msgstr "stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0\n"

msgid ""
"wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin'\n"
"\n"
"stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0\n"
msgstr ""
"wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin'\n"
"\n"
"stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0\n"

msgid "dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin\n"
msgstr "dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin\n"

msgid "source [find target/stm32f1x.cfg]\n"
msgstr "source [find target/stm32f1x.cfg]\n"

msgid "flash read_bank 0 btt_skr_mini_e3_backup.bin\n"
msgstr "flash read_bank 0 btt_skr_mini_e3_backup.bin\n"

msgid ""
"stm32f1x mass_erase 0\n"
"program hid_btt_skr_mini_e3.bin verify 0x08000000\n"
msgstr ""
"stm32f1x mass_erase 0\n"
"program hid_btt_skr_mini_e3.bin verify 0x08000000\n"

msgid ""
"You may need to hold down the reset button on the board while launching OpenOCD. It should display something like:Open On-Chip Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00)\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"DEPRECATED! use 'adapter speed' not 'adapter_khz'\n"
"Info : BCM2835 GPIO JTAG/SWD bitbang driver\n"
"Info : JTAG and SWD modes enabled\n"
"Info : clock speed 40 kHz\n"
"Info : SWD DPIDR 0x1ba01477\n"
"Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"Info : stm32f1x.cpu: external reset detected\n"
"Info : starting gdb server for stm32f1x.cpu on 3333\n"
"Info : Listening on port 3333 for gdb connections\n"
msgstr ""
"You may need to hold down the reset button on the board while launching OpenOCD. It should display something like:Open On-Chip Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00)\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"DEPRECATED! use 'adapter speed' not 'adapter_khz'\n"
"Info : BCM2835 GPIO JTAG/SWD bitbang driver\n"
"Info : JTAG and SWD modes enabled\n"
"Info : clock speed 40 kHz\n"
"Info : SWD DPIDR 0x1ba01477\n"
"Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"Info : stm32f1x.cpu: external reset detected\n"
"Info : starting gdb server for stm32f1x.cpu on 3333\n"
"Info : Listening on port 3333 for gdb connections\n"

msgid "After which you can release the reset button."
msgstr "之后可以松开复位按钮。"

msgid ""
"sudo apt install libusb-1.0\n"
"cd ~/klipper/lib/hidflash\n"
"make\n"
msgstr ""
"sudo apt install libusb-1.0\n"
"cd ~/klipper/lib/hidflash\n"
"make\n"

msgid "~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin\n"
msgstr "~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin\n"

msgid "make flash FLASH_DEVICE=1209:BEBA\n"
msgstr "make flash FLASH_DEVICE=1209:BEBA\n"

msgid "make flash FLASH_DEVICE=/dev/ttyACM0\n"
msgstr "make flash FLASH_DEVICE=/dev/ttyACM0\n"

msgid ""
"wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin\n"
"\n"
"stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0\n"
msgstr ""
"wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin\n"
"\n"
"stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0\n"

msgid ""
"sudo apt-get update\n"
"sudo apt-get install autoconf libtool telnet\n"
"mkdir ~/openocd\n"
"cd ~/openocd/\n"
"git clone http://openocd.zylin.com/openocd\n"
"cd openocd\n"
"./bootstrap\n"
"./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/openocd/install\n"
"make\n"
"make install\n"
msgstr ""
"sudo apt-get update\n"
"sudo apt-get install autoconf libtool telnet\n"
"mkdir ~/openocd\n"
"cd ~/openocd/\n"
"git clone http://openocd.zylin.com/openocd\n"
"cd openocd\n"
"./bootstrap\n"
"./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/openocd/install\n"
"make\n"
"make install\n"

msgid "nano ~/openocd/openocd.cfg\n"
msgstr "nano ~/openocd/openocd.cfg\n"

msgid ""
"# Uses RPi pins: GPIO25 for SWDCLK, GPIO24 for SWDIO, GPIO18 for nRST\n"
"source [find interface/raspberrypi2-native.cfg]\n"
"bcm2835gpio_swd_nums 25 24\n"
"bcm2835gpio_srst_num 18\n"
"transport select swd\n"
"\n"
"# Use hardware reset wire for chip resets\n"
"reset_config srst_only\n"
"adapter_nsrst_delay 100\n"
"adapter_nsrst_assert_width 100\n"
"\n"
"# Specify the chip type\n"
"source [find target/atsame5x.cfg]\n"
"\n"
"# Set the adapter speed\n"
"adapter_khz 40\n"
"\n"
"# Connect to chip\n"
"init\n"
"targets\n"
"reset halt\n"
msgstr ""
"# Uses RPi pins: GPIO25 for SWDCLK, GPIO24 for SWDIO, GPIO18 for nRST\n"
"source [find interface/raspberrypi2-native.cfg]\n"
"bcm2835gpio_swd_nums 25 24\n"
"bcm2835gpio_srst_num 18\n"
"transport select swd\n"
"\n"
"# Use hardware reset wire for chip resets\n"
"reset_config srst_only\n"
"adapter_nsrst_delay 100\n"
"adapter_nsrst_assert_width 100\n"
"\n"
"# Specify the chip type\n"
"source [find target/atsame5x.cfg]\n"
"\n"
"# Set the adapter speed\n"
"adapter_khz 40\n"
"\n"
"# Connect to chip\n"
"init\n"
"targets\n"
"reset halt\n"

msgid ""
"cd ~/openocd/\n"
"sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg\n"
msgstr ""
"cd ~/openocd/\n"
"sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg\n"

msgid "telnet 127.0.0.1 4444\n"
msgstr "telnet 127.0.0.1 4444\n"

msgid ""
"bindto 0.0.0.0\n"
"gdb_port 44444\n"
msgstr ""
"bindto 0.0.0.0\n"
"gdb_port 44444\n"

msgid ""
"cd /path/to/klipper/\n"
"gdb out/klipper.elf\n"
msgstr ""
"cd /path/to/klipper/\n"
"gdb out/klipper.elf\n"

msgid "target remote octopi:44444\n"
msgstr "target remote octopi:44444\n"

#: docs/Bootloaders.md:block 1 (header)
msgid "Bootloaders"
msgstr "底层引导程序"

#: docs/Bootloaders.md:block 7 (paragraph)
msgid ""
"In general, the Arduino project is a good reference for bootloaders and "
"flashing procedures on the 8-bit Atmel Atmega micro-controllers. In "
"particular, the \"boards.txt\" file: "
"<https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt>"
" is a useful reference."
msgstr ""
"总体上来说，Arduino项目是8位Atmel Atmega微控制器的引导程序和刷写程序的好的参考。特别是\" boards.txt "
"\"文件。<https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt>是一个有用的参考。"

#: docs/Bootloaders.md:block 32 (paragraph)
msgid ""
"The Teensy++ device from pjrc.com comes with a proprietary bootloader. It "
"requires a custom flashing tool from "
"<https://github.com/PaulStoffregen/teensy_loader_cli>. One can flash an "
"application with it using something like:"
msgstr ""
"来自pjrc.com的Teensy++设备带有一个专用的引导程序。它需要一个来自<https://github.com/PaulStoffregen/teensy_loader_cli>的定制刷写工具。可以用这个工具来刷写一个应用程序，例如："

#: docs/Bootloaders.md:block 42 (paragraph)
msgid ""
"The code at <https://github.com/shumatech/BOSSA> can be used to program the "
"SAM3. It is recommended to use version 1.9 or later."
msgstr "<https://github.com/shumatech/BOSSA>中的代码可以用来为SAM3编程。建议使用1.9或更高版本。"

#: docs/Bootloaders.md:block 48 (paragraph)
msgid ""
"The code at <https://github.com/shumatech/BOSSA> can be used to program the "
"SAM4. It is necessary to use version `1.8.0` or higher."
msgstr ""
"<https://github.com/shumatech/BOSSA>中的代码可以用来为SAM4编程。需要使用`1.8.0`或更高的版本。"

#: docs/Bootloaders.md:block 66 (paragraph)
msgid ""
"Obtain a bootloader - several bootloaders are available from "
"<https://github.com/adafruit/uf2-samdx1/releases/latest>. For example:"
msgstr ""
"获得一个引导程序--"
"很多引导程序可以从<https://github.com/adafruit/uf2-samdx1/releases/latest>获得。例如："

#: docs/Bootloaders.md:block 78 (paragraph)
msgid ""
"The \"stm32duino\" project has a USB capable bootloader - see: "
"<https://github.com/rogerclarkmelbourne/STM32duino-bootloader>"
msgstr ""
"\"stm32duino \"项目有一个USB功能的引导程序-"
"参见：<https://github.com/rogerclarkmelbourne/STM32duino-bootloader>"

#: docs/Bootloaders.md:block 113 (paragraph)
msgid ""
"This document does not describe the method to flash a bootloader itself - "
"see: <http://smoothieware.org/flashing-the-bootloader> for further "
"information on that topic."
msgstr ""
"本文件没有描述刷写引导程序本身的方法--见：<http://smoothieware.org/flashing-the-"
"bootloader>以获得关于该主题的进一步信息。"

#: docs/Bootloaders.md:block 114 (paragraph)
msgid ""
"It is common for Smoothieboards to come with a bootloader from: "
"<https://github.com/triffid/LPC17xx-DFU-Bootloader>. When using this "
"bootloader the application must be compiled with a start address of 16KiB. "
"The easiest way to flash an application with this bootloader is to copy the "
"application file (eg, `out/klipper.bin`) to a file named `firmware.bin` on "
"an SD card, and then to reboot the micro-controller with that SD card."
msgstr ""
"Smoothieboards通常带有一个来自<https://github.com/triffid/LPC17xx-DFU-"
"Bootloader>的bootloader。当使用这个引导程序时，应用程序必须以16KiB的起始地址进行编译。用这个引导程序刷写应用程序的最简单方法是将应用程序文件（例如`out/klipper.bin`）复制到SD卡上一个名为`firmware.bin`的文件，然后用该SD卡重新启动微控制器。"

#: docs/Bootloaders.md:block 117 (paragraph)
msgid ""
"This section describes how one can install and launch OpenOCD. It is derived"
" from the instructions at: <https://learn.adafruit.com/programming-"
"microcontrollers-using-openocd-on-raspberry-pi>"
msgstr ""
"本节描述了如何安装和启动OpenOCD。它来自于以下的说明：<https://learn.adafruit.com/programming-"
"microcontrollers-using-openocd-on-raspberry-pi>"

#: docs/Bootloaders.md:block 75 (paragraph)
msgid ""
"Note that if one is using a Raspberry Pi for the 3.3V serial, the stm32flash"
" protocol uses a serial parity mode which the Raspberry Pi's \"mini UART\" "
"does not support. See "
"<https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-"
"uarts> for details on enabling the full uart on the Raspberry Pi GPIO pins."
msgstr ""
"注意，如果使用树莓派的3.3V串口，stm32flash协议使用的串行奇偶校验模式，树莓派的 \"mini UART "
"\"并不支持。关于在树莓派的GPIO引脚上启用完整的UART的细节，见<https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-"
"uarts>。"

#: docs/Bootloaders.md:block 85 (paragraph)
msgid ""
"The [HID bootloader](https://github.com/Serasidis/STM32_HID_Bootloader) is a"
" compact, driverless bootloader capable of flashing over USB. Also available"
" is a [fork with builds specific to the SKR Mini E3 "
"1.2](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."
msgstr ""
"[HID "
"bootloader](https://github.com/Serasidis/STM32_HID_Bootloader)是一个紧凑的、不包含驱动的启动引导程序，能够通过USB进行刷写。此外，还有一个[针对SKR"
" Mini E3 "
"1.2构建的分支](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)。"

#: docs/Bootloaders.md:block 106 (paragraph)
msgid ""
"STM32F4 microcontrollers come equipped with a built-in system bootloader "
"capable of flashing over USB (via DFU), 3.3v Serial, and various other "
"methods (see STM Document AN2606 for more information). Some STM32F4 boards,"
" such as the SKR Pro 1.1, are not able to enter the DFU bootloader. The HID "
"bootloader is available for STM32F405/407 based boards should the user "
"prefer flashing over USB over using the sdcard. Note that you may need to "
"configure and build a version specific to your board, a [build for the SKR "
"Pro 1.1 is available "
"here](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."
msgstr ""
"STM32F4微控制器配备了一个内置的系统引导程序，能够通过USB（通过DFU）、3.3v串口和其他各种方法进行刷写（更多信息见STM文件AN2606）。一些STM32F4板，如SKR"
" Pro "
"1.1，不能进入DFU引导程序。基于STM32F405/407的板子可以使用HID引导程序，如果用户愿意通过USB刷写而不是使用SD卡。请注意，你可能需针对你的板子配置和构建一个特定的版本，[针对SKR"
" Pro "
"1.1的构建可以在这里找到](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)。"

#: docs/Bootloaders.md:block 105 (header)
msgid "STM32F103/STM32F072 with MSC bootloader"
msgstr "带MSC引导程序的STM32F103/STM32F072"

#: docs/Bootloaders.md:block 106 (paragraph)
msgid ""
"The [MSC bootloader](https://github.com/Telekatz/MSC-stm32f103-bootloader) "
"is a driverless bootloader capable of flashing over USB."
msgstr ""
"[MSC 引导程序](https://github.com/Telekatz/MSC-stm32f103-bootloader) 是一个能够进行 USB"
" 刷写的免驱引导程序。"

#: docs/Bootloaders.md:block 107 (paragraph)
msgid ""
"It is possible to flash the bootloader via 3.3v serial using stm32flash as "
"noted in the stm32duino section above, substituting the file name for the "
"desired MSC bootloader binary (ie: MSCboot-Bluepill.bin for the blue pill)."
msgstr ""
"可以使用 stm32flash 通过 3.3v 串行刷写引导程序，如上面的 stm32duino 章节所述，将文件名替换为所需的 MSC "
"引导加载程序二进制文件（例如：Blue Pill 使用 MSCboot-Bluepill.bin）。"

#: docs/Bootloaders.md:block 108 (paragraph)
msgid ""
"For STM32F072 boards it is also possible to flash the bootloader over USB "
"(via DFU) with something like:"
msgstr "STM32F072板也可以通过USB（通过DFU）刷写引导程序，如下所示："

#: docs/Bootloaders.md:block 109 (code)
msgid ""
" dfu-util -d 0483:df11 -a 0 -R -D  MSCboot-STM32F072.bin "
"-s0x08000000:leave\n"
msgstr ""
" dfu-util -d 0483:df11 -a 0 -R -D  MSCboot-STM32F072.bin "
"-s0x08000000:leave\n"

#: docs/Bootloaders.md:block 110 (paragraph)
msgid ""
"This bootloader uses 8KiB or 16KiB of flash space, see description of the "
"bootloader (the application must be compiled with with the corresponding "
"starting address)."
msgstr "此引导加载程序使用 8KiB 或 16KiB 的闪存空间，请参阅引导加载程序的说明（必须使用相应的起始地址编译应用程序）。"

#: docs/Bootloaders.md:block 111 (paragraph)
msgid ""
"The bootloader can be activated by pressing the reset button of the board "
"twice. As soon as the bootloader is activated, the board appears as a USB "
"flash drive onto which the klipper.bin file can be copied."
msgstr ""
"可以通过按两次电路板上的复位按钮来激活引导程序。一旦启动引导程序，该板就会显示为一个 USB 闪存驱动器，可以将 klipper.bin "
"文件复制到该驱动器上。"

#: docs/Bootloaders.md:block 73 (paragraph)
msgid ""
"The STM32F103 devices have a ROM that can flash a bootloader or application "
"via 3.3V serial. Typically one would wire the PA10 (MCU Rx) and PA9 (MCU Tx)"
" pins to a 3.3V UART adapter. To access the ROM, one should connect the "
"\"boot 0\" pin to high and \"boot 1\" pin to low, and then reset the device."
" The \"stm32flash\" package can then be used to flash the device using "
"something like:"
msgstr ""
"STM32F103设备有一个ROM，可以通过3.3V串口刷写引导程序或应用程序。通常会把PA10（MCU Rx）和PA9（MCU "
"Tx）引脚连接到3.3V UART适配器上。要访问ROM，应该把\"boot 0\"引脚连接到高电平，\"boot "
"1\"引脚连接到低电平，然后重置设备。然后可以用\"stm32flash\"包刷写设备，使用的方法如下："

#: docs/Bootloaders.md:block 112 (header)
msgid "STM32F103/STM32F0x2 with CanBoot bootloader"
msgstr "带有CanBoot引导程序的STM32F103/STM32F0x2"

#: docs/Bootloaders.md:block 113 (paragraph)
msgid ""
"The [CanBoot](https://github.com/Arksine/CanBoot) bootloader provides an "
"option for uploading Klipper firmware over the CANBUS. The bootloader itself"
" is derived from Klipper's source code. Currently CanBoot supports the "
"STM32F103, STM32F042, and STM32F072 models."
msgstr ""
"[CanBoot](https://github.com/Arksine/CanBoot)引导程序提供了一个通过CANBUS上传Klipper固件的选项。该引导程序本身来自Klipper的源代码。目前CanBoot支持STM32F103、STM32F042和STM32F072型号。"

#: docs/Bootloaders.md:block 114 (paragraph)
msgid ""
"It is recommended to use a ST-Link Programmer to flash CanBoot, however it "
"should be possible to flash using `stm32flash` on STM32F103 devices, and "
"`dfu-util` on STM32F042/STM32F072 devices. See the previous sections in this"
" document for instructions on these flashing methods, substituting "
"`canboot.bin` for the file name where appropriate. The CanBoot repo linked "
"above provides instructions for building the bootloader."
msgstr ""
"建议使用ST-"
"Link编程器来刷写CanBoot，然而在STM32F103设备上使用`stm32flash`，在STM32F042/STM32F072设备上使用`dfu-"
"util`应该是可以刷写。关于这些刷写方法的说明，请参见本文的前几节，在适当的地方用`canboot.bin`代替文件名。上面链接的CanBoot "
"repo提供了构建引导程序的说明。"

#: docs/Bootloaders.md:block 115 (paragraph)
msgid ""
"The first time CanBoot has been flashed it should detect that no application"
" is present and enter the bootloader. If this doesn't occur it is possible "
"to enter the bootloader by pressing the reset button twice in succession."
msgstr "在CanBoot第一次被写入时，应该检测到没有应用程序，并进入引导程序。如果没有出现这种情况，可以通过连续按两次复位按钮进入引导程序。"

#: docs/Bootloaders.md:block 116 (paragraph)
msgid ""
"The `flash_can.py` utility supplied in the `lib/canboot` folder may be used "
"to upload Klipper firmware. The device UUID is necessary to flash. If you do"
" not have a UUID it is possible to query nodes currently running the "
"bootloader:"
msgstr ""
"`flash_can.py`在`lib/canboot`文件夹中提供的工具可以用来上传Klipper固件。设备的UUID对于写入固件来说是必要的。如果你没有UUID可以查询当前运行引导程序的节点："

#: docs/Bootloaders.md:block 117 (code)
msgid "python3 flash_can.py -q\n"
msgstr "python3 flash_can.py -q\n"

#: docs/Bootloaders.md:block 118 (paragraph)
msgid ""
"This will return UUIDs for all connected nodes not currently assigned a "
"UUID. This should include all nodes currently in the bootloader."
msgstr "这会返回所有未被分配UUID的节点的UUID。这应该包括当前在bootloader中的所有节点。"

#: docs/Bootloaders.md:block 119 (paragraph)
msgid "Once you have a UUID, you may upload firmware with following command:"
msgstr "一旦你有了UUID，你可以用以下命令上传固件："

#: docs/Bootloaders.md:block 120 (code)
msgid ""
"python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff\n"
msgstr ""
"python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff\n"

#: docs/Bootloaders.md:block 121 (paragraph)
msgid ""
"Where `aabbccddeeff` is replaced by your UUID. Note that the `-i` and `-f` "
"options may be omitted, they default to `can0` and "
"`~/klipper/out/klipper.bin` respectively."
msgstr ""
"其中`aabbccddeeff`被你的UUID取代。注意选项`-i`和`-f`可以被省略，它们分别默认为`can0`和`~/klipper/out/klipper.bin`。"

#: docs/Bootloaders.md:block 122 (paragraph)
msgid ""
"When building Klipper for use with CanBoot, select the 8 KiB Bootloader "
"option."
msgstr "当构建Klipper与CanBoot一起使用时，选择8 KiB Bootloader选项。"

#~ msgid ""
#~ "The STM32F103 devices have a ROM that can flash a bootloader or application "
#~ "via 3.3V serial. To access this ROM, one should connect the \"boot 0\" pin "
#~ "to high and \"boot 1\" pin to low, and then reset the device. The "
#~ "\"stm32flash\" package can then be used to flash the device using something "
#~ "like:"
#~ msgstr ""
#~ "STM32F103 产品线的芯片包含一个可以通过 3.3V 串口刷写引导程序或应用程序的ROM。要访问这个ROM，在\"boot 0 "
#~ "\"引脚接到高电平\"boot 1 \" 引脚接到低电平后重置芯片。然后，可以使用 \"stm32flash \"软件包，使用类似以下的命令刷写："

#~ msgid ""
#~ "The [HID bootloader](https://github.com/Serasidis/STM32_HID_Bootloader) is a"
#~ " compact, driverless bootloader capable of flashing over USB. Also available"
#~ " is a [fork with builds specific to the SKR Mini E3 "
#~ "1.2](https://github.com/Arksine/STM32_HID_Bootloader/releases/tag/v0.5-beta)."
#~ msgstr ""
#~ "[HID 引导加载程序](https://github.com/Serasidis/STM32_HID_Bootloader) "
#~ "是一个紧凑、免驱动的引导加载程序，能够通过 USB 刷写。另外也可以使用 [SKR Mini E3 1.2 "
#~ "专用分支](https://github.com/Arksine/STM32_HID_Bootloader/releases/tag/v0.5-beta)。"

#~ msgid ""
#~ "STM32F4 microcontrollers come equipped with a built-in system bootloader "
#~ "capable of flashing over USB (via DFU), 3.3v Serial, and various other "
#~ "methods (see STM Document AN2606 for more information). Some STM32F4 boards,"
#~ " such as the SKR Pro 1.1, are not able to enter the DFU bootloader. The HID "
#~ "bootloader is available for STM32F405/407 based boards should the user "
#~ "prefer flashing over USB over using the sdcard. Note that you may need to "
#~ "configure and build a version specific to your board, a [build for the SKR "
#~ "Pro 1.1 is available "
#~ "here](https://github.com/Arksine/STM32_HID_Bootloader/releases/tag/v0.5-beta)."
#~ msgstr ""

#~ msgid ""
#~ "Note that if one is using a Raspberry Pi for the 3.3V serial, the stm32flash"
#~ " protocol uses a serial parity mode which the Raspberry Pi's \"miniuart\" "
#~ "does not support. See "
#~ "<https://www.raspberrypi.org/documentation/configuration/uart.md> for "
#~ "details on enabling the full uart on the Raspberry Pi GPIO pins."
#~ msgstr ""
