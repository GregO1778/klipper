# mirokymac <toufubomb@gmail.com>, 2021, 2022.
# Yifei Ding <dingyifeiair@gmail.com>, 2021, 2022.
# Neko.vecter <Vecterfang@icloud.com>, 2022.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2022-07-07 00:09+0000\n"
"Last-Translator: Yifei Ding <dingyifeiair@gmail.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/klipper/kinematics/zh_Hans/>\n"
"Language: zh_Hans\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.13.1-dev\n"

msgid ""
"This document provides an overview of how Klipper implements robot motion "
"(its [kinematics](https://en.wikipedia.org/wiki/Kinematics)). The contents "
"may be of interest to both developers interested in working on the Klipper "
"software as well as users interested in better understanding the mechanics "
"of their machines."
msgstr ""
"该文档提供Klipper实现机械[运动学](https://en.wikipedia.org/wiki/Kinematics)控制的概述，以供 "
"致力于完善Klipper的开发者 或 希望对自己的设备的机械原理有进一步了解的爱好者 参考。"

msgid "Acceleration"
msgstr "加速"

msgid ""
"Klipper implements a constant acceleration scheme whenever the print head "
"changes velocity - the velocity is gradually changed to the new speed "
"instead of suddenly jerking to it. Klipper always enforces acceleration "
"between the tool head and the print. The filament leaving the extruder can "
"be quite fragile - rapid jerks and/or extruder flow changes lead to poor "
"quality and poor bed adhesion. Even when not extruding, if the print head is"
" at the same level as the print then rapid jerking of the head can cause "
"disruption of recently deposited filament. Limiting speed changes of the "
"print head (relative to the print) reduces risks of disrupting the print."
msgstr ""
"Klipper总使用常加速度策略——打印头的速度总是梯度变化到新的速度，而非使用速度突变的方式。Klipper着眼于打印件和打印头之间的速度变化。离开挤出机的耗材十分脆弱，突然的移动速度和/或挤出流量突变可能会导致造成打印质量或床黏着能力的下降。甚至在无挤出时，如果打印头和打印件顶端在同一水平面时，喷嘴的速度突变有可能对刚挤出的耗材进行剐蹭。限制打印头相对于打印件的速度，可以减少剐蹭打印件的风险。"

msgid ""
"It is also important to limit acceleration so that the stepper motors do not"
" skip or put excessive stress on the machine. Klipper limits the torque on "
"each stepper by virtue of limiting the acceleration of the print head. "
"Enforcing acceleration at the print head naturally also limits the torque of"
" the steppers that move the print head (the inverse is not always true)."
msgstr ""
"限制减速度也能减少步进电机丢步和炸机的状况。Klipper通过限制打印头的加速度来限制每个步进电机的力矩。限制打印头的加速度自然也限制了移动打印头的步进器的扭矩（反之则不一定）。"

msgid ""
"Klipper implements constant acceleration. The key formula for constant "
"acceleration is:"
msgstr "Klipper实现恒加速度控制，关键的方程如下："

msgid "Trapezoid generator"
msgstr "梯形发生器"

msgid ""
"Klipper uses a traditional \"trapezoid generator\" to model the motion of "
"each move - each move has a start speed, it accelerates to a cruising speed "
"at constant acceleration, it cruises at a constant speed, and then "
"decelerates to the end speed using constant acceleration."
msgstr ""
"Klipper 使用传统的\"梯形发生器\"来产生每个动作的运动--"
"每个动作都有一个起始速度，先恒定的加速度加速到一个巡航速度，再以恒定的速度巡航，最后用恒定的加速度减速到终点速度。"

msgid "![trapezoid](img/trapezoid.svg.png)"
msgstr "![trapezoid](img/trapezoid.svg.png)"

msgid ""
"It's called a \"trapezoid generator\" because a velocity diagram of the move"
" looks like a trapezoid."
msgstr "因为移动时的速度图看起来像一个梯形，它被称为 \"梯形发生器\"。"

msgid ""
"The cruising speed is always greater than or equal to both the start speed "
"and the end speed. The acceleration phase may be of zero duration (if the "
"start speed is equal to the cruising speed), the cruising phase may be of "
"zero duration (if the move immediately starts decelerating after "
"acceleration), and/or the deceleration phase may be of zero duration (if the"
" end speed is equal to the cruising speed)."
msgstr ""
"巡航速度总是大于等于起始和终端速度。加速度阶段可能持续时间为0（如果起始速度等于巡航速度），巡航速度的持续时间也可为0（如果在加速结束后马上进行减速），减速阶段也能为0（如果终端速度等于巡航速度）。"

msgid "![trapezoids](img/trapezoids.svg.png)"
msgstr "![trapezoids](img/trapezoids.svg.png)"

msgid "Look-ahead"
msgstr "预计算（look-ahead）"

msgid ""
"The \"look-ahead\" system is used to determine cornering speeds between "
"moves."
msgstr "拐角速度使用预计算系统进行处理。"

msgid "Consider the following two moves contained on an XY plane:"
msgstr "考虑以下两个在 XY 平面上的移动："

msgid "![corner](img/corner.svg.png)"
msgstr "![corner](img/corner.svg.png)"

msgid ""
"In the above situation it is possible to fully decelerate after the first "
"move and then fully accelerate at the start of the next move, but that is "
"not ideal as all that acceleration and deceleration would greatly increase "
"the print time and the frequent changes in extruder flow would result in "
"poor print quality."
msgstr ""
"在上述的状况下，打印机可以在第一步时减速至停止，并在第二步开始时加速至巡航速度。但这种运动策略并不理想，完全减速和完全加速会大幅增加打印时间，同时挤出量会频繁变动，从而导致打印质量的下降。"

msgid ""
"To solve this, the \"look-ahead\" mechanism queues multiple incoming moves "
"and analyzes the angles between moves to determine a reasonable speed that "
"can be obtained during the \"junction\" between two moves. If the next move "
"is nearly in the same direction then the head need only slow down a little "
"(if at all)."
msgstr ""
"要解决这种情况，klipper引入了预计算机制，预先依次计算后续的数个移动，分析其中的拐角并确定合适的拐角速度。如果下一步的速度与现时的移动速度相近，则滑车速度仅会稍微减少。"

msgid "![lookahead](img/lookahead.svg.png)"
msgstr "![lookahead](img/lookahead.svg.png)"

msgid ""
"However, if the next move forms an acute angle (the head is going to travel "
"in nearly a reverse direction on the next move) then only a small junction "
"speed is permitted."
msgstr "然而，如果下一步形成一个尖锐的拐角（滑车将在下一步进行近于反方向的移动），则只能采用一个很低的拐角速度。"

msgid "![lookahead](img/lookahead-slow.svg.png)"
msgstr "![lookahead](img/lookahead-slow.svg.png)"

msgid ""
"The junction speeds are determined using \"approximated centripetal "
"acceleration\". Best [described by the "
"author](https://onehossshay.wordpress.com/2011/09/24/improving_grbl_cornering_algorithm/)."
" However, in Klipper, junction speeds are configured by specifying the "
"desired speed that a 90° corner should have (the \"square corner "
"velocity\"), and the junction speeds for other angles are derived from that."
msgstr ""
"转角速度由“近似向心加速度”确定。最好[由作者描述](https://onehossshay.wordpress.com/2011/09/24/improving_grbl_cornering_algorithm/)。然而在Klipper中转角速度是通过指定90°角应该有的理想速度（“直角速度”）并且其他的角度的转角速度也是根据它推导出来的。"

msgid "Key formula for look-ahead:"
msgstr "预计算的关键方程："

msgid "Smoothed look-ahead"
msgstr "预计算结果平滑"

msgid ""
"Klipper also implements a mechanism for smoothing out the motions of short "
"\"zigzag\" moves. Consider the following moves:"
msgstr "Klipper 实现了一种用于平滑短距离之字形移动的机制。参考以下移动："

msgid "![zigzag](img/zigzag.svg.png)"
msgstr "![zigzag](img/zigzag.svg.png)"

msgid ""
"In the above, the frequent changes from acceleration to deceleration can "
"cause the machine to vibrate which causes stress on the machine and "
"increases the noise. To reduce this, Klipper tracks both regular move "
"acceleration as well as a virtual \"acceleration to deceleration\" rate. "
"Using this system, the top speed of these short \"zigzag\" moves are limited"
" to smooth out the printer motion:"
msgstr ""
"在上述情况下，从加速到减速的频繁变化会导致机器振动并且会对机器造成压力和加噪音。为了减少这种情况，Klipper既跟踪常规的移动加速度并且也跟踪虚拟的\"加减速率\"。利用这个系统，这些短的\"zigzag\"移动的最高速度被限制以使得打印机的运动可以更加平滑："

msgid "![smoothed](img/smoothed.svg.png)"
msgstr "![smoothed](img/smoothed.svg.png)"

msgid ""
"Specifically, the code calculates what the velocity of each move would be if"
" it were limited to this virtual \"acceleration to deceleration\" rate (half"
" the normal acceleration rate by default). In the above picture the dashed "
"gray lines represent this virtual acceleration rate for the first move. If a"
" move can not reach its full cruising speed using this virtual acceleration "
"rate then its top speed is reduced to the maximum speed it could obtain at "
"this virtual acceleration rate. For most moves the limit will be at or above"
" the move's existing limits and no change in behavior is induced. For short "
"zigzag moves, however, this limit reduces the top speed. Note that it does "
"not change the actual acceleration within the move - the move continues to "
"use the normal acceleration scheme up to its adjusted top-speed."
msgstr ""
"具体来说，代码计算的是限制在这个虚拟的“加速到减速”率下时（默认为正常加速率的一半），每个动作的速度是多少。在上图中，灰色虚线代表了第一段移动时的虚拟加速率。如果一段移动使用这个虚拟加速度不能达到目标巡航速度，那么这段移动的最高速度将被降低到它在这个虚拟加速率下所能获得的最大速度。对于大多数移动来说，该限制将处于或高于该移动的现有限制，并且不会改变移动的行为。然而，对于短的"
" \"之 \"字形移动，这个限制会降低最高速度。请注意，它不会改变移动中的实际加速度--移动会继续使用正常的加速，直到其调整后的最高速度。"

msgid "Generating steps"
msgstr "生成步数（Generating steps）"

msgid ""
"Once the look-ahead process completes, the print head movement for the given"
" move is fully known (time, start position, end position, velocity at each "
"point) and it is possible to generate the step times for the move. This "
"process is done within \"kinematic classes\" in the Klipper code. Outside of"
" these kinematic classes, everything is tracked in millimeters, seconds, and"
" in cartesian coordinate space. It's the task of the kinematic classes to "
"convert from this generic coordinate system to the hardware specifics of the"
" particular printer."
msgstr ""
"前瞻过程完成后给定移动的打印头运动已被确定（时间、开始位置、结束位置、每一点的速度），可以被用于生成移动的步进时间。这个过程是在Klipper代码的运动学类中完成的。在这些运动学类之外，所有的东西都是以毫米、秒为单位，在笛卡尔坐标空间进行跟踪。运动学类负责将这个通用坐标系统转换为符合打印机硬件特性的坐标系。"

msgid ""
"Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm) to generate the step times for each stepper. The code "
"contains the formulas to calculate the ideal cartesian coordinates of the "
"head at each moment in time, and it has the kinematic formulas to calculate "
"the ideal stepper positions based on those cartesian coordinates. With these"
" formulas, Klipper can determine the ideal time that the stepper should be "
"at each step position. The given steps are then scheduled at these "
"calculated times."
msgstr ""
"Klipper使用一个[迭代求解器](https://zh.wikipedia.org/wiki/%E6%B1%82%E6%A0%B9%E7%AE%97%E6%B3%95)来生成每个步进的步进时间。该代码包含了计算打印头在每个时间点上的理想笛卡尔坐标的公式，它还有运动学公式来计算基于这些笛卡尔坐标的理想步进位置。通过这些公式，Klipper可以确定步进电机在每个步进位置时的理想步进时间。然后在这些计算出的时间内安排给定的步进。"

msgid ""
"The key formula to determine how far a move should travel under constant "
"acceleration is:"
msgstr "确定一个移动在恒定加速度下应该移动多远的关键公式是："

msgid "and the key formula for movement with constant velocity is:"
msgstr "并且匀速运动的关键公式是："

msgid ""
"The key formulas for determining the cartesian coordinate of a move given a "
"move distance is:"
msgstr "在给定移动距离的情况下用于确定移动的笛卡尔坐标的关键公式为："

msgid "Cartesian Robots"
msgstr "笛卡尔机器"

msgid ""
"Generating steps for cartesian printers is the simplest case. The movement "
"on each axis is directly related to the movement in cartesian space."
msgstr "为笛卡尔坐标的打印机生成步进是最简单的情况。每个轴上的运动与笛卡尔空间中的运动直接相关。"

msgid "Key formulas:"
msgstr "关键公式："

msgid "CoreXY Robots"
msgstr "CoreXY 机器"

msgid ""
"Generating steps on a CoreXY machine is only a little more complex than "
"basic cartesian robots. The key formulas are:"
msgstr "在CoreXY的机器上生成步进只比基本的卡特尔机器人复杂一点。关键公式是："

msgid "Delta Robots"
msgstr "三角洲机器"

msgid "Step generation on a delta robot is based on Pythagoras's theorem:"
msgstr "三角洲结构机器人上的步进生成基于勾股定理："

msgid "Stepper motor acceleration limits"
msgstr "步进电机加速限制"

msgid ""
"With delta kinematics it is possible for a move that is accelerating in "
"cartesian space to require an acceleration on a particular stepper motor "
"greater than the move's acceleration. This can occur when a stepper arm is "
"more horizontal than vertical and the line of movement passes near that "
"stepper's tower. Although these moves could require a stepper motor "
"acceleration greater than the printer's maximum configured move "
"acceleration, the effective mass moved by that stepper would be smaller. "
"Thus the higher stepper acceleration does not result in significantly higher"
" stepper torque and it is therefore considered harmless."
msgstr ""
"在三角洲机器运动时，打印头在笛卡尔空间中运动进行一定加速度的加速运动，其对应轴的步进电机需要高于前述加速度的加速度。这种状况在一打印壁需提供的水平运动幅度大于垂直运动幅度，并且，运动直线靠近某一垂柱时发生。尽管这些运动会要求步进电机的加速度超过打印机的加速度设置限额，但单个步进电机需要承担的有效质量是相对较小的。因此，增加的步进电机加速度不会显著增加步进电机的扭矩需求，可认为这种现象是无害的。"

msgid ""
"However, to avoid extreme cases, Klipper enforces a maximum ceiling on "
"stepper acceleration of three times the printer's configured maximum move "
"acceleration. (Similarly, the maximum velocity of the stepper is limited to "
"three times the maximum move velocity.) In order to enforce this limit, "
"moves at the extreme edge of the build envelope (where a stepper arm may be "
"nearly horizontal) will have a lower maximum acceleration and velocity."
msgstr ""
"然而，为了避免极端状况，Klipper强制将步进电机的加速度上限设置为打印机加速度上限的3倍。（同样，步进电机的速度上限也设置为打印机速度上限的3倍。）为了实现上述设置，在打印区域水平边沿的（存在打印臂接近水平的）位置，打印头的速度和加速度上限将相应降低。"

msgid "Extruder kinematics"
msgstr "挤出机运动学"

msgid ""
"Klipper implements extruder motion in its own kinematic class. Since the "
"timing and speed of each print head movement is fully known for each move, "
"it's possible to calculate the step times for the extruder independently "
"from the step time calculations of the print head movement."
msgstr ""
"Klipper 在自身的运动学类中实现了挤出机的运动。由于每个打印头运动的时间和速度是完全已知的，因此可以独立于打印头运动的步长计算来计算挤出机的步长。"

msgid ""
"Basic extruder movement is simple to calculate. The step time generation "
"uses the same formulas that cartesian robots use:"
msgstr "基本的挤出机运动计算起来很简单。步进时间的生成使用和笛卡尔结构相同的公式："

msgid "Pressure advance"
msgstr "压力提前"

msgid ""
"Experimentation has shown that it's possible to improve the modeling of the "
"extruder beyond the basic extruder formula. In the ideal case, as an "
"extrusion move progresses, the same volume of filament should be deposited "
"at each point along the move and there should be no volume extruded after "
"the move. Unfortunately, it's common to find that the basic extrusion "
"formulas cause too little filament to exit the extruder at the start of "
"extrusion moves and for excess filament to extrude after extrusion ends. "
"This is often referred to as \"ooze\"."
msgstr ""
"实验表明，在基本的挤出机方程之上可以改进挤出机的模型。在理想情况下，随着挤出移动的进行，沿移动的每个点应寄出相同体积的耗材，并且在移动后不应挤出任何耗材。不幸的是，在实际情况下，基本的挤出机方程会导致在挤出运动开始时挤出过少的耗材，并且在挤出结束后挤出过多的耗材。这通常被称为“溢料”。"

msgid "![ooze](img/ooze.svg.png)"
msgstr "![溢料](img/ooze.svg.png)"

msgid ""
"The \"pressure advance\" system attempts to account for this by using a "
"different model for the extruder. Instead of naively believing that each "
"mm^3 of filament fed into the extruder will result in that amount of mm^3 "
"immediately exiting the extruder, it uses a model based on pressure. "
"Pressure increases when filament is pushed into the extruder (as in [Hooke's"
" law](https://en.wikipedia.org/wiki/Hooke%27s_law)) and the pressure "
"necessary to extrude is dominated by the flow rate through the nozzle "
"orifice (as in [Poiseuille's "
"law](https://en.wikipedia.org/wiki/Poiseuille_law)). The key idea is that "
"the relationship between filament, pressure, and flow rate can be modeled "
"using a linear coefficient:"
msgstr ""
"\"压力推进\"系统试图通过使用一个不同的挤出机模型来解决这个问题。它不理想的假设送入挤出机的每mm^3耗材将导致该体积的mm^3立即被挤出，而是使用基于压力的模型。当耗材被推入挤出机时，压力会增加（如[胡克定律](https://en.wikipedia.org/wiki/Hooke%27s_law)），而挤出所需的压力则由通过喷嘴孔口的流速决定（如[泊伊维尔定律](https://en.wikipedia.org/wiki/Poiseuille_law)）。关键的想法是，耗材、压力和流速之间的关系可以用一个线性系数来建模："

msgid ""
"See the [pressure advance](Pressure_Advance.md) document for information on "
"how to find this pressure advance coefficient."
msgstr "有关如何测量压力提前系数的信息，请参阅 [压力提前](Pressure_Advance.md) 文档。"

msgid ""
"The basic pressure advance formula can cause the extruder motor to make "
"sudden velocity changes. Klipper implements \"smoothing\" of the extruder "
"movement to avoid this."
msgstr "基本的压力推进公式会对挤出机电机的速度进行很大的瞬时调整。Klipper 通过实施挤出机运动的\"平滑\"（smoothing）以避免这种情况。"

msgid "![pressure-advance](img/pressure-velocity.png)"
msgstr "![pressure-advance](img/pressure-velocity.png)"

msgid ""
"The above graph shows an example of two extrusion moves with a non-zero "
"cornering velocity between them. Note that the pressure advance system "
"causes additional filament to be pushed into the extruder during "
"acceleration. The higher the desired filament flow rate, the more filament "
"must be pushed in during acceleration to account for pressure. During head "
"deceleration the extra filament is retracted (the extruder will have a "
"negative velocity)."
msgstr ""
"上图以两个挤出运动为例，它们之间的转弯速度不为零。请注意，压力推进系统在加速过程中会导致额外的耗材被推入挤出机。所需的耗材流量越高，在加速过程中必须推入更多的耗材以均衡压力。在打印头减速期间，额外的耗材会被回抽（挤出机将有一个负速度）。"

msgid ""
"The \"smoothing\" is implemented using a weighted average of the extruder "
"position over a small time period (as specified by the "
"`pressure_advance_smooth_time` config parameter). This averaging can span "
"multiple g-code moves. Note how the extruder motor will start moving prior "
"to the nominal start of the first extrusion move and will continue to move "
"after the nominal end of the last extrusion move."
msgstr ""
"“平滑”由挤出机位置在一小段时间内的加权平均值实现的（由 `pressure_advance_smooth_time` "
"配置参数指定）。这种平均可以跨越多个 g "
"代码移动。请注意，挤出机电机将如何在第一次挤出运动的标称起点之前开始移动，并在最后一次挤出运动的标称结束之后继续移动。"

msgid "Key formula for \"smoothed pressure advance\":"
msgstr "\"平滑压力提前\"的关键公式："

msgid "velocity(time) = start_velocity + accel*time\n"
msgstr "velocity(time) = start_velocity + accel*time\n"

msgid "end_velocity^2 = start_velocity^2 + 2*accel*move_distance\n"
msgstr "end_velocity^2 = start_velocity^2 + 2*accel*move_distance\n"

msgid "move_distance = (start_velocity + .5 * accel * move_time) * move_time\n"
msgstr "move_distance = (start_velocity + .5 * accel * move_time) * move_time\n"

msgid "move_distance = cruise_velocity * move_time\n"
msgstr "move_distance = cruise_velocity * move_time\n"

msgid ""
"cartesian_x_position = start_x + move_distance * total_x_movement / total_movement\n"
"cartesian_y_position = start_y + move_distance * total_y_movement / total_movement\n"
"cartesian_z_position = start_z + move_distance * total_z_movement / total_movement\n"
msgstr ""
"cartesian_x_position = start_x + move_distance * total_x_movement / total_movement\n"
"cartesian_y_position = start_y + move_distance * total_y_movement / total_movement\n"
"cartesian_z_position = start_z + move_distance * total_z_movement / total_movement\n"

msgid ""
"stepper_x_position = cartesian_x_position\n"
"stepper_y_position = cartesian_y_position\n"
"stepper_z_position = cartesian_z_position\n"
msgstr ""
"stepper_x_position = cartesian_x_position\n"
"stepper_y_position = cartesian_y_position\n"
"stepper_z_position = cartesian_z_position\n"

msgid ""
"stepper_a_position = cartesian_x_position + cartesian_y_position\n"
"stepper_b_position = cartesian_x_position - cartesian_y_position\n"
"stepper_z_position = cartesian_z_position\n"
msgstr ""
"stepper_a_position = cartesian_x_position + cartesian_y_position\n"
"stepper_b_position = cartesian_x_position - cartesian_y_position\n"
"stepper_z_position = cartesian_z_position\n"

msgid ""
"stepper_position = (sqrt(arm_length^2\n"
"                         - (cartesian_x_position - tower_x_position)^2\n"
"                         - (cartesian_y_position - tower_y_position)^2)\n"
"                    + cartesian_z_position)\n"
msgstr ""
"stepper_position = (sqrt(arm_length^2\n"
"                         - (cartesian_x_position - tower_x_position)^2\n"
"                         - (cartesian_y_position - tower_y_position)^2)\n"
"                    + cartesian_z_position)\n"

msgid "stepper_position = requested_e_position\n"
msgstr "stepper_position = requested_e_position\n"

msgid ""
"pa_position = nominal_position + pressure_advance_coefficient * "
"nominal_velocity\n"
msgstr ""
"pa_position = nominal_position + pressure_advance_coefficient * "
"nominal_velocity\n"

msgid ""
"smooth_pa_position(t) =\n"
"    ( definitive_integral(pa_position(x) * (smooth_time/2 - abs(t - x)) * dx,\n"
"                          from=t-smooth_time/2, to=t+smooth_time/2)\n"
"     / (smooth_time/2)^2 )\n"
msgstr ""
"smooth_pa_position(t) =\n"
"    ( definitive_integral(pa_position(x) * (smooth_time/2 - abs(t - x)) * dx,\n"
"                          from=t-smooth_time/2, to=t+smooth_time/2)\n"
"     / (smooth_time/2)^2 )\n"

#: docs/Kinematics.md:block 1 (header)
msgid "Kinematics"
msgstr "运动学"
