# mirokymac <toufubomb@gmail.com>, 2021.
# Yifei Ding <dingyifeiair@gmail.com>, 2021, 2022.
# Neko.vecter <Vecterfang@icloud.com>, 2022.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2022-08-08 09:23+0000\n"
"Last-Translator: Neko.vecter <Vecterfang@icloud.com>\n"
"Language-Team: Chinese (Simplified) <https://hosted.weblate.org/projects/klipper/code_overview/zh_Hans/>\n"
"Language: zh_Hans\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14-dev\n"

msgid ""
"This document describes the overall code layout and major code flow of "
"Klipper."
msgstr "本文档将描述Klipper的代码总体结构和代码流。"

msgid "Directory Layout"
msgstr "文件夹结构"

msgid ""
"The **src/** directory contains the C source for the micro-controller code. "
"The **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, "
"**src/lpc176x/**, **src/pru/**, and **src/stm32/** directories contain "
"architecture specific micro-controller code. The **src/simulator/** contains"
" code stubs that allow the micro-controller to be test compiled on other "
"architectures. The **src/generic/** directory contains helper code that may "
"be useful across different architectures. The build arranges for includes of"
" \"board/somefile.h\" to first look in the current architecture directory "
"(eg, src/avr/somefile.h) and then in the generic directory (eg, "
"src/generic/somefile.h)."
msgstr ""
"**src/**包含微控制器的C源码。其中**src/atsam/**, **src/atsamd/**, **src/avr/**, "
"**src/linux/**, **src/lpc176x/**, **src/pru/**, and **src/stm32/** "
"为对应微处理器架构的源码。 **src/simulator/** "
"包含有用于交叉编译、测试目标微处理器的代码。**src/generic/**为对不同架构均有用的代码。编译\"board/somefile.h\"时，编译器会优先使用"
" 架构特定的目录 (即src/avr/somefile.h)随后找寻通用目录(即 src/generic/somefile.h)。"

msgid ""
"The **klippy/** directory contains the host software. Most of the host "
"software is written in Python, however the **klippy/chelper/** directory "
"contains some C code helpers. The **klippy/kinematics/** directory contains "
"the robot kinematics code. The **klippy/extras/** directory contains the "
"host code extensible \"modules\"."
msgstr ""
"**klippy/**目录包含了上位机软件。软件大部分由Python实现，同时**klippy/chelper/** "
"目录包含了由C实现的有用代码。**klippy/kinematics/**目录包含机械运动学的实现代码。**klippy/extras/** "
"目录包含了上位机的扩建模块(\"modules\")。"

msgid ""
"The **lib/** directory contains external 3rd-party library code that is "
"necessary to build some targets."
msgstr "**lib/**包含了构建必须的第三方库代码。"

msgid ""
"The **config/** directory contains example printer configuration files."
msgstr "**config/**包含了打印机配置的实例文件。"

msgid ""
"The **scripts/** directory contains build-time scripts useful for compiling "
"the micro-controller code."
msgstr "**scripts/**目录包含了编译微控制器代码时有用的脚本。"

msgid "The **test/** directory contains automated test cases."
msgstr "**test/**目录包含了自动测试示例。"

msgid ""
"During compilation, the build may create an **out/** directory. This "
"contains temporary build time objects. The final micro-controller object "
"that is built is **out/klipper.elf.hex** on AVR and **out/klipper.bin** on "
"ARM."
msgstr ""
"在编译过程重，编译器会构建**out/**目录。该目录包含构建时的临时文件。对于AVR架构，编译器输出的为**out/klipper.elf.hex**，而对ARM架构则为**out/klipper.bin**。"

msgid "Micro-controller code flow"
msgstr "微处理器的代码流"

msgid ""
"Execution of the micro-controller code starts in architecture specific code "
"(eg, **src/avr/main.c**) which ultimately calls sched_main() located in "
"**src/sched.c**. The sched_main() code starts by running all functions that "
"have been tagged with the DECL_INIT() macro. It then goes on to repeatedly "
"run all functions tagged with the DECL_TASK() macro."
msgstr ""
"微控制器的代码从对应架构的代码(即**src/avr/main.c**)开始执行，前述代码会持续调用**src/sched.c**中的 "
"sched_main() 函数。sched_main() 代码会先运行经 DECL_INIT() 宏标注的所有函数。之后它将不断重复运行由 "
"DECL_TASK() 宏所标注的函数。"

msgid ""
"One of the main task functions is command_dispatch() located in "
"**src/command.c**. This function is called from the board specific "
"input/output code (eg, **src/avr/serial.c**, **src/generic/serial_irq.c**) "
"and it runs the command functions associated with the commands found in the "
"input stream. Command functions are declared using the DECL_COMMAND() macro "
"(see the [protocol](Protocol.md) document for more information)."
msgstr ""
"其中一个主要的任务函数为**src/command.c** 中的command_dispatch()。上述函数经由微处理器特定的 输入/输出 "
"代码调用(即**src/avr/serial.c**, "
"**src/generic/serial_irq.c**)，并执行输入流中的命令所对应的命令函数。命令函数通过 DECL_COMMAND() 宏进行定义"
" (详情参照[协议](Protocol.md) 文档)。"

msgid ""
"Timer functions are scheduled by calling sched_add_timer() (located in "
"**src/sched.c**). The scheduler code will arrange for the given function to "
"be called at the requested clock time. Timer interrupts are initially "
"handled in an architecture specific interrupt handler (eg, "
"**src/avr/timer.c**) which calls sched_timer_dispatch() located in "
"**src/sched.c**. The timer interrupt leads to execution of schedule timer "
"functions. Timer functions always run with interrupts disabled. The timer "
"functions should always complete within a few micro-seconds. At completion "
"of the timer event, the function may choose to reschedule itself."
msgstr ""
"定时函数通过调用sched_add_timer() (即 "
"**src/sched.c**)方法进行注册。调度器会在设定的时间点对注册的函数进行调用。定时器中断会在微处理器架构特定的初始化处理器中处理(例如 "
"**src/avr/timer.c**)，该代码会调用 "
"**src/sched.c**中的sched_timer_dispatch()。通过定时器中断执行注册的定时函数。定时函数总在中断禁用下运行。定时函数应总能在数微秒内完成。在定时函数结束时，该函数可对自身进行重新定时。"

msgid ""
"In the event an error is detected the code can invoke shutdown() (a macro "
"which calls sched_shutdown() located in **src/sched.c**). Invoking "
"shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
"run. Shutdown functions always run with interrupts disabled."
msgstr ""
"如果事件中抛出错误， "
"代码可调用shutdown()（**src/sched.c**中的sched_shutdown()）。调用shutdown()会导致所有标记为DECL_SHUTDOWN()宏的函数被运行。shutdown()总是在禁用中断的情况下运行。"

msgid ""
"Much of the functionality of the micro-controller involves working with "
"General-Purpose Input/Output pins (GPIO). In order to abstract the low-level"
" architecture specific code from the high-level task code, all GPIO events "
"are implemented in architecture specific wrappers (eg, **src/avr/gpio.c**). "
"The code is compiled with gcc's \"-flto -fwhole-program\" optimization which"
" does an excellent job of inlining functions across compilation units, so "
"most of these tiny gpio functions are inlined into their callers, and there "
"is no run-time cost to using them."
msgstr ""
"微控制器的大部分功能涉及到通用输入输出引脚（GPIO）的操作。为了从高级任务代码中抽象出特定架构底层代码，所有的GPIO事件都在特定架构的包装器中实现（如，**src/avr/gpio.c**）。代码使用gcc的\"-flto"
" -fwhole-program "
"\"来优化编译，以实现内联函数的高性能交叉编译，大多数微小的GPIO操作函数内联到它们的调用器中，使用这些GPIO将没有任何运行时成本。"

msgid "Klippy code overview"
msgstr "代码总览"

msgid ""
"The host code (Klippy) is intended to run on a low-cost computer (such as a "
"Raspberry Pi) paired with the micro-controller. The code is primarily "
"written in Python, however it does use CFFI to implement some functionality "
"in C code."
msgstr ""
"上位机程序（klippy）运行在廉价计算机（如 树莓派）上，配搭mcu使用。该程序的主要编程语言为Python，同时部分功能通过CFFI在C语言上实现。"

msgid ""
"Initial execution starts in **klippy/klippy.py**. This reads the command-"
"line arguments, opens the printer config file, instantiates the main printer"
" objects, and starts the serial connection. The main execution of G-code "
"commands is in the process_commands() method in **klippy/gcode.py**. This "
"code translates the G-code commands into printer object calls, which "
"frequently translate the actions to commands to be executed on the micro-"
"controller (as declared via the DECL_COMMAND macro in the micro-controller "
"code)."
msgstr ""
"上位机程序通过** "
"klippy/klippy.py**初始化。该文件会读取命令行参数，打开打印机的设置文件，实例化打印机的主要模块，并启用串口通讯。G代码命令的执行则通过"
" **klippy/gcode.py**中的 process_commands() "
"方法实现。此代码将G代码转化为打印机的对象调用，它将频繁地将G代码命令转化为微控制器的行动指令（通过微控制器代码中的 DECL_COMMAND "
"进行声明）。"

msgid ""
"There are four threads in the Klippy host code. The main thread handles "
"incoming gcode commands. A second thread (which resides entirely in the "
"**klippy/chelper/serialqueue.c** C code) handles low-level IO with the "
"serial port. The third thread is used to process response messages from the "
"micro-controller in the Python code (see **klippy/serialhdl.py**). The "
"fourth thread writes debug messages to the log (see "
"**klippy/queuelogger.py**) so that the other threads never block on log "
"writes."
msgstr ""
"Klippy上位机程序包含四个进程。主线程用于处理输入的G代码命令。第二线程通过串口实现底层IO的处理（代码位于 "
"**klippy/chelper/serialqueue.c **以C语言实现）。第三线程则通过Python代码处理微控制器返回的信息（参照 "
"klippy/serialhdl.py）。第四线程则负责将Debug信息写入到日志文件(见 "
"**klippy/queuelogger.py**)，由此，其他线程的执行将不会阻塞日志的写入。"

msgid "Code flow of a move command"
msgstr "典型运动命令的代码流"

msgid ""
"A typical printer movement starts when a \"G1\" command is sent to the "
"Klippy host and it completes when the corresponding step pulses are produced"
" on the micro-controller. This section outlines the code flow of a typical "
"move command. The [kinematics](Kinematics.md) document provides further "
"information on the mechanics of moves."
msgstr ""
"典型的打印机运动始于klipper上位机接收到\"G1\"命令，并在微控制器发出对应的步进脉冲结束。本节将简述典型运动命令的代码流。[运动学](Kinematics.md)文档将更为细致的描述运动的机械原理。"

msgid ""
"Processing for a move command starts in gcode.py. The goal of gcode.py is to"
" translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
"klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
"origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
"unit changes (eg, F6000=100mm/s). The code path for a move is: "
"`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
"ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
"ToolHead.move()`"
msgstr ""
"移动命令的处理始于gcode.py，该代码将G代码转化为内部调用。G1命令将调用klippy/extras/gcode_move.py中的cmd_G1()函数。gcode_move.py中的代码将处理"
" 原点变换（G92），绝对坐标模式（G90）和单位变换（如F6000=100mm/s）。一个移动命令的处理路径为：`_process_data() ->"
" _process_commands() -> cmd_G1()`。最终将调用ToolHead类的方法实现移动 `cmd_G1() -> "
"ToolHead.move()`。"

msgid ""
"The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the "
"timing of printing actions. The main codepath for a move is: "
"`ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> "
"Move.set_junction() -> ToolHead._process_moves()`."
msgstr ""
"ToolHead类（位于toolhead.py）处理“前瞻”行为和记录打印的时间点。移动命令的代码路径为 `ToolHead.move() -> "
"MoveQueue.add_move() -> MoveQueue.flush() -> Move.set_junction() -> "
"ToolHead._process_moves()`。"

msgid ""
"ToolHead.move() creates a Move() object with the parameters of the move (in "
"cartesian space and in units of seconds and millimeters)."
msgstr "ToolHead.move()将创建一个Move()对象实例，其中将包含移动的参数（在笛卡尔空间中，并这些参数以mm和s为单位）。"

msgid ""
"The kinematics class is given the opportunity to audit each move "
"(`ToolHead.move() -> kin.check_move()`). The kinematics classes are located "
"in the klippy/kinematics/ directory. The check_move() code may raise an "
"error if the move is not valid. If check_move() completes successfully then "
"the underlying kinematics must be able to handle the move."
msgstr ""
"kinematics类将检查每个运动命令（`ToolHead.move() -> kin.check_move()`）。各种kinematics类存放于"
" klippy/kinematics/ 目录。check_move()能在运动命令不合理时抛出错误。如果 "
"check_move()成功，这意味着打印机必定能完成运动命令。"

msgid "MoveQueue.add_move() places the move object on the \"look-ahead\" queue."
msgstr "MoveQueue.add_move()将一个move实例添加到“前瞻”队列。"

msgid ""
"MoveQueue.flush() determines the start and end velocities of each move."
msgstr "MoveQueue.flush()将进行每次运动 起始和结束 速度。"

msgid ""
"Move.set_junction() implements the \"trapezoid generator\" on a move. The "
"\"trapezoid generator\" breaks every move into three parts: a constant "
"acceleration phase, followed by a constant velocity phase, followed by a "
"constant deceleration phase. Every move contains these three phases in this "
"order, but some phases may be of zero duration."
msgstr ""
"Move.set_junction()实现移动的“梯形加减速（trapezoid "
"generator）”。“梯形加减速”将每次移动拆分为三部分：恒加速度加速阶段、恒速度阶段、恒加速度减速阶段。所有移动均含有上述三个阶段，但单个阶段的持续时间可能为0。"

msgid ""
"When ToolHead._process_moves() is called, everything about the move is known"
" - its start location, its end location, its acceleration, its "
"start/cruising/end velocity, and distance traveled during "
"acceleration/cruising/deceleration. All the information is stored in the "
"Move() class and is in cartesian space in units of millimeters and seconds."
msgstr ""
"当ToolHead._process_moves()被调用时，一次移动的所有要素均已就绪——移动的起始位置、结束位置、加速度、起始/巡航/结束速度、以及起始/巡航/结束的距离。所有信息以笛卡尔坐标的形式存储在Move()实例中，单位为mm和s。"

msgid ""
"Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm) to generate the step times for each stepper. For "
"efficiency reasons, the stepper pulse times are generated in C code. The "
"moves are first placed on a \"trapezoid motion queue\": "
"`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
"The step times are then generated: `ToolHead._process_moves() -> "
"ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
"itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
"klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
"step times given a function that calculates a stepper position from a time. "
"This is done by repeatedly \"guessing\" various times until the stepper "
"position formula returns the desired position of the next step on the "
"stepper. The feedback produced from each guess is used to improve future "
"guesses so that the process rapidly converges to the desired time. The "
"kinematic stepper position formulas are located in the klippy/chelper/ "
"directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
msgstr ""
"Klipper使用[迭代求解](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm)的方式生成步进电机的每步的时长。为了提高效率，步进脉冲时间是以C语言代码生成。一个运动先经过“梯形运动队列化” "
"：`ToolHead._process_moves() -> trapq_append()` (位于 "
"klippy/chelper/trapq.c)，然后生成步进时间 `ToolHead._process_moves() -> "
"ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
"itersolve_generate_steps() -> itersolve_gen_steps_range()` (位于 "
"klippy/chelper/itersolve.c)。迭代求解器通过一个时间-位置方程计算出步进时间。求解时通过“假定”时间点，以时间-"
"位置方程计算出下一步的位置。如果计算结果与实际需求的下一步位置一致，假定值将用于实际运动；否则，通过计算结果对“假定时间”进行修正，并进行下一次试算。这种反馈方式会使迭代快速收敛。运动学所使用的时间-"
"位置函数位于 klippy/chelper/ 目录 (例如, kin_cart.c, kin_corexy.c, kin_delta.c, "
"kin_extruder.c)。"

msgid ""
"Note that the extruder is handled in its own kinematic class: "
"`ToolHead._process_moves() -> PrinterExtruder.move()`. Since the Move() "
"class specifies the exact movement time and since step pulses are sent to "
"the micro-controller with specific timing, stepper movements produced by the"
" extruder class will be in sync with head movement even though the code is "
"kept separate."
msgstr ""
"需要注意，挤出机有独特的运动学模型，使用`ToolHead._process_moves() -> "
"PrinterExtruder.move()`类继续宁处理。尽管挤出机使用了独立的Move()类，由于Move() "
"实例包含了实际运动的时间，并且脉冲时间的设备是定时发送到微控制器上，因此由挤出机类产生的步进运动将与打印头的运动同步。"

msgid ""
"After the iterative solver calculates the step times they are added to an "
"array: `itersolve_gen_steps_range() -> stepcompress_append()` (in "
"klippy/chelper/stepcompress.c). The array (struct stepcompress.queue) stores"
" the corresponding micro-controller clock counter times for every step. Here"
" the \"micro-controller clock counter\" value directly corresponds to the "
"micro-controller's hardware counter - it is relative to when the micro-"
"controller was last powered up."
msgstr ""
"当迭代计算器计算出步进时长后，计算结果将被置于一个数组中：`itersolve_gen_steps_range() -> "
"stepcompress_append()` (位于 klippy/chelper/stepcompress.c)。数组(结构体 "
"stepcompress.queue)存储每一步对应的微处理器时钟计数器时间。上述的“微处理器计数器”的值指的是微处理器硬件上的计数器——其值基于微处理器最后一次上电而定。"

msgid ""
"The next major step is to compress the steps: `stepcompress_flush() -> "
"compress_bisect_add()` (in klippy/chelper/stepcompress.c). This code "
"generates and encodes a series of micro-controller \"queue_step\" commands "
"that correspond to the list of stepper step times built in the previous "
"stage. These \"queue_step\" commands are then queued, prioritized, and sent "
"to the micro-controller (via stepcompress.c:steppersync and "
"serialqueue.c:serialqueue)."
msgstr ""
"接下来重要的是，对步进数据进行压缩： `stepcompress_flush() -> compress_bisect_add()` (位于 "
"klippy/chelper/stepcompress.c)。上述代码将基于前述的 步进时间列表 "
"生成和编码一系列的微控制器\"queue_step\"（队列步进）命令。这些\"queue_step\"命令将被队列化，优先处理，并发送到微控制器中（上位机通过"
" stepcompress.c:steppersync；下位机通过serialqueue.c:serialqueue)）。"

msgid ""
"Processing of the queue_step commands on the micro-controller starts in "
"src/command.c which parses the command and calls `command_queue_step()`. The"
" command_queue_step() code (in src/stepper.c) just appends the parameters of"
" each queue_step command to a per stepper queue. Under normal operation the "
"queue_step command is parsed and queued at least 100ms before the time of "
"its first step. Finally, the generation of stepper events is done in "
"`stepper_event()`. It's called from the hardware timer interrupt at the "
"scheduled time of the first step. The stepper_event() code generates a step "
"pulse and then reschedules itself to run at the time of the next step pulse "
"for the given queue_step parameters. The parameters for each queue_step "
"command are \"interval\", \"count\", and \"add\". At a high-level, "
"stepper_event() runs the following, 'count' times: `do_step(); "
"next_wake_time = last_wake_time + interval; interval += add;`"
msgstr ""
"在微控制器，queue_step命令将经由 src/command.c 处理。改代码将对命令进行解释，并调用 "
"`command_queue_step()`。command_queue_step()（位于src/stepper.c）将每个queue_step命令的参数附加到对应的步进队列中。正常运行下，一“步”将在其执行前100ms被解释并加入队列。最后通过"
" "
"`stepper_event()`结束步进事件的生成。该代码会基于queue_step命令的参数生成步进脉冲，并安排下一次步进脉冲生成的时间。硬件定时器发出中断，在设定的事件调用相应的stepper_event。queue_step命令的参数包含“间隔”、“计数”、“增量”。总体而言，stepper_event()将执行下列内容，“记录时间”:"
" `do_step(); next_wake_time = last_wake_time + interval; interval += add;`"

msgid ""
"The above may seem like a lot of complexity to execute a movement. However, "
"the only really interesting parts are in the ToolHead and kinematic classes."
" It's this part of the code which specifies the movements and their timings."
" The remaining parts of the processing is mostly just communication and "
"plumbing."
msgstr ""
"上面的运动过程看似十分复杂。然而，真正需要注意的只有ToolHead（打印头） 和 kinematic "
"（运动学）类，上述两个类的代码确定了运动执行和定时。剩下的代码仅用于处理通讯和管道的问题。"

msgid "Adding a host module"
msgstr "添加上位机模块"

msgid ""
"The Klippy host code has a dynamic module loading capability. If a config "
"section named \"[my_module]\" is found in the printer config file then the "
"software will automatically attempt to load the python module "
"klippy/extras/my_module.py . This module system is the preferred method for "
"adding new functionality to Klipper."
msgstr ""
"Klippy上位机的主程序能对模块进行热加载。如果设置文件中出现了类似\"[my_module]\" 的字段名，程序会自动尝试加载 "
"klippy/extras/my_module.py 文件内的模块。Klipper推荐使用上述方式扩展Klipper功能。"

msgid ""
"The easiest way to add a new module is to use an existing module as a "
"reference - see **klippy/extras/servo.py** as an example."
msgstr "新增模块的最简单的方式是参照已有的模块 - 下面将以 **klippy/extras/servo.py **作为例子。"

msgid "The following may also be useful:"
msgstr "下面是另一些有用的信息："

msgid ""
"Execution of the module starts in the module level `load_config()` function "
"(for config sections of the form [my_module]) or in `load_config_prefix()` "
"(for config sections of the form [my_module my_name]). This function is "
"passed a \"config\" object and it must return a new \"printer object\" "
"associated with the given config section."
msgstr ""
"模块的运作起始于模块级别的`load_config()`函数（针对形如 [my_module] "
"的配置块）或`load_config_prefix()`（对 [my_module my_name] 配置块）。该方法将接受一个 \"config\" "
"对象并必须返回一个与目标功能相关的新\"printer object\"。"

msgid ""
"During the process of instantiating a new printer object, the config object "
"can be used to read parameters from the given config section. This is done "
"using `config.get()`, `config.getfloat()`, `config.getint()`, etc. methods. "
"Be sure to read all values from the config during the construction of the "
"printer object - if the user specifies a config parameter that is not read "
"during this phase then it will be assumed it is a typo in the config and an "
"error will be raised."
msgstr ""
"在创建新\"printer object\"的实例时，可以使用\"config\"对象读取配置文件中相应配置块中的信息。此时可使用 "
"`config.get()`，`config.getfloat()`， `config.getint()`等方法。应确保所需的参数在 \"printer"
" object\" 构建阶段时完成读取。如果用户参数没有在该阶段完成读取，程序将认为这是配置中的错字，并抛出异常。"

msgid ""
"Use the `config.get_printer()` method to obtain a reference to the main "
"\"printer\" class. This \"printer\" class stores references to all the "
"\"printer objects\" that have been instantiated. Use the "
"`printer.lookup_object()` method to find references to other printer "
"objects. Almost all functionality (even core kinematic modules) are "
"encapsulated in one of these printer objects. Note, though, that when a new "
"module is instantiated, not all other printer objects will have been "
"instantiated. The \"gcode\" and \"pins\" modules will always be available, "
"but for other modules it is a good idea to defer the lookup."
msgstr ""
"使用 `config.get_printer()` "
"方法获取主\"printer\"类的引用。该\"printer\"类存储了所有实例化了的\"printer "
"objects\"的引用。使用`printer.lookup_object()`方法获取其他\"printer "
"objects\"的引用。几乎全部的功能（包括运动控制模块）都包装为\"printer "
"objects\"。需要注意的是，当一个新模块实例化的时候，并非所有其他的\"printer "
"objects\"均已完成实例化。其中\"gcode\"和\"pins\"模块总是可用，但对于其他模块最好推迟查找。"

msgid ""
"Register event handlers using the `printer.register_event_handler()` method "
"if the code needs to be called during \"events\" raised by other printer "
"objects. Each event name is a string, and by convention it is the name of "
"the main source module that raises the event along with a short name for the"
" action that is occurring (eg, \"klippy:connect\"). The parameters passed to"
" each event handler are specific to the given event (as are exception "
"handling and execution context). Two common startup events are:"
msgstr ""
"如果代码需要在其他\"printer "
"objects\"发起事件（event）时被调用，可通过`printer.register_event_handler()`注册事件处理函数。每个事件的名称是一个字符串，按照惯例，它是引发该事件的主要源模块的名称，以及正在发生的动作的简短名称（例如，\"klippy:connect\"）。传递给事件处理函数的参数因处理函数而异（异常处理和执行环境也是如此）。常见的两种起始事件为："

msgid ""
"klippy:connect - This event is generated after all printer objects are "
"instantiated. It is commonly used to lookup other printer objects, to verify"
" config settings, and to perform an initial \"handshake\" with printer "
"hardware."
msgstr ""
"klippy:connect - 该事件在所有 \"printer objects\" 实例化后发起。它通常用于查找其他\"printer "
"objects\"，核实配置，并与mcu进行初始握手。"

msgid ""
"klippy:ready - This event is generated after all connect handlers have "
"completed successfully. It indicates the printer is transitioning to a state"
" ready to handle normal operations. Do not raise an error in this callback."
msgstr ""
"klippy:ready - 该事件在所有connect处理程序成功地完成后发起。它意味着打印机转为等待常规指令的待命状态。不应在该回调函数中抛出异常。"

msgid ""
"If there is an error in the user's config, be sure to raise it during the "
"`load_config()` or \"connect event\" phases. Use either `raise "
"config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
" report the error."
msgstr ""
"如果用户配置中存在错误，应在`load_config()`或连接事件（connect event）中抛出异常。使用 `raise "
"config.error(\"my error\")` 或 `raise printer.config_error(\"my error\")` "
"进行告警。"

msgid ""
"Use the \"pins\" module to configure a pin on a micro-controller. This is "
"typically done with something similar to "
"`printer.lookup_object(\"pins\").setup_pin(\"pwm\", "
"config.get(\"my_pin\"))`. The returned object can then be commanded at run-"
"time."
msgstr ""
"使用\"pins\"模块对微控制器的引脚进行定义，例如`printer.lookup_object(\"pins\").setup_pin(\"pwm\","
" config.get(\"my_pin\"))`。此后，运行时，可通过返回的对象对针脚进行控制。"

msgid ""
"If the module needs access to system timing or external file descriptors "
"then use `printer.get_reactor()` to obtain access to the global \"event "
"reactor\" class. This reactor class allows one to schedule timers, wait for "
"input on file descriptors, and to \"sleep\" the host code."
msgstr ""
"如果模块需要使用系统时钟或外部文件描述符，可通过`printer.get_reactor()`对获取全局事件反应器进行访问（event "
"reactor）。通过该反应器类可以部署定时器，等待文件描述符输入，或者“挂起”上位机程序。"

msgid ""
"Do not use global variables. All state should be stored in the printer "
"object returned from the `load_config()` function. This is important as "
"otherwise the RESTART command may not perform as expected. Also, for similar"
" reasons, if any external files (or sockets) are opened then be sure to "
"register a \"klippy:disconnect\" event handler and close them from that "
"callback."
msgstr ""
"不应使用全局变量。全部状态量应存储于 \"printer objects\"，并通过 "
"`load_config()`进行访问。否则，RESTART命令的行为将无法预测。同样，任何在运行时打开的外部文件（或套接字），应在\"klippy:disconnect\"的事件内注册相应的回调函数进行关闭。"

msgid ""
"Avoid accessing the internal member variables (or calling methods that start"
" with an underscore) of other printer objects. Observing this convention "
"makes it easier to manage future changes."
msgstr "应避免访问其他\"printer objects\"私有对象属性（或调用命名以下划线开始的方法）。遵循这一方式可方便之后的变更。"

msgid ""
"If submitting the module for inclusion in the main Klipper code, be sure to "
"place a copyright notice at the top of the module. See the existing modules "
"for the preferred format."
msgstr "若需向 klipper 母分支提交模块的代码，请在模块代码的头部加入版权声明。详请参考已有模块的格式。"

msgid "Adding new kinematics"
msgstr "增加新运动学模型"

msgid ""
"This section provides some tips on adding support to Klipper for additional "
"types of printer kinematics. This type of activity requires excellent "
"understanding of the math formulas for the target kinematics. It also "
"requires software development skills - though one should only need to update"
" the host software."
msgstr ""
"本节将提供为Klipper增加新运动学模型的提示。这需要对目标运动学方程有深入的了解。这同时需要一定的软件开发技巧—尽管大多情况下只需要更新上位机软件。"

msgid "Useful steps:"
msgstr "有用的步骤："

msgid ""
"Start by studying the \"[code flow of a move](#code-flow-of-a-move-"
"command)\" section and the [Kinematics document](Kinematics.md)."
msgstr ""
"开始应研究 \"[移动命令工作流](#code-flow-of-a-move-command)\" 章节和 [动力学](Kinematics.md)."

msgid ""
"Review the existing kinematic classes in the klippy/kinematics/ directory. "
"The kinematic classes are tasked with converting a move in cartesian "
"coordinates to the movement on each stepper. One should be able to copy one "
"of these files as a starting point."
msgstr ""
"参考位于klippy/kinematics/目录已有的运动学类。动力学类旨在将一个笛卡尔坐标系中的运动转化为各个步进电机的运动。建议复制已有的代码，并在其基础上进行修改。"

msgid ""
"Implement the C stepper kinematic position functions for each stepper if "
"they are not already available (see kin_cart.c, kin_corexy.c, and "
"kin_delta.c in klippy/chelper/). The function should call `move_get_coord()`"
" to convert a given move time (in seconds) to a cartesian coordinate (in "
"millimeters), and then calculate the desired stepper position (in "
"millimeters) from that cartesian coordinate."
msgstr ""
"若需要的运动学方程未被Klipper涵盖，则应使用C语言实现新动力学体系中各个步进电机的位置方程（见klippy/chelper/，如kin_cart.c,"
" kin_corexy.c, and kin_delta.c）。位置方程中应调用`move_get_coord()`以将运动的时间点（单位 "
"：秒）转化为对应的笛卡尔坐标位置（单位：毫米），进而计算目标步进电机运动目标位置（单位：毫米）。"

msgid ""
"Implement the `calc_position()` method in the new kinematics class. This "
"method calculates the position of the toolhead in cartesian coordinates from"
" the position of each stepper. It does not need to be efficient as it is "
"typically only called during homing and probing operations."
msgstr ""
"在新的运动学类中实现`calc_position`方法。该方法将通过各个步进电机的位置计算笛卡尔坐标系下的打印头位置；同时该方法通常只在回零和z探测时使用，因此无需过分追求效率。"

msgid ""
"Other methods. Implement the `check_move()`, `get_status()`, "
"`get_steppers()`, `home()`, and `set_position()` methods. These functions "
"are typically used to provide kinematic specific checks. However, at the "
"start of development one can use boiler-plate code here."
msgstr ""
"之后实现`check_move()`, `get_status()`, `get_steppers()`, `home()`, "
"`set_position()`方法。这些函数用于特定的运动学检查。在开发的初期，可以直接使用已有代码。"

msgid ""
"Implement test cases. Create a g-code file with a series of moves that can "
"test important cases for the given kinematics. Follow the [debugging "
"documentation](Debugging.md) to convert this g-code file to micro-controller"
" commands. This is useful to exercise corner cases and to check for "
"regressions."
msgstr ""
"添加测试实例。创建一个G代码文件，其中包含一系列的运动命令用于测试新增的运动学模型。 按照[调试文档](Debugging.md)将该G代码文件转换为微控制器命令。在遭遇困难状况和检查数据传递相当有用。"

msgid "Porting to a new micro-controller"
msgstr "移植到新的微控制器"

msgid ""
"This section provides some tips on porting Klipper's micro-controller code "
"to a new architecture. This type of activity requires good knowledge of "
"embedded development and hands-on access to the target micro-controller."
msgstr "该节将介绍将Klipper微控制器代码移植到新架构时的一些提示。该操作将需要对嵌入式开发有一定的认识并应有目标微控制器的开发平台。"

msgid ""
"Start by identifying any 3rd party libraries that will be used during the "
"port. Common examples include \"CMSIS\" wrappers and manufacturer \"HAL\" "
"libraries. All 3rd party code needs to be GNU GPLv3 compatible. The 3rd "
"party code should be committed to the Klipper lib/ directory. Update the "
"lib/README file with information on where and when the library was obtained."
" It is preferable to copy the code into the Klipper repository unchanged, "
"but if any changes are required then those changes should be listed "
"explicitly in the lib/README file."
msgstr ""
"首先应确定移植所需的第三方库。常见的例子为“CMSIS”包装器和厂商的“HAL”库。全部第三方代码应遵循或兼容GNU "
"GPLv3协议。第三方代码应提交到Klipper的/lib文件夹。更新lib/README注明第三方库的获取途径和更新时间。推荐不改变内容，直接将代码复制到Klipper，但如果需要进行变更，应将所做的修改列在lib/README文件中。"

msgid ""
"Create a new architecture sub-directory in the src/ directory and add "
"initial Kconfig and Makefile support. Use the existing architectures as a "
"guide. The src/simulator provides a basic example of a minimum starting "
"point."
msgstr ""
"在src/下新建一个新架构的子目录，并创建对应的初始Kconfig和Makefile。以已有的架构作为模版，其中src/simulator给出了微控制器架构的基本需求。"

msgid ""
"Get familiar with the the console.py tool (as described in the [debugging "
"document](Debugging.md)) and verify connectivity to the micro-controller "
"with it. This tool translates the low-level micro-controller communication "
"protocol to a human readable form."
msgstr ""
"依照[调试文档](Debugging.md)熟悉console.py工具，并使用该工具核实微控制器的连接。该工具将底层微控制器通讯协议转换为可读形式。"

msgid ""
"Create a sample Klipper config file in the config/ directory. Test the "
"micro-controller with the main klippy.py program."
msgstr "在config/目录新建一个配置事例，并使用Klipper.py的主程序进行设置。"

msgid "Consider adding build test cases in the test/ directory."
msgstr "考虑在test/目录加入构建测试的事例。"

msgid "Coordinate Systems"
msgstr "坐标系变换"

msgid ""
"Internally, Klipper primarily tracks the position of the toolhead in "
"cartesian coordinates that are relative to the coordinate system specified "
"in the config file. That is, most of the Klipper code will never experience "
"a change in coordinate systems. If the user makes a request to change the "
"origin (eg, a `G92` command) then that effect is obtained by translating "
"future commands to the primary coordinate system."
msgstr ""
"内部而言，Klipper使用笛卡尔坐标系追踪打印头的位置，其坐标系设置相对于设置文件中的坐标系而变化。因此，KIlipper的执行在绝大部分情况下都不会变换坐标系。如果用户进行原点的变换（如执行`G92`命令），Klipper会将后续命令转化到原始坐标系上进行执行。"

msgid ""
"However, in some cases it is useful to obtain the toolhead position in some "
"other coordinate system and Klipper has several tools to facilitate that. "
"This can be seen by running the GET_POSITION command. For example:"
msgstr ""
"然而，在部分情况下，需要获取其他坐标系中打印头的位置。Klipper提供数种工具以实现上述功能。运行GET_POSITION可以获得上述数据，如："

msgid ""
"The \"stepper\" position (`stepper.get_commanded_position()`) is the "
"position of the given stepper as tracked by the kinematics code. This "
"generally corresponds to the position (in mm) of the carriage along its "
"rail, relative to the position_endstop specified in the config file. (Some "
"kinematics track stepper positions in radians instead of millimeters.) If "
"the robot is in motion when the query is issued then the reported value "
"includes moves buffered on the micro-controller, but does not include moves "
"on the look-ahead queue. One may use the `toolhead.flush_step_generation()` "
"or `toolhead.wait_moves()` calls to fully flush the look-ahead and step "
"generation code."
msgstr ""
"“步进电机”部分（`stepper.get_commanded_position()`）是运动学模型中记录的特定步进电机位置。通常是对应轨道的相对于设定中的position_endstop设定值的滑车位置（单位为毫米，但部分设定中使用的是弧度单位而非线性单位）。如果在机械运动时触发上述代码，则返回的值为微控制器中缓存的位置，而不包含预计队列（look-"
"ahead "
"queue）中的预计位置。可使用`toolhead.flush_step_generation()`或`toolhead.wati_moves()`调用完全刷新预计队列和步进脉冲生成代码。"

msgid ""
"The \"kinematic\" position (`kin.calc_position()`) is the cartesian position"
" of the toolhead as derived from \"stepper\" positions and is relative to "
"the coordinate system specified in the config file. This may differ from the"
" requested cartesian position due to the granularity of the stepper motors. "
"If the robot is in motion when the \"stepper\" positions are taken then the "
"reported value includes moves buffered on the micro-controller, but does not"
" include moves on the look-ahead queue. One may use the "
"`toolhead.flush_step_generation()` or `toolhead.wait_moves()` calls to fully"
" flush the look-ahead and step generation code."
msgstr ""
"运动学位置（`kin.cal_position()`）是在笛卡尔坐标上的，衍生于步进电机位置的，相对于设置文件中position_endstop值的位置。由于步进电机的分辨率原因，这可能与请求的笛卡尔坐标值不一致。如果在机械运动时触发上述代码，则返回的值为微控制器中缓存的位置，而不包含预计队列（look-"
"ahead "
"queue）中的预计位置。可使用`toolhead.flush_step_generation()`或`toolhead.wati_moves()`调用完全刷新预计队列和步进脉冲生成代码。"

msgid ""
"The \"toolhead\" position (`toolhead.get_position()`) is the last requested "
"position of the toolhead in cartesian coordinates relative to the coordinate"
" system specified in the config file. If the robot is in motion when the "
"query is issued then the reported value includes all requested moves (even "
"those in buffers waiting to be issued to the stepper motor drivers)."
msgstr ""
"打印头位置（`toolhead.get_position()`）是最后的运动请求对应的，相对于设置文件限位位置的，笛卡尔坐标上的打印头位置。如果在机械运动时触发上述代码，那么返回值会依据请求运动序列中的运动终点给出（尽管buffer中的运动还没由步进电机触发）。"

msgid ""
"The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
"command in cartesian coordinates relative to the coordinate system specified"
" in the config file. This may differ from the \"toolhead\" position if a "
"g-code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in "
"effect. This may differ from the actual coordinates specified in the last "
"`G1` command if the g-code origin has been changed (eg, `G92`, "
"`SET_GCODE_OFFSET`, `M221`). The `M114` command "
"(`gcode_move.get_status()['gcode_position']`) will report the last g-code "
"position relative to the current g-code coordinate system."
msgstr ""
"G代码位置时最后一次位置请求命令（`G1`或`G0`）对应的，在笛卡尔坐标系中相对设定文件中的设定原点的相对位置。这可能与“打印头位置”不一致，这是因为G代码修正的影响（比如床网，床倾角修正，调平螺母修正）。这也会因为G代码原点变更（如`G92`，`SET_GCODE_OFFSET`，`M221`）而导致返回值跟最后一次`G1`命令请求的位置不一致。`Ｍ114`命令（`gcode_move.get_status()[’gcode_position’]`）会返回现时G代码相对于此时的G代码原点的位置。"

msgid ""
"The \"gcode base\" is the location of the g-code origin in cartesian "
"coordinates relative to the coordinate system specified in the config file. "
"Commands such as `G92`, `SET_GCODE_OFFSET`, and `M221` alter this value."
msgstr ""
"G代码基准是笛卡尔坐标系中相对于设定文件中的设定原点的相对位置。诸如`G92`，`SET_GCODE_OFFSET`和`M221`会改变的返回值。"

msgid ""
"The \"gcode homing\" is the location to use for the g-code origin (in "
"cartesian coordinates relative to the coordinate system specified in the "
"config file) after a `G28` home command. The `SET_GCODE_OFFSET` command can "
"alter this value."
msgstr ""
"G代码回零点是在`G28`命令执行后G代码原点。同样，该位置是笛卡尔坐标系中，相对于设置文件原点的位置。`SET_GCODE_OFFSET`命令会改变该值。"

msgid "Time"
msgstr "定时"

msgid ""
"Fundamental to the operation of Klipper is the handling of clocks, times, "
"and timestamps. Klipper executes actions on the printer by scheduling events"
" to occur in the near future. For example, to turn on a fan, the code might "
"schedule a change to a GPIO pin in a 100ms. It is rare for the code to "
"attempt to take an instantaneous action. Thus, the handling of time within "
"Klipper is critical to correct operation."
msgstr ""
"该节将描述Klipper如何处理时钟，定时和时间戳。Klipper通过提前安排需要执行的行为事件从而执行动作。例如，要启动风扇，代码需要安排GPIO针脚在100ms后变化。代码立即执行动作反而是罕见的状况。因此，Klipper的正确运行离不开对时间的精确处理。"

msgid ""
"There are three types of times tracked internally in the Klipper host "
"software:"
msgstr "Klipper内部使用三种不同的时间："

msgid ""
"System time. The system time uses the system's monotonic clock - it is a "
"floating point number stored as seconds and it is (generally) relative to "
"when the host computer was last started. System times have limited use in "
"the software - they are primarily used when interacting with the operating "
"system. Within the host code, system times are frequently stored in "
"variables named *eventtime* or *curtime*."
msgstr ""
"系统时间（System "
"time）。系统时间使用系统的单调时钟。这是一个以秒为单位储存的浮点数，在系统启动后开始累计。系统时钟的用途有限，通常只会在与操作系统进行互动时使用。在上位机中，系统时间保存在*eventtime*或*curtime*变量中。"

msgid ""
"Print time. The print time is synchronized to the main micro-controller "
"clock (the micro-controller defined in the \"[mcu]\" config section). It is "
"a floating point number stored as seconds and is relative to when the main "
"mcu was last restarted. It is possible to convert from a \"print time\" to "
"the main micro-controller's hardware clock by multiplying the print time by "
"the mcu's statically configured frequency rate. The high-level host code "
"uses print times to calculate almost all physical actions (eg, head "
"movement, heater changes, etc.). Within the host code, print times are "
"generally stored in variables named *print_time* or *move_time*."
msgstr ""
"打印时间（Print "
"time）。打印时间会与主微控制器时钟同步（在“[MCU]”设置段中定义的微控制器。）这是一个以秒为单位储存的浮点数，并在主微控制最后一次启动后开始从0累加。通过乘以设定的微控制器频率，可以获得主微控制器内部硬件时钟值。上层应用可以通过打印时间计算几乎所有物理行为（比如打印头运动，加热器变动等）。在上位机代码中，打印时间通常保存在*print_time*和*move_time*变量中。"

msgid ""
"MCU clock. This is the hardware clock counter on each micro-controller. It "
"is stored as an integer and its update rate is relative to the frequency of "
"the given micro-controller. The host software translates its internal times "
"to clocks before transmission to the mcu. The mcu code only ever tracks time"
" in clock ticks. Within the host code, clock values are tracked as 64bit "
"integers, while the mcu code uses 32bit integers. Within the host code, "
"clocks are generally stored in variables with names containing *clock* or "
"*ticks*."
msgstr ""
"MCU时钟，是各个微控制内部的硬件时钟累加器。它是基于微控制器设定频率为速率进行累加的，以整形保存的值。上位机软件将软件内部时间转换为mcu时间并将命令传输到微控制器上。微控制代码仅在时钟跳动时更新和追踪时间。在上位机代码中，时钟值以64位整形记录，而微控制代码则使用32位整形。在上位机代码中，时钟通常以*clock*或*tick*变量保存。"

msgid ""
"Conversion between the different time formats is primarily implemented in "
"the **klippy/clocksync.py** code."
msgstr "不同时钟格式的转换主要在**klipper/clocksync.py**中实现。"

msgid "Some things to be aware of when reviewing the code:"
msgstr "在检查代码时需要注意："

msgid ""
"32bit and 64bit clocks: To reduce bandwidth and to improve micro-controller "
"efficiency, clocks on the micro-controller are tracked as 32bit integers. "
"When comparing two clocks in the mcu code, the `timer_is_before()` function "
"must always be used to ensure integer rollovers are handled properly. The "
"host software converts 32bit clocks to 64bit clocks by appending the high-"
"order bits from the last mcu timestamp it has received - no message from the"
" mcu is ever more than 2^31 clock ticks in the future or past so this "
"conversion is never ambiguous. The host converts from 64bit clocks to 32bit "
"clocks by simply truncating the high-order bits. To ensure there is no "
"ambiguity in this conversion, the **klippy/chelper/serialqueue.c** code will"
" buffer messages until they are within 2^31 clock ticks of their target "
"time."
msgstr ""
"32位和64位时钟：为了降低带宽消耗和提高微控制器效率，微控制器时钟使用32位整形进行追踪。在微控制器代码中对比两个时钟时，应保持调用`time_is_before`以确定整形时钟没有出现溢出的情况。上位机软件通过将微控制器最后一次返回的时间戳累加到主机代码时钟的高位地址中，以实现32位时钟到64位时钟的转换，由于来自微控制器的信息不可能来自2^31个时间刻度的过去或未来，因此时间转换不会出现错误。主机通过简单截断高位中的值，实现64位到32位的转换。为了确保转换没有歧义，**klippy/chelper/serialqueque.c**代码会缓存信息直到代码目标时间的2^31个时间刻度内。"

msgid ""
"Multiple micro-controllers: The host software supports using multiple micro-"
"controllers on a single printer. In this case, the \"MCU clock\" of each "
"micro-controller is tracked separately. The clocksync.py code handles clock "
"drift between micro-controllers by modifying the way it converts from "
"\"print time\" to \"MCU clock\". On secondary mcus, the mcu frequency that "
"is used in this conversion is regularly updated to account for measured "
"drift."
msgstr ""
"复数微控制器的情况：上位机软件支持单体打印机使用复数微控制器。此时，各微控制器的“微控制器时钟”将被分开记录。clocksync.py处理微处理器之间的时间飘变，方法在“打印时间”和“微处理器时间”的转换方法上修改得出。在次要微处理上，微处理器频率被用于上述处理，并通过持续测量漂变对次要微控制器频率进行更新。"

msgid ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"
msgstr ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"

#: docs/Code_Overview.md:block 1 (header)
msgid "Code overview"
msgstr "代码总览"

#: docs/Code_Overview.md:block 43 (paragraph)
msgid ""
"The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
" number of steps the micro-controller has issued in a positive direction "
"minus the number of steps issued in a negative direction since the micro-"
"controller was last reset. If the robot is in motion when the query is "
"issued then the reported value includes moves buffered on the micro-"
"controller, but does not include moves on the look-ahead queue."
msgstr ""
"“微控制器位置”（`stepper.get_mcu_position()`）是微控制器最后一次重置后执行的“正向”步数总数 - "
"“负向”步数总数的值。如果设备处于机械运动时，该方法将返回包含运动缓冲区中的位置值，但不包含预计队列中的运动值。"

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Add support for timer dispatch from hardware interrupts. See Klipper [commit"
" "
"970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
" as an example of steps 1-5 done for the LPC176x architecture."
msgstr ""
"增加对硬件中断的定时器调度的支持。参见 Klipper [commit "
"970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)，作为针对LPC176x架构的步骤1-5的例子。"

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up basic GPIO input and output support. See Klipper [commit "
"c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
" as an example of this."
msgstr ""
"提供基本的 GPIO 输入和输出支持。参见 Klipper [commit "
"c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
" 作为一个例子。"

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up additional peripherals - for example see Klipper commit "
"[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
" "
"[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
" and "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
msgstr ""
"启动其他外围设备-"
"参阅Klipper提交[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27)，[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5)，和[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)的例子。"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If the printer object defines a `get_status()` method then the module can "
"export [status information](Status_Reference.md) via "
"[macros](Command_Templates.md) and via the [API Server](API_Server.md). The "
"`get_status()` method must return a Python dictionary with keys that are "
"strings and values that are integers, floats, strings, lists, dictionaries, "
"True, False, or None. Tuples (and named tuples) may also be used (these "
"appear as lists when accessed via the API Server). Lists and dictionaries "
"that are exported must be treated as \"immutable\" - if their contents "
"change then a new object must be returned from `get_status()`, otherwise the"
" API Server will not detect those changes."
msgstr ""
"如果打印机对象中定义了 `get_status()` "
"方法，则在模块中可以通过[宏](Command_Templates.md)或[API服务](API_Server.md)输出[状态信息](Status_Reference.md)。"
" `get_status()` "
"必须返回一个Python字典对象，其键需要为字符串，而值应为整形、浮点数、列表、字典、True、False或者None。元组（或命名元组）也可以作为值（它们在API服务中将被视为列表）。列表和字典的输出值必须为“不可变的（immutable）”，即在函数内，如果"
" `get_status()` 需要输出上述类型的实例，则需要新建或者进行深层复制，否则API服务会识别出输出值中的内容变更。"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"It is recommended to assign a value to all member variables in the Python "
"constructor of Python classes. (And therefore avoid utilizing Python's "
"ability to dynamically create new member variables.)"
msgstr "推荐在类的工厂函数中将所有成员变量实例化（即避免使用Python的动态变动成员变量的功能）。"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If a Python variable is to store a floating point value then it is "
"recommended to always assign and manipulate that variable with floating "
"point constants (and never use integer constants). For example, prefer "
"`self.speed = 1.` over `self.speed = 1`, and prefer `self.speed = 2. * x` "
"over `self.speed = 2 * x`. Consistent use of floating point values can avoid"
" hard to debug quirks in Python type conversions."
msgstr ""
"若一Python变量存放有一浮点数，那么建议该变量应总赋予浮点类型的量，并仅使用浮点数常量进行值运算（并绝不使用整形常数进行运算）。例如，应使用`self.speed"
" = 1.`而非`self.speed = 1`，并以`self.speed = 2. * x` 替代 ` self.speed = 2 "
"*x`。一致地使用浮点值可以避免Python类型转换中难以调试的怪异现象。"

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"The first main coding task is to bring up communication support to the "
"target board. This is the most difficult step in a new port. Once basic "
"communication is working, the remaining steps tend to be much easier. It is "
"typical to use a UART type serial device during initial development as these"
" types of hardware devices are generally easier to enable and control. "
"During this phase, make liberal use of helper code from the src/generic/ "
"directory (check how src/simulator/Makefile includes the generic C code into"
" the build). It is also necessary to define timer_read_time() (which returns"
" the current system clock) in this phase, but it is not necessary to fully "
"support timer irq handling."
msgstr ""
"首要任务是在目标打印机主板上实现通讯。这是增加支持中最难的一步，实现该功能后一切将阔然开朗。在开荒时，一般使用串行总线进行开发，因为通常串行总线已于应用和控制。在此阶段，可大量使用"
" src/generic/ 目录中的中的辅助代码（可参考 src/simulator/Makefile "
"中如何将上述代码加入构建）。同时，需要在这阶段完成 timer_read_time() 的定义（用于获取现时系统时钟），但无需完全实现定时中断功能。"

#: docs/Code_Overview.md:block 39 (paragraph)
msgid "Additional coding tips:"
msgstr "还有一些tips："

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Avoid using \"C bitfields\" to access IO registers; prefer direct read and "
"write operations of 32bit, 16bit, or 8bit integers. The C language "
"specifications don't clearly specify how the compiler must implement C "
"bitfields (eg, endianness, and bit layout), and it's difficult to determine "
"what IO operations will occur on a C bitfield read or write."
msgstr ""
"避免使用“C位段”（C "
"bitfield）访问IO寄存器；应使用直接对32位、16位和8位的整数读写代替。C语言规范中没有对位段操作进行清晰定义（例如端序、字布局等），且在IO操作时使用C段位读写，将难以确定具体进行了何种IO操作。"

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Prefer writing explicit values to IO registers instead of using read-modify-"
"write operations. That is, if updating a field in an IO register where the "
"other fields have known values, then it is preferable to explicitly write "
"the full contents of the register. Explicit writes produce code that is "
"smaller, faster, and easier to debug."
msgstr ""
"IO寄存器操作时应使用显式赋值，避免使用“读-改-写”。也就是说，如果在一个IO寄存器中更新一个字段，而其他字段的值是已知的，那么最好是显式地写入寄存器的全部内容。显式写入产生的代码更小，更快，更容易调试。"

#: docs/Code_Overview.md:block 14 (paragraph)
msgid ""
"Task, init, and command functions always run with interrupts enabled "
"(however, they can temporarily disable interrupts if needed). These "
"functions should avoid long pauses, delays, or do work that lasts a "
"significant time. (Long delays in these \"task\" functions result in "
"scheduling jitter for other \"tasks\" - delays over 100us may become "
"noticeable, delays over 500us may result in command retransmissions, delays "
"over 100ms may result in watchdog reboots.) These functions schedule work at"
" specific times by scheduling timers."
msgstr ""
"任务、初始化和命令函数始终在启用中断的情况下运行（但是，如果需要，它们可以暂时禁用中断）。这些函数应避免长时间的暂停、延迟或执行持续很长时间的工作。（这些“任务”功能中的长时间延迟会导致其他“任务”的调度抖动"
" - "
"超过100us的延迟可能会变得明显，超过500us的延迟可能导致命令重传，超过100ms的延迟可能导致看门狗触发重启。这些函数通过调度计时器在特定时间安排工作。"

#~ msgid ""
#~ "Task, init, and command functions always run with interrupts enabled "
#~ "(however, they can temporarily disable interrupts if needed). These "
#~ "functions should never pause, delay, or do any work that lasts more than a "
#~ "few micro-seconds. These functions schedule work at specific times by "
#~ "scheduling timers."
#~ msgstr ""
#~ "任务、初始化和命令函数总是在中断启用的情况下运行（然而，可根据需要将中断功能停用）。这些函数不应出现暂停、延迟或执行持续事件长于数微秒的任务。这些函数应由调度定时器在特定的事件进行调用。"

#~ msgid ""
#~ "The first main coding task is to bring up communication support to the "
#~ "target board. This is the most difficult step in a new port. Once basic "
#~ "communication is working, the remaining steps tend to be much easier. It is "
#~ "typical to use an RS-232 style serial port during initial development as "
#~ "these types of hardware devices are generally easier to enable and control. "
#~ "During this phase, make liberal use of helper code from the src/generic/ "
#~ "directory (check how src/simulator/Makefile includes the generic C code into"
#~ " the build). It is also necessary to define timer_read_time() (which returns"
#~ " the current system clock) in this phase, but it is not necessary to fully "
#~ "support timer irq handling."
#~ msgstr ""
#~ "首要的变成任务，是为目标架构提供通讯支持。这是移植中最难的一步。只要完成基础通讯，剩余的步骤会更为简单。在开发初期，通常使用RS-232风格串行通讯，因为这些硬件通常易于获得和控制。在这个阶段，应充分使用src/generic的帮助代码（检查如何通过src/simulator/Makefile将通过C代码纳入构建之中）。同时，在这个阶段必须定义timer_read_time()（用于返回现时的系统时钟），然而此时不必添加完全的定时器中断处理支持。"

#~ msgid ""
#~ "Add support for timer dispatch from hardware interrupts. See Klipper [commit"
#~ " "
#~ "970831ee](https://github.com/KevinOConnor/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
#~ " as an example of steps 1-5 done for the LPC176x architecture."
#~ msgstr ""
#~ "增加硬件中断定时器的调度支持。参考Klipper "
#~ "commit[970831ee](https://github.com/KevinOConnor/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)以LPC176X为例的步骤1-5的例子。"

#~ msgid ""
#~ "Bring up basic GPIO input and output support. See Klipper [commit "
#~ "c78b9076](https://github.com/KevinOConnor/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
#~ " as an example of this."
#~ msgstr ""
#~ "增加GPIO输入输出的测试。参考Klipper "
#~ "commnit[c78b9076](https://github.com/KevinOConnor/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)。"

#~ msgid ""
#~ "Bring up additional peripherals - for example see Klipper commit "
#~ "[65613aed](https://github.com/KevinOConnor/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
#~ " "
#~ "[c812a40a](https://github.com/KevinOConnor/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
#~ " and "
#~ "[c381d03a](https://github.com/KevinOConnor/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
#~ msgstr ""
#~ "增加外设支持，参考commit "
#~ "[65613aed](https://github.com/KevinOConnor/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
#~ " "
#~ "[c812a40a](https://github.com/KevinOConnor/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
#~ " "
#~ "和[c381d03a](https://github.com/KevinOConnor/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)。"

#~ msgid ""
#~ "The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
#~ " number of steps the micro-controller has issued in a positive direction "
#~ "minus the number of steps issued in a negative direction since the micro-"
#~ "controller was last reset. The value reported is only valid after the "
#~ "stepper has been homed. If the robot is in motion when the query is issued "
#~ "then the reported value includes moves buffered on the micro-controller, but"
#~ " does not include moves on the look-ahead queue."
#~ msgstr ""
