# brian park <gouache95@gmail.com>, 2021.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2021-08-23 02:32+0000\n"
"Last-Translator: brian park <gouache95@gmail.com>\n"
"Language-Team: Korean <https://hosted.weblate.org/projects/klipper/measuring_resonances/ko/>\n"
"Language: ko\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.8.1-dev\n"

msgid "Measuring Resonances"
msgstr "공진 측정"

msgid ""
"Klipper has built-in support for ADXL345 accelerometer, which can be used to"
" measure resonance frequencies of the printer for different axes, and auto-"
"tune [input shapers](Resonance_Compensation.md) to compensate for "
"resonances. Note that using ADXL345 requires some soldering and crimping. "
"ADXL345 can be connected to a Raspberry Pi directly, or to an SPI interface "
"of an MCU board (it needs to be reasonably fast)."
msgstr ""
"Klipper는 다양한 축에 대한 프린터의 공진 주파수를 측정하는 데 사용할 수 있는 ADXL345 가속도계를 기본적으로 지원하고 공진을"
" 보상하기 위해 [input shapers](Resonance_Compensation.md) 를 자동 조정합니다. ADXL345 를 "
"사용하려면 약간의 납땜 및 압착이 필요합니다. ADXL345는 Raspberry Pi에 직접 연결하거나 MCU 보드의 SPI 인터페이스에"
" 연결할 수 있습니다 (빠른 속도가 필요하기 때문에)."

msgid "Installation instructions"
msgstr "설치 방법"

msgid "Wiring"
msgstr "배선"

msgid ""
"You need to connect ADXL345 to your Raspberry Pi via SPI. Note that the I2C "
"connection, which is suggested by ADXL345 documentation, has too low "
"throughput and **will not work**. The recommended connection scheme:"
msgstr ""
"SPI 를 통해 ADXL345 를 Raspberry Pi에 연결해야 합니다. ADXL345 문서에서 제안하는 I2C 연결은 처리량이 너무"
" 낮아 **작동하지 않습니다**. 권장 연결 방식:"

msgid "ADXL345 pin"
msgstr "ADXL345 핀"

msgid "RPi pin"
msgstr "RPi 핀"

msgid "RPi pin name"
msgstr "RPi 핀 이름"

msgid "3V3 (or VCC)"
msgstr "3V3 (또는 VCC)"

msgid "01"
msgstr "01"

msgid "3.3v DC power"
msgstr "3.3v 직류 전원"

msgid "GND"
msgstr "GND"

msgid "06"
msgstr "06"

msgid "Ground"
msgstr "Ground"

msgid "CS"
msgstr "CS"

msgid "24"
msgstr "24"

msgid "GPIO08 (SPI0_CE0_N)"
msgstr "GPIO08 (SPI0_CE0_N)"

msgid "SDO"
msgstr "SDO"

msgid "21"
msgstr "21"

msgid "GPIO09 (SPI0_MISO)"
msgstr "GPIO09 (SPI0_MISO)"

msgid "SDA"
msgstr "SDA"

msgid "19"
msgstr "19"

msgid "GPIO10 (SPI0_MOSI)"
msgstr "GPIO10 (SPI0_MOSI)"

msgid "SCL"
msgstr "SCL"

msgid "23"
msgstr "23"

msgid "GPIO11 (SPI0_SCLK)"
msgstr "GPIO11 (SPI0_SCLK)"

msgid "Fritzing wiring diagrams for some of the ADXL345 boards:"
msgstr "ADXL345 보드에 대한 Fritzing 배선 다이어그램:"

msgid "![ADXL345-Rpi](img/adxl345-fritzing.png)"
msgstr "![ADXL345-Rpi](img/adxl345-fritzing.png)"

msgid ""
"Double-check your wiring before powering up the Raspberry Pi to prevent "
"damaging it or the accelerometer."
msgstr ""
"Raspberry Pi 또는 가속도계의 손상을 방지하기 위해 Raspberry Pi의 전원을 켜기 전에 배선을 다시 확인하십시오."

msgid "Mounting the accelerometer"
msgstr "가속도계 장착"

msgid ""
"The accelerometer must be attached to the toolhead. One needs to design a "
"proper mount that fits their own 3D printer. It is better to align the axes "
"of the accelerometer with the printer's axes (but if it makes it more "
"convenient, axes can be swapped - i.e. no need to align X axis with X and so"
" forth - it should be fine even if Z axis of accelerometer is X axis of the "
"printer, etc.)."
msgstr ""
"가속도계는 툴헤드에 부착되어야 합니다. 자신의 3D 프린터에 맞는 적절한 마운트를 설계해야 합니다. 가속도계의 축을 프린터의 축과 "
"정렬하는 것이 좋습니다 (그러나 더 편리하게 만들면 축을 바꿀 수 있습니다. 즉, X축을 X와 정렬할 필요가 없습니다. Z축이 다음과 "
"같아도 괜찮습니다. 가속도계는 프린터의 X축 등)."

msgid "An example of mounting ADXL345 on the SmartEffector:"
msgstr "SmartEffector 에 ADXL345 를 장착하는 예:"

msgid "![ADXL345 on SmartEffector](img/adxl345-mount.jpg)"
msgstr "![ADXL345 on SmartEffector](img/adxl345-mount.jpg)"

msgid ""
"Note that on a bed slinger printer one must design 2 mounts: one for the "
"toolhead and one for the bed, and run the measurements twice. See the "
"corresponding [section](#bed-slinger-printers) for more details."
msgstr ""
"BED Slingers 프린터에서 하나는 2개의 마운트를 설계해야 합니다. 하나는 헤드용, 다른 하나는 베드용이고 측정을 두 번 "
"실행합니다. 자세한 내용은 해당 [section](#bed-slinger-printers) 을 참조하세요."

msgid ""
"**Attention:** make sure the accelerometer and any screws that hold it in "
"place do not touch any metal parts of the printer. Basically, the mount must"
" be designed such as to ensure the electrical isolation of the accelerometer"
" from the printer frame. Failing to ensure that can create a ground loop in "
"the system that may damage the electronics."
msgstr ""
"**주의:** 가속도계와 이를 고정하는 나사가 프린터의 금속 부분에 닿지 않도록 하십시오. 기본적으로 마운트는 프린터 프레임에서 "
"가속도계의 전기적 절연을 보장하도록 설계되어야 합니다. 시스템에 접지가 되지 않으면 전자장치를 손상시킬 수 있습니다."

msgid "Software installation"
msgstr "소프트웨어 설치"

msgid ""
"Afterwards, check and follow the instructions in the [RPi Microcontroller "
"document](RPi_microcontroller.md) to setup the \"linux mcu\" on the "
"Raspberry Pi."
msgstr ""
"이후 [RPi Microcontroller document](RPi_microcontroller.md) 의 지시사항에 따라 라즈베리파이에"
" \"linux mcu\"를 설정합니다."

msgid ""
"Make sure the Linux SPI driver is enabled by running `sudo raspi-config` and"
" enabling SPI under the \"Interfacing options\" menu."
msgstr ""
"`sudo raspi-config` 를 실행하고 \"Interfacing options\" 메뉴에서 SPI를 활성화하여 Linux SPI"
" 드라이버가 활성화되어 있는지 확인합니다."

msgid ""
"It is advised to start with 1 probe point, in the middle of the print bed, "
"slightly above it."
msgstr "프린터 BED 중간, 약간 위에서 프로브 포인트 1개로 시작하는 것이 좋습니다."

msgid "Restart Klipper via the `RESTART` command."
msgstr "`RESTART` 명령을 통해 Klipper를 다시 시작하십시오."

msgid "Measuring the resonances"
msgstr "공진 측정"

msgid "Checking the setup"
msgstr "설정 확인"

msgid "Now you can test a connection."
msgstr "이제 연결을 테스트할 수 있습니다."

msgid ""
"For \"non bed-slingers\" (e.g. one accelerometer), in Octoprint, enter "
"`ACCELEROMETER_QUERY`"
msgstr ""
"\"non bed-slingers\"(예: 가속도계 1개) 의 경운 Octoprint에 `ACCELEROMETER_QUERY` 를 "
"입력하세요"

msgid ""
"For \"bed-slingers\" (e.g. more than one accelerometer), enter "
"`ACCELEROMETER_QUERY CHIP=<chip>` where `<chip>` is the name of the chip as-"
"entered, e.g. `CHIP=bed` (see: [bed-slinger](#bed-slinger-printers)) for all"
" installed accelerometer chips."
msgstr ""
"\"bed-slingers\" (예: 둘 이상의 가속도계) 의 경우 `ACCELERROMETER_QUERY CHIP=<chip>`을 "
"입력합니다. 여기서 `<chip>`은 입력된 칩의 이름입니다. 예: 설치된 가속도 칩에 대해 `CHIP=bed`(참조: [bed-"
"slinger](#bed-slinger-printers))."

msgid ""
"You should see the current measurements from the accelerometer, including "
"the free-fall acceleration, e.g."
msgstr "자유 낙하 가속도를 포함하여 가속도계의 현재 측정값이 표시되어야 합니다. 예는 아래와 같습니다."

msgid ""
"If you get an error like `Invalid adxl345 id (got xx vs e5)`, where `xx` is "
"some other ID, it is indicative of the connection problem with ADXL345, or "
"the faulty sensor. Double-check the power, the wiring (that it matches the "
"schematics, no wire is broken or loose, etc.), and soldering quality."
msgstr ""
"`Invalid adxl345 id (got xx vs e5)` 와 같은 오류가 발생하면 (여기서 'xx'는 다른 ID임) "
"ADXL345의 연결 문제 또는 센서 결함을 나타냅니다. 전원, 배선(회로도와 일치하는지, 와이어가 끊어지거나 느슨하지 않은지 등) 및 "
"납땜 품질을 다시 확인하십시오."

msgid ""
"Next, try running `MEASURE_AXES_NOISE` in Octoprint, you should get some "
"baseline numbers for the noise of accelerometer on the axes (should be "
"somewhere in the range of ~1-100). Too high axes noise (e.g. 1000 and more) "
"can be indicative of the sensor issues, problems with its power, or too "
"noisy imbalanced fans on a 3D printer."
msgstr ""
"다음으로 Octoprint에서 `MEASURE_AXES_NOISE`를 실행해 보십시오. 축의 가속도계 노이즈에 대한 기준 수치를 얻어야 "
"합니다 (~1-100 범위 어딘가에 있어야 함). 너무 높은 축 노이즈(예: 1000개 이상)는 센서 문제, 전원 문제 또는 3D "
"프린터의 너무 시끄러운 팬이 원인일 수 있습니다."

msgid "Now you can run some real-life tests. Run the following command:"
msgstr "이제 실제 테스트를 실행할 수 있습니다. 다음 명령을 실행합니다:"

msgid ""
"Note that it will create vibrations on X axis. It will also disable input "
"shaping if it was enabled previously, as it is not valid to run the "
"resonance testing with the input shaper enabled."
msgstr ""
"X축에 진동을 생성합니다. 또한 입력 셰이퍼가 활성화된 상태에서 공진 테스트를 실행하는 것이 유효하지 않기 때문에 이전에 활성화된 경우 "
"입력 셰이핑을 비활성화합니다."

msgid ""
"**Attention!** Be sure to observe the printer for the first time, to make "
"sure the vibrations do not become too violent (`M112` command can be used to"
" abort the test in case of emergency; hopefully it will not come to this "
"though). If the vibrations do get too strong, you can attempt to specify a "
"lower than the default value for `accel_per_hz` parameter in "
"`[resonance_tester]` section, e.g."
msgstr ""
"**주의!** 진동이 너무 심하지 않도록 프린터를 처음 관찰해야 합니다('M112' 명령은 비상시 테스트를 중단하는 데 사용할 수 "
"있습니다. 그러나 이것은 자주 사용되지 않았으면 합니다). 진동이 너무 강해지면 `[resonance_tester]` 섹션에서 "
"`accel_per_hz` 매개변수의 기본값보다 낮은 값을 지정할 수 있습니다. 예를 들어."

msgid "If it works for X axis, run for Y axis as well:"
msgstr "X축에 대해 작동하는 경우 Y축에 대해서도 실행합니다:"

msgid ""
"This script will generate the charts `/tmp/shaper_calibrate_x.png` and "
"`/tmp/shaper_calibrate_y.png` with frequency responses. You will also get "
"the suggested frequencies for each input shaper, as well as which input "
"shaper is recommended for your setup. For example:"
msgstr ""
"이 스크립트는 주파수 응답과 함께 `/tmp/shaper_calibration_x.png` 및 "
"`/tmp/shaper_calibration_y.png` 차트를 생성합니다. 또한 각 입력 셰이퍼에 대해 제안된 주파수와 설정에 권장되는"
" 입력 셰이퍼를 얻을 수 있습니다. 예를 들어:"

msgid "![Resonances](img/calibrate-y.png)"
msgstr "![Resonances](img/calibrate-y.png)"

msgid ""
"The suggested configuration can be added to `[input_shaper]` section of "
"`printer.cfg`, e.g.:"
msgstr "제안된 구성은 `printer.cfg`의 `[input_shaper]` 섹션에 추가할 수 있습니다. 예:"

msgid ""
"or you can choose some other configuration yourself based on the generated "
"charts: peaks in the power spectral density on the charts correspond to the "
"resonance frequencies of the printer."
msgstr ""
"또는 생성된 차트를 기반으로 다른 구성을 직접 선택할 수 있습니다. 차트의 전력 스펙트럼 밀도 피크는 프린터의 공진 주파수에 해당합니다."

msgid ""
"Note that alternatively you can run the input shaper autocalibration from "
"Klipper [directly](#input-shaper-auto-calibration), which can be convenient,"
" for example, for the input shaper [re-calibration](#input-shaper-re-"
"calibration)."
msgstr ""
"Klipper에서 [directly](#input-shaper-auto-calibration) 입력 셰이퍼 자동 보정을 실행하는게 편리할"
" 수 있습니다, 예를 들어 입력 셰이퍼의 경우 [re-calibration](#input-shaper-re-calibration) 을 "
"사용합니다."

msgid "Bed-slinger printers"
msgstr "Bed-slinger 프린터"

msgid ""
"If your printer is a bed slinger printer, you will need to change the "
"location of the accelerometer between the measurements for X and Y axes: "
"measure the resonances of X axis with the accelerometer attached to the "
"toolhead and the resonances of Y axis - to the bed (the usual bed slinger "
"setup)."
msgstr ""
"프린터가 bed slinger 프린터인 경우 X축과 Y축 측정 사이에 가속도계의 위치를 변경해야 합니다. 툴 헤드에 부착된 가속도계로 "
"X축의 공명과 Y축의 공진을 측정합니다. BED (일반적인 bed slinger 설정)."

msgid ""
"However, you can also connect two accelerometers simultaneously, though they"
" must be connected to different boards (say, to an RPi and printer MCU "
"board), or to two different physical SPI interfaces on the same board "
"(rarely available). Then they can be configured in the following manner:"
msgstr ""
"그러나 두 개의 가속도계를 동시에 연결할 수도 있지만 서로 다른 보드(예: RPi 및 프린터 MCU 보드)에 연결하거나 동일한 보드에 "
"있는 두 개의 서로 다른 물리적 SPI 인터페이스(드물게 사용 가능)에 연결해야 합니다. 그런 다음 다음과 같은 방식으로 구성할 수 "
"있습니다:"

msgid ""
"Then the commands `TEST_RESONANCES AXIS=X` and `TEST_RESONANCES AXIS=Y` will"
" use the correct accelerometer for each axis."
msgstr ""
"그런 다음 `TEST_RESONANCES AXIS=X` 및 `TEST_RESONANCES AXIS=Y` 명령을 각 축 가속도계에 "
"사용합니다."

msgid "Max smoothing"
msgstr "Max smoothing"

msgid ""
"Keep in mind that the input shaper can create some smoothing in parts. "
"Automatic tuning of the input shaper performed by `calibrate_shaper.py` "
"script or `SHAPER_CALIBRATE` command tries not to exacerbate the smoothing, "
"but at the same time they try to minimize the resulting vibrations. "
"Sometimes they can make a sub-optimal choice of the shaper frequency, or "
"maybe you simply prefer to have less smoothing in parts at the expense of a "
"larger remaining vibrations. In these cases, you can request to limit the "
"maximum smoothing from the input shaper."
msgstr ""
"입력 셰이퍼는 부분에 약간의 smoothing을 생성할 수 있습니다. `calibration_shaper.py` 스크립트 또는 "
"`SHAPER_CALIBRATE` 명령에 의해 수행되는 입력 셰이퍼의 자동 조정은 smoothing을 악화시키지 않으려고 시도합니다, "
"그러나 동시에 그들은 결과적인 진동을 최소화하려고 노력합니다. 때때로 그들은 셰이퍼 주파수의 차선책을 선택하거나 더 큰 잔여 진동을 "
"희생시키면서 부품의 smoothing을 줄이는 것을 선호할 수 있습니다. 이러한 경우 입력 셰이퍼에서 최대 스무딩을 제한하도록 요청할 수"
" 있습니다."

msgid "Let's consider the following results from the automatic tuning:"
msgstr "자동 튜닝의 결과를 다음과 같이 가정해 보겠습니다:"

msgid "![Resonances](img/calibrate-x.png)"
msgstr "![Resonances](img/calibrate-x.png)"

msgid ""
"Note that the reported `smoothing` values are some abstract projected "
"values. These values can be used to compare different configurations: the "
"higher the value, the more smoothing a shaper will create. However, these "
"smoothing scores do not represent any real measure of smoothing, because the"
" actual smoothing depends on [`max_accel`](#selecting-max-accel) and "
"`square_corner_velocity` parameters. Therefore, you should print some test "
"prints to see how much smoothing exactly a chosen configuration creates."
msgstr ""
"보고된 `smoothing` 값은 일부 추상적으로 투영 값입니다. 이 값은 다양한 구성을 비교하는 데 사용할 수 있습니다. 값이 높을수록"
" 셰이퍼가 더 부드럽게 만듭니다. 그러나 이러한 smoothing 점수는 smoothing 의 실제 측정을 나타내지 않습니다. 실제 "
"smoothing 은 [`max_accel`](#selecting-max-accel) 및 `square_corner_velocity` "
"매개변수에 의존하기 때문입니다. 따라서 선택한 구성이 정확히 얼마나 스무딩을 생성하는지 확인하려면 몇 가지 테스트 인쇄를 인쇄해야 "
"합니다."

msgid ""
"In the example above the suggested shaper parameters are not bad, but what "
"if you want to get less smoothing on the X axis? You can try to limit the "
"maximum shaper smoothing using the following command:"
msgstr ""
"위의 예에서 제안된 셰이퍼 매개변수는 나쁘지 않지만 만약 X축에서 스무딩을 줄이고 싶다면? 다음 명령을 사용하여 최대 셰이퍼 "
"smoothing 을 제한할 수 있습니다:"

msgid ""
"which limits the smoothing to 0.2 score. Now you can get the following "
"result:"
msgstr "smoothing을 0.2 점수로 제한합니다. 이제 다음과 같은 결과를 얻을 수 있습니다:"

msgid "![Resonances](img/calibrate-x-max-smoothing.png)"
msgstr "![Resonances](img/calibrate-x-max-smoothing.png)"

msgid ""
"If you compare to the previously suggested parameters, the vibrations are a "
"bit larger, but the smoothing is significantly smaller than previously, "
"allowing larger maximum acceleration."
msgstr "앞서 제안한 파라미터와 비교하면 진동은 조금 더 크지만 이전보다 스무딩이 현저히 작아 최대 가속도가 더 커졌습니다."

msgid ""
"When deciding which `max_smoothing` parameter to choose, you can use a "
"trial-and-error approach. Try a few different values and see which results "
"you get. Note that the actual smoothing produced by the input shaper "
"depends, primarily, on the lowest resonance frequency of the printer: the "
"higher the frequency of the lowest resonance - the smaller the smoothing. "
"Therefore, if you request the script to find a configuration of the input "
"shaper with the unrealistically small smoothing, it will be at the expense "
"of increased ringing at the lowest resonance frequencies (which are, "
"typically, also more prominently visible in prints). So, always double-check"
" the projected remaining vibrations reported by the script and make sure "
"they are not too high."
msgstr ""
"선택할 `max_smoothing` 매개변수를 결정할 때 시행착오를 거칠 수 있습니다. 몇 가지 다른 값을 시도하고 어떤 결과를 얻을 수"
" 있는지 확인하십시오. 입력 셰이퍼에 의해 생성된 실제 smoothing 은 주로 프린터의 가장 낮은 공진 주파수에 따라 달라집니다. "
"가장 낮은 공진의 주파수가 높을수록 smoothing이 작아집니다. 따라서 비현실적으로 작은 smoothing 으로 입력 셰이퍼의 구성을"
" 찾도록 스크립트를 요청하는 경우 가장 낮은 공명 주파수(일반적으로 인쇄물에서도 더 두드러지게 나타남) 에서 링잉이 증가하게 됩니다. "
"따라서 스크립트에서 보고한 예상 잔여 진동을 항상 다시 확인하고 너무 높지 않은지 확인하십시오."

msgid ""
"Note that if you chose a good `max_smoothing` value for both of your axes, "
"you can store it in the `printer.cfg` as"
msgstr "두 축에 대해 좋은 `max_smoothing` 값을 선택했다면 `printer.cfg`에 다음과 같이 저장할 수 있습니다"

msgid ""
"Then, if you [rerun](#input-shaper-re-calibration) the input shaper auto-"
"tuning using `SHAPER_CALIBRATE` Klipper command in the future, it will use "
"the stored `max_smoothing` value as a reference."
msgstr ""
"그런 다음 나중에 `SHAPER_CALIBRATE` Klipper 명령을 사용하여 입력 shaper 자동 튜닝을 "
"[rerun](#input-shaper-re-calibration) 실행하면 저장된 `max_smoothing` 값을 참조로 사용합니다."

msgid "Selecting max_accel"
msgstr "max_accel 선택"

msgid ""
"Since the input shaper can create some smoothing in parts, especially at "
"high accelerations, you will still need to choose the `max_accel` value that"
" does not create too much smoothing in the printed parts. A calibration "
"script provides an estimate for `max_accel` parameter that should not create"
" too much smoothing. Note that the `max_accel` as displayed by the "
"calibration script is only a theoretical maximum at which the respective "
"shaper is still able to work without producing too much smoothing. It is by "
"no means a recommendation to set this acceleration for printing. The maximum"
" acceleration your printer is able to sustain depends on its mechanical "
"properties and the maximum torque of the used stepper motors. Therefore, it "
"is suggested to set `max_accel` in `[printer]` section that does not exceed "
"the estimated values for X and Y axes, likely with some conservative safety "
"margin."
msgstr ""
"입력 셰이퍼는 특히 높은 가속에서 부품에 약간의 smoothing 을 생성할 수 있으므로 인쇄된 부품에 너무 많은 smoothing 을 "
"생성하지 않는 'max_accel' 값을 선택해야 합니다. 보정 스크립트는 smoothing을 너무 많이 생성하지 않아야 하는 "
"'max_accel' 매개변수에 대한 추정치를 제공합니다. 보정 스크립트에 의해 표시되는 'max_accel'은 각 셰이퍼가 너무 많은 "
"smoothing 을 생성하지 않고 여전히 작동할 수 있는 이론적인 최대값일 뿐입니다. 인쇄를 위해 이 가속을 설정하는 것은 결코 "
"권장되지 않습니다. 프린터가 유지할 수 있는 최대 가속도는 기계적 특성과 사용된 스테퍼 모터의 최대 토크에 따라 다릅니다. 따라서 "
"`[printer]` 섹션에서 `max_accel` 을 X 및 Y축의 예상 값을 초과하지 않도록 설정하는 것이 좋습니다. 약간의 보수적인"
" 안전 제한이 있을 수 있습니다."

msgid ""
"Alternatively, follow [this](Resonance_Compensation.md#selecting-max_accel) "
"part of the input shaper tuning guide and print the test model to choose "
"`max_accel` parameter experimentally."
msgstr ""
"또는 입력 셰이퍼 튜닝 가이드의 [this](Resonance_Compensation.md#selecting-max_accel) 부분을 "
"따르고 테스트 모델을 인쇄하여 `max_accel` 매개변수를 실험적으로 선택합니다."

msgid ""
"The same notice applies to the input shaper [auto-calibration](#input-"
"shaper-auto-calibration) with `SHAPER_CALIBRATE` command: it is still "
"necessary to choose the right `max_accel` value after the auto-calibration, "
"and the suggested acceleration limits will not be applied automatically."
msgstr ""
"동일한 알림이 `SHAPER_CALIBRATE` 명령을 사용하여 입력 셰이퍼 [auto-calibration](#input-shaper-"
"auto-calibration) 에 적용됩니다: 자동 보정 후에도 올바른 `max_accel` 값을 선택해야 하며 제안된 가속 제한은 "
"자동으로 적용되지 않습니다."

msgid ""
"If you are doing a shaper re-calibration and the reported smoothing for the "
"suggested shaper configuration is almost the same as what you got during the"
" previous calibration, this step can be skipped."
msgstr ""
"만약 셰이퍼 재보정을 수행하고 제안된 셰이퍼 구성에 대해 보고된 smoothing 이 이전 보정 중에 얻은 것과 거의 동일한 경우 이 "
"단계를 건너뛸 수 있습니다."

msgid "Input Shaper auto-calibration"
msgstr "사용자 정의 축 테스트"

msgid ""
"Besides manually choosing the appropriate parameters for the input shaper "
"feature, it is also possible to run the auto-tuning for the input shaper "
"directly from Klipper. Run the following command via Octoprint terminal:"
msgstr ""
"입력 셰이퍼 기능에 대한 적절한 매개변수를 수동으로 선택하는 것 외에도 Klipper에서 직접 입력 셰이퍼에 대한 자동 조정을 실행할 "
"수도 있습니다. Octoprint 터미널을 통해 다음 명령을 실행합니다:"

msgid ""
"This will run the full test for both axes and generate the csv output "
"(`/tmp/calibration_data_*.csv` by default) for the frequency response and "
"the suggested input shapers. You will also get the suggested frequencies for"
" each input shaper, as well as which input shaper is recommended for your "
"setup, on Octoprint console. For example:"
msgstr ""
"그러면 두 축에 대한 전체 테스트가 실행되고 주파수 응답 및 제안된 입력 셰이퍼에 대한 csv 출력 (기본적으로 "
"`/tmp/calibration_data_*.csv`) 이 생성됩니다. 또한 Octoprint 콘솔에서 각 입력 셰이퍼에 대해 제안된 "
"주파수와 설정에 권장되는 입력 셰이퍼를 얻을 수 있습니다. 예를 들어:"

msgid ""
"If you agree with the suggested parameters, you can execute `SAVE_CONFIG` "
"now to save them and restart the Klipper. Note that this will not update "
"`max_accel` value in `[printer]` section. You should update it manually "
"following the considerations in [Selecting max_accel](#selecting-max_accel) "
"section."
msgstr ""
"제안된 매개변수에 동의하면 지금 `SAVE_CONFIG` 를 실행하여 저장하고 Klipper를 다시 시작할 수 있습니다. 이것은 "
"`[printer]` 섹션의 `max_accel` 값을 업데이트하지 않습니다. [Selecting "
"max_accel](#selecting-max_accel) 섹션을 수동으로 업데이트해야 합니다."

msgid ""
"If your printer is a bed slinger printer, you can specify which axis to "
"test, so that you can change the accelerometer mounting point between the "
"tests (by default the test is performed for both axes):"
msgstr ""
"프린터가 bed slinger 프린터인 경우 테스트할 축을 지정할 수 있으므로 테스트 사이에 가속도계 장착 지점을 변경할 수 있습니다 "
"(기본적으로 테스트는 두 축 모두에 대해 수행됨):"

msgid "You can execute `SAVE_CONFIG` twice - after calibrating each axis."
msgstr "각 축을 보정한 후 `SAVE_CONFIG`를 두 번 실행할 수 있습니다."

msgid ""
"However, if you connected two accelerometers simultaneously, you simply run "
"`SHAPER_CALIBRATE` without specifying an axis to calibrate the input shaper "
"for both axes in one go."
msgstr ""
"그러나 두 개의 가속도계를 동시에 연결한 경우 축을 지정하지 않고 `SHAPER_CALIBRATE`를 실행하여 두 축에 대한 입력 "
"셰이퍼를 한 번에 보정하기만 하면 됩니다."

msgid "Input Shaper re-calibration"
msgstr "Input Shaper 재보정"

msgid ""
"`SHAPER_CALIBRATE` command can be also used to re-calibrate the input shaper"
" in the future, especially if some changes to the printer that can affect "
"its kinematics are made. One can either re-run the full calibration using "
"`SHAPER_CALIBRATE` command, or restrict the auto-calibration to a single "
"axis by supplying `AXIS=` parameter, like"
msgstr ""
"`SHAPER_CALIBRATE` 명령은 향후 입력 셰이퍼를 다시 보정하는 데 사용할 수도 있습니다. 특히 운동학에 영향을 줄 수 있는 "
"프린터 변경 사항이 있는 경우 더욱 그렇습니다. `SHAPER_CALIBRATE` 명령을 사용하여 전체 보정을 다시 실행하거나 다음과 "
"같이 `AXIS=` 매개변수를 제공하여 자동 보정을 단일 축으로 제한할 수 있습니다"

msgid ""
"**Warning!** It is not advisable to run the shaper autocalibration very "
"frequently (e.g. before every print, or every day). In order to determine "
"resonance frequencies, autocalibration creates intensive vibrations on each "
"of the axes. Generally, 3D printers are not designed to withstand a "
"prolonged exposure to vibrations near the resonance frequencies. Doing so "
"may increase wear of the printer components and reduce their lifespan. There"
" is also an increased risk of some parts unscrewing or becoming loose. "
"Always check that all parts of the printer (including the ones that may "
"normally not move) are securely fixed in place after each auto-tuning."
msgstr ""
"**경고!** 셰이퍼 자동 보정을 매우 자주 실행하지 않는 것이 좋습니다 (예: 인쇄할 때마다 또는 매일). 공진 주파수를 결정하기 위해"
" 자동 보정은 각 축에 집중적인 진동을 생성합니다. 일반적으로 3D 프린터는 공진 주파수 근처의 진동에 장기간 노출되는 것을 견디도록 "
"설계되지 않았습니다. 그렇게 하면 프린터 구성 요소의 마모가 증가하고 수명이 단축될 수 있습니다. 또한 일부 부품이 풀리거나 느슨해질 "
"위험이 증가합니다. 각 자동 조정 후에 프린터의 모든 부품 (일반적으로 움직이지 않는 부품 포함) 이 제자리에 단단히 고정되어 있는지 "
"항상 확인하십시오."

msgid ""
"Also, due to some noise in measurements, it is possible that the tuning "
"results will be slightly different from one calibration run to another one. "
"Still, it is not expected that the noise will affect the print quality too "
"much. However, it is still advised to double-check the suggested parameters,"
" and print some test prints before using them to confirm they are good."
msgstr ""
"또한 측정의 일부 노이즈로 인해 조정 결과가 교정 실행마다 약간 다를 수 있습니다. 그러나 노이즈가 인쇄 품질에 너무 많은 영향을 줄 "
"것으로 예상되지는 않습니다. 그러나 여전히 제안된 매개변수를 다시 확인하고 테스트 인쇄물을 인쇄하여 사용하기 전에 양호한지 확인하는 것이"
" 좋습니다."

msgid "Offline processing of the accelerometer data"
msgstr "가속도계 데이터의 오프라인 처리"

msgid ""
"It is possible to generate the raw accelerometer data and process it offline"
" (e.g. on a host machine), for example to find resonances. In order to do "
"so, run the following commands via Octoprint terminal:"
msgstr ""
"예를 들어 공진을 찾기 위해 원시 가속도계 데이터를 생성하고 오프라인으로(예: 호스트 머신에서) 처리할 수 있습니다. 그렇게 하려면 "
"Octoprint 터미널을 통해 다음 명령을 실행하십시오:"

msgid ""
"ignoring any errors for `SET_INPUT_SHAPER` command. For `TEST_RESONANCES` "
"command, specify the desired test axis. The raw data will be written into "
"`/tmp` directory on the RPi."
msgstr ""
"`SET_INPUT_SHAPER` 명령에 대한 오류를 무시합니다. `TEST_RESONANCES` 명령의 경우 원하는 테스트 축을 "
"지정합니다. 원시 데이터는 RPi의 `/tmp` 디렉토리에 기록됩니다."

msgid ""
"The data can be processed later by the following scripts: "
"`scripts/graph_accelerometer.py` and `scripts/calibrate_shaper.py`. Both of "
"them accept one or several raw csv files as the input depending on the mode."
" The graph_accelerometer.py script supports several modes of operation:"
msgstr ""
"데이터는 나중에 다음 스크립트로 처리할 수 있습니다: `scripts/graph_accelerometer.py` 및 "
"`scripts/calibrate_shaper.py`. 둘 다 모드에 따라 하나 또는 여러 개의 원시 csv 파일을 입력으로 허용합니다."
" graph_accelerometer.py 스크립트는 여러 작동 모드를 지원합니다:"

msgid ""
"plotting raw accelerometer data (use `-r` parameter), only 1 input is "
"supported;"
msgstr "원시 가속도계 데이터 플로팅(`-r` 매개변수 사용), 1개의 입력만 지원됩니다;"

msgid ""
"plotting a frequency response (no extra parameters required), if multiple "
"inputs are specified, the average frequency response is computed;"
msgstr "주파수 응답을 플로팅(추가 매개변수가 필요하지 않음), 다중 입력이 지정된 경우 평균 주파수 응답이 계산됩니다;"

msgid ""
"comparison of the frequency response between several inputs (use `-c` "
"parameter); you can additionally specify which accelerometer axis to "
"consider via `-a x`, `-a y` or `-a z` parameter (if none specified, the sum "
"of vibrations for all axes is used);"
msgstr ""
"여러 입력 간의 주파수 응답 비교(`-c` 매개변수 사용) `-a x`, `-a y` 또는 `-a z` 매개변수를 통해 고려할 가속도계 "
"축을 추가로 지정할 수 있습니다(지정되지 않은 경우 모든 축의 진동 합계가 사용됨);"

msgid ""
"plotting the spectrogram (use `-s` parameter), only 1 input is supported; "
"you can additionally specify which accelerometer axis to consider via `-a "
"x`, `-a y` or `-a z` parameter (if none specified, the sum of vibrations for"
" all axes is used)."
msgstr ""
"스펙트로그램 플로팅(`-s` 매개변수 사용), 1개의 입력만 지원됩니다. `-a x`, `-a y` 또는 `-a z` 매개변수를 통해 "
"고려할 가속도계 축을 추가로 지정할 수 있습니다(지정되지 않은 경우 모든 축의 진동 합계가 사용됨)."

msgid ""
"Note that graph_accelerometer.py script supports only the raw_data\\*.csv "
"files and not resonances\\*.csv or calibration_data\\*.csv files."
msgstr ""
"graph_accelerometer.py 스크립트는 raw_data\\*.csv 파일만 지원하고 resonances\\*.csv 또는 "
"calibration_data\\*.csv 파일은 지원하지 않습니다."

msgid "For example,"
msgstr "예를 들어,"

msgid ""
"will plot the comparison of several `/tmp/raw_data_x_*.csv` files for Z axis"
" to `/tmp/resonances_x.png` file."
msgstr ""
"Z 축에 대한 여러 `/tmp/raw_data_x_*.csv` 파일을 `/tmp/resonances_x.png` 파일과 비교하여 "
"플롯합니다."

msgid ""
"The shaper_calibrate.py script accepts 1 or several inputs and can run "
"automatic tuning of the input shaper and suggest the best parameters that "
"work well for all provided inputs. It prints the suggested parameters to the"
" console, and can additionally generate the chart if `-o output.png` "
"parameter is provided, or the CSV file if `-c output.csv` parameter is "
"specified."
msgstr ""
"shaper_calibration.py 스크립트는 하나 이상의 입력을 허용하고 입력 shaper의 자동 조정을 실행할 수 있고 제공된 "
"모든 입력에 대해 잘 작동하는 최상의 매개변수를 제안할 수 있습니다. 제안된 매개변수를 콘솔에 출력하고 `-o output.png` "
"매개변수가 제공된 경우 차트를 추가로 생성하거나 `-c output.csv` 매개변수가 지정된 경우 CSV 파일을 생성할 수 있습니다."

msgid ""
"Providing several inputs to shaper_calibrate.py script can be useful if "
"running some advanced tuning of the input shapers, for example:"
msgstr ""
"shaper_calibration.py 스크립트에 여러 입력을 제공하면 입력 셰이퍼의 일부 고급 조정을 실행하는 경우 유용할 수 "
"있습니다. 예를 들면 다음과 같습니다:"

msgid ""
"Running `TEST_RESONANCES AXIS=X OUTPUT=raw_data` (and `Y` axis) for a single"
" axis twice on a bed slinger printer with the accelerometer attached to the "
"toolhead the first time, and the accelerometer attached to the bed the "
"second time in order to detect axes cross-resonances and attempt to cancel "
"them with input shapers."
msgstr ""
"처음에는 툴 헤드에 가속도계가 부착된 bed slinger 프린터에서 단일 축에 대해 `TEST_RESONANCES AXIS=X "
"OUTPUT=raw_data`(및 `Y` 축)를 두 번 실행하고 두 번째로 베드에 가속도계를 부착한 순서대로 실행 축 교차 공명을 "
"감지하고 입력 셰이퍼로 취소하려고 시도합니다."

msgid ""
"Running `TEST_RESONANCES AXIS=Y OUTPUT=raw_data` twice on a bed slinger with"
" a glass bed and a magnetic surfaces (which is lighter) to find the input "
"shaper parameters that work well for any print surface configuration."
msgstr ""
"유리 베드와 자성 표면 (더 가벼움)이 있는 bed slinger에서 `TEST_RESONANCES AXIS=Y "
"OUTPUT=raw_data`를 두 번 실행하여 모든 인쇄 표면 구성에 잘 작동하는 입력 셰이퍼 매개변수를 찾습니다."

msgid "Combining the resonance data from multiple test points."
msgstr "여러 테스트 지점의 공진 데이터 결합."

msgid ""
"Combining the resonance data from 2 axis (e.g. on a bed slinger printer to "
"configure X-axis input_shaper from both X and Y axes resonances to cancel "
"vibrations of the *bed* in case the nozzle 'catches' a print when moving in "
"X axis direction)."
msgstr ""
"2축의 공명 데이터 결합 (예: bed slinger 프린터에서 X축과 Y축 모두에서 X축 input_shaper 를 구성하는 공진은 "
"X축 방향으로 이동할 때 노즐이 인쇄물을 '치는' 경우 *BED* 의 진동을 취소하기 위해 공진)."

msgid "~/klippy-env/bin/pip install -v numpy\n"
msgstr "~/klippy-env/bin/pip install -v numpy\n"

msgid "Recv: // adxl345 values (x, y, z): 470.719200, 941.438400, 9728.196800\n"
msgstr ""
"Recv: // adxl345 values (x, y, z): 470.719200, 941.438400, 9728.196800\n"

msgid "TEST_RESONANCES AXIS=X\n"
msgstr "TEST_RESONANCES AXIS=X\n"

msgid ""
"[resonance_tester]\n"
"accel_chip: adxl345\n"
"accel_per_hz: 50  # default is 75\n"
"probe_points: ...\n"
msgstr ""
"[resonance_tester]\n"
"accel_chip: adxl345\n"
"accel_per_hz: 50  # default is 75\n"
"probe_points: ...\n"

msgid "TEST_RESONANCES AXIS=Y\n"
msgstr "TEST_RESONANCES AXIS=Y\n"

msgid ""
"~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png\n"
"~/klipper/scripts/calibrate_shaper.py /tmp/resonances_y_*.csv -o /tmp/shaper_calibrate_y.png\n"
msgstr ""
"~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o /tmp/shaper_calibrate_x.png\n"
"~/klipper/scripts/calibrate_shaper.py /tmp/resonances_y_*.csv -o /tmp/shaper_calibrate_y.png\n"

msgid ""
"Fitted shaper 'zv' frequency = 34.4 Hz (vibrations = 4.0%, smoothing ~= 0.132)\n"
"To avoid too much smoothing with 'zv', suggested max_accel <= 4500 mm/sec^2\n"
"Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 0.0%, smoothing ~= 0.170)\n"
"To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2\n"
"Fitted shaper 'ei' frequency = 41.4 Hz (vibrations = 0.0%, smoothing ~= 0.188)\n"
"To avoid too much smoothing with 'ei', suggested max_accel <= 3200 mm/sec^2\n"
"Fitted shaper '2hump_ei' frequency = 51.8 Hz (vibrations = 0.0%, smoothing ~= 0.201)\n"
"To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2\n"
"Fitted shaper '3hump_ei' frequency = 61.8 Hz (vibrations = 0.0%, smoothing ~= 0.215)\n"
"To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2800 mm/sec^2\n"
"Recommended shaper is mzv @ 34.6 Hz\n"
msgstr ""
"Fitted shaper 'zv' frequency = 34.4 Hz (vibrations = 4.0%, smoothing ~= 0.132)\n"
"To avoid too much smoothing with 'zv', suggested max_accel <= 4500 mm/sec^2\n"
"Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 0.0%, smoothing ~= 0.170)\n"
"To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2\n"
"Fitted shaper 'ei' frequency = 41.4 Hz (vibrations = 0.0%, smoothing ~= 0.188)\n"
"To avoid too much smoothing with 'ei', suggested max_accel <= 3200 mm/sec^2\n"
"Fitted shaper '2hump_ei' frequency = 51.8 Hz (vibrations = 0.0%, smoothing ~= 0.201)\n"
"To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2\n"
"Fitted shaper '3hump_ei' frequency = 61.8 Hz (vibrations = 0.0%, smoothing ~= 0.215)\n"
"To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2800 mm/sec^2\n"
"Recommended shaper is mzv @ 34.6 Hz\n"

msgid ""
"[input_shaper]\n"
"shaper_freq_x: ...\n"
"shaper_type_x: ...\n"
"shaper_freq_y: 34.6\n"
"shaper_type_y: mzv\n"
"\n"
"[printer]\n"
"max_accel: 3000  # should not exceed the estimated max_accel for X and Y axes\n"
msgstr ""
"[input_shaper]\n"
"shaper_freq_x: ...\n"
"shaper_type_x: ...\n"
"shaper_freq_y: 34.6\n"
"shaper_type_y: mzv\n"
"\n"
"[printer]\n"
"max_accel: 3000  # should not exceed the estimated max_accel for X and Y axes\n"

msgid ""
"[adxl345 hotend]\n"
"# Assuming `hotend` chip is connected to an RPi\n"
"cs_pin: rpi:None\n"
"\n"
"[adxl345 bed]\n"
"# Assuming `bed` chip is connected to a printer MCU board\n"
"cs_pin: ...  # Printer board SPI chip select (CS) pin\n"
"\n"
"[resonance_tester]\n"
"# Assuming the typical setup of the bed slinger printer\n"
"accel_chip_x: adxl345 hotend\n"
"accel_chip_y: adxl345 bed\n"
"probe_points: ...\n"
msgstr ""
"[adxl345 hotend]\n"
"# Assuming `hotend` chip is connected to an RPi\n"
"cs_pin: rpi:None\n"
"\n"
"[adxl345 bed]\n"
"# Assuming `bed` chip is connected to a printer MCU board\n"
"cs_pin: ...  # Printer board SPI chip select (CS) pin\n"
"\n"
"[resonance_tester]\n"
"# Assuming the typical setup of the bed slinger printer\n"
"accel_chip_x: adxl345 hotend\n"
"accel_chip_y: adxl345 bed\n"
"probe_points: ...\n"

msgid ""
"Fitted shaper 'zv' frequency = 57.8 Hz (vibrations = 20.3%, smoothing ~= 0.053)\n"
"To avoid too much smoothing with 'zv', suggested max_accel <= 13000 mm/sec^2\n"
"Fitted shaper 'mzv' frequency = 34.8 Hz (vibrations = 3.6%, smoothing ~= 0.168)\n"
"To avoid too much smoothing with 'mzv', suggested max_accel <= 3600 mm/sec^2\n"
"Fitted shaper 'ei' frequency = 48.8 Hz (vibrations = 4.9%, smoothing ~= 0.135)\n"
"To avoid too much smoothing with 'ei', suggested max_accel <= 4400 mm/sec^2\n"
"Fitted shaper '2hump_ei' frequency = 45.2 Hz (vibrations = 0.1%, smoothing ~= 0.264)\n"
"To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2200 mm/sec^2\n"
"Fitted shaper '3hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.356)\n"
"To avoid too much smoothing with '3hump_ei', suggested max_accel <= 1500 mm/sec^2\n"
"Recommended shaper is 2hump_ei @ 45.2 Hz\n"
msgstr ""
"Fitted shaper 'zv' frequency = 57.8 Hz (vibrations = 20.3%, smoothing ~= 0.053)\n"
"To avoid too much smoothing with 'zv', suggested max_accel <= 13000 mm/sec^2\n"
"Fitted shaper 'mzv' frequency = 34.8 Hz (vibrations = 3.6%, smoothing ~= 0.168)\n"
"To avoid too much smoothing with 'mzv', suggested max_accel <= 3600 mm/sec^2\n"
"Fitted shaper 'ei' frequency = 48.8 Hz (vibrations = 4.9%, smoothing ~= 0.135)\n"
"To avoid too much smoothing with 'ei', suggested max_accel <= 4400 mm/sec^2\n"
"Fitted shaper '2hump_ei' frequency = 45.2 Hz (vibrations = 0.1%, smoothing ~= 0.264)\n"
"To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2200 mm/sec^2\n"
"Fitted shaper '3hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.356)\n"
"To avoid too much smoothing with '3hump_ei', suggested max_accel <= 1500 mm/sec^2\n"
"Recommended shaper is 2hump_ei @ 45.2 Hz\n"

msgid ""
"~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o "
"/tmp/shaper_calibrate_x.png --max_smoothing=0.2\n"
msgstr ""
"~/klipper/scripts/calibrate_shaper.py /tmp/resonances_x_*.csv -o "
"/tmp/shaper_calibrate_x.png --max_smoothing=0.2\n"

msgid ""
"Fitted shaper 'zv' frequency = 55.4 Hz (vibrations = 19.7%, smoothing ~= 0.057)\n"
"To avoid too much smoothing with 'zv', suggested max_accel <= 12000 mm/sec^2\n"
"Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 3.6%, smoothing ~= 0.170)\n"
"To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2\n"
"Fitted shaper 'ei' frequency = 48.2 Hz (vibrations = 4.8%, smoothing ~= 0.139)\n"
"To avoid too much smoothing with 'ei', suggested max_accel <= 4300 mm/sec^2\n"
"Fitted shaper '2hump_ei' frequency = 52.0 Hz (vibrations = 2.7%, smoothing ~= 0.200)\n"
"To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2\n"
"Fitted shaper '3hump_ei' frequency = 72.6 Hz (vibrations = 1.4%, smoothing ~= 0.155)\n"
"To avoid too much smoothing with '3hump_ei', suggested max_accel <= 3900 mm/sec^2\n"
"Recommended shaper is 3hump_ei @ 72.6 Hz\n"
msgstr ""
"Fitted shaper 'zv' frequency = 55.4 Hz (vibrations = 19.7%, smoothing ~= 0.057)\n"
"To avoid too much smoothing with 'zv', suggested max_accel <= 12000 mm/sec^2\n"
"Fitted shaper 'mzv' frequency = 34.6 Hz (vibrations = 3.6%, smoothing ~= 0.170)\n"
"To avoid too much smoothing with 'mzv', suggested max_accel <= 3500 mm/sec^2\n"
"Fitted shaper 'ei' frequency = 48.2 Hz (vibrations = 4.8%, smoothing ~= 0.139)\n"
"To avoid too much smoothing with 'ei', suggested max_accel <= 4300 mm/sec^2\n"
"Fitted shaper '2hump_ei' frequency = 52.0 Hz (vibrations = 2.7%, smoothing ~= 0.200)\n"
"To avoid too much smoothing with '2hump_ei', suggested max_accel <= 3000 mm/sec^2\n"
"Fitted shaper '3hump_ei' frequency = 72.6 Hz (vibrations = 1.4%, smoothing ~= 0.155)\n"
"To avoid too much smoothing with '3hump_ei', suggested max_accel <= 3900 mm/sec^2\n"
"Recommended shaper is 3hump_ei @ 72.6 Hz\n"

msgid ""
"[resonance_tester]\n"
"accel_chip: ...\n"
"probe_points: ...\n"
"max_smoothing: 0.25  # an example\n"
msgstr ""
"[resonance_tester]\n"
"accel_chip: ...\n"
"probe_points: ...\n"
"max_smoothing: 0.25  # an example\n"

msgid "SHAPER_CALIBRATE\n"
msgstr "SHAPER_CALIBRATE\n"

msgid ""
"Calculating the best input shaper parameters for y axis\n"
"Fitted shaper 'zv' frequency = 39.0 Hz (vibrations = 13.2%, smoothing ~= 0.105)\n"
"To avoid too much smoothing with 'zv', suggested max_accel <= 5900 mm/sec^2\n"
"Fitted shaper 'mzv' frequency = 36.8 Hz (vibrations = 1.7%, smoothing ~= 0.150)\n"
"To avoid too much smoothing with 'mzv', suggested max_accel <= 4000 mm/sec^2\n"
"Fitted shaper 'ei' frequency = 36.6 Hz (vibrations = 2.2%, smoothing ~= 0.240)\n"
"To avoid too much smoothing with 'ei', suggested max_accel <= 2500 mm/sec^2\n"
"Fitted shaper '2hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.234)\n"
"To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2500 mm/sec^2\n"
"Fitted shaper '3hump_ei' frequency = 59.0 Hz (vibrations = 0.0%, smoothing ~= 0.235)\n"
"To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2500 mm/sec^2\n"
"Recommended shaper_type_y = mzv, shaper_freq_y = 36.8 Hz\n"
msgstr ""
"Calculating the best input shaper parameters for y axis\n"
"Fitted shaper 'zv' frequency = 39.0 Hz (vibrations = 13.2%, smoothing ~= 0.105)\n"
"To avoid too much smoothing with 'zv', suggested max_accel <= 5900 mm/sec^2\n"
"Fitted shaper 'mzv' frequency = 36.8 Hz (vibrations = 1.7%, smoothing ~= 0.150)\n"
"To avoid too much smoothing with 'mzv', suggested max_accel <= 4000 mm/sec^2\n"
"Fitted shaper 'ei' frequency = 36.6 Hz (vibrations = 2.2%, smoothing ~= 0.240)\n"
"To avoid too much smoothing with 'ei', suggested max_accel <= 2500 mm/sec^2\n"
"Fitted shaper '2hump_ei' frequency = 48.0 Hz (vibrations = 0.0%, smoothing ~= 0.234)\n"
"To avoid too much smoothing with '2hump_ei', suggested max_accel <= 2500 mm/sec^2\n"
"Fitted shaper '3hump_ei' frequency = 59.0 Hz (vibrations = 0.0%, smoothing ~= 0.235)\n"
"To avoid too much smoothing with '3hump_ei', suggested max_accel <= 2500 mm/sec^2\n"
"Recommended shaper_type_y = mzv, shaper_freq_y = 36.8 Hz\n"

msgid "SHAPER_CALIBRATE AXIS=Y\n"
msgstr "SHAPER_CALIBRATE AXIS=Y\n"

msgid "SHAPER_CALIBRATE AXIS=X\n"
msgstr "SHAPER_CALIBRATE AXIS=X\n"

msgid ""
"SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0\n"
"TEST_RESONANCES AXIS=X OUTPUT=raw_data\n"
msgstr ""
"SET_INPUT_SHAPER SHAPER_FREQ_X=0 SHAPER_FREQ_Y=0\n"
"TEST_RESONANCES AXIS=X OUTPUT=raw_data\n"

msgid ""
"~/klipper/scripts/graph_accelerometer.py /tmp/raw_data_x_*.csv -o "
"/tmp/resonances_x.png -c -a z\n"
msgstr ""
"~/klipper/scripts/graph_accelerometer.py /tmp/raw_data_x_*.csv -o "
"/tmp/resonances_x.png -c -a z\n"

#: docs/Measuring_Resonances.md:block 80 (header)
msgid "Testing custom axes"
msgstr "사용자 정의 축 테스트"

#: docs/Measuring_Resonances.md:block 81 (paragraph)
msgid ""
"`TEST_RESONANCES` command supports custom axes. While this is not really "
"useful for input shaper calibration, it can be used to study printer "
"resonances in-depth and to check, for example, belt tension."
msgstr ""
"`TEST_RESONANCES` 명령은 사용자 지정 축을 지원합니다. 이것은 입력 셰이퍼 보정에 실제로 유용하지 않지만 프린터 공진을 "
"심층적으로 연구하고 예를 들어 벨트 장력을 확인하는 데 사용할 수 있습니다."

#: docs/Measuring_Resonances.md:block 82 (paragraph)
msgid "To check the belt tension on CoreXY printers, execute"
msgstr "CoreXY 프린터의 벨트 장력을 확인하려면 다음을 실행하십시오"

#: docs/Measuring_Resonances.md:block 83 (code)
msgid ""
"TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data\n"
"TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data\n"
msgstr ""
"TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data\n"
"TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data\n"

#: docs/Measuring_Resonances.md:block 84 (paragraph)
msgid "and use `graph_accelerometer.py` to process the generated files, e.g."
msgstr "생성된 파일을 처리하기 위해 `graph_accelerometer.py`를 사용합니다, 예들들어."

#: docs/Measuring_Resonances.md:block 85 (code)
msgid ""
"~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o "
"/tmp/resonances.png\n"
msgstr ""
"~/klipper/scripts/graph_accelerometer.py -c /tmp/raw_data_axis*.csv -o "
"/tmp/resonances.png\n"

#: docs/Measuring_Resonances.md:block 86 (paragraph)
msgid "which will generate `/tmp/resonances.png` comparing the resonances."
msgstr "이것은 공명을 비교하는 `/tmp/resonances.png`를 생성합니다."

#: docs/Measuring_Resonances.md:block 87 (paragraph)
msgid ""
"For Delta printers with the default tower placement (tower A ~= 210 degrees,"
" B ~= 330 degrees, and C ~= 90 degrees), execute"
msgstr ""
"기본 타워 배치(타워 A ~= 210도, B ~= 330도 및 C ~= 90도)가 있는 Delta 프린터의 경우 다음을 실행합니다"

#: docs/Measuring_Resonances.md:block 88 (code)
msgid ""
"TEST_RESONANCES AXIS=0,1 OUTPUT=raw_data\n"
"TEST_RESONANCES AXIS=-0.866025404,-0.5 OUTPUT=raw_data\n"
"TEST_RESONANCES AXIS=0.866025404,-0.5 OUTPUT=raw_data\n"
msgstr ""
"TEST_RESONANCES AXIS=0,1 OUTPUT=raw_data\n"
"TEST_RESONANCES AXIS=-0.866025404,-0.5 OUTPUT=raw_data\n"
"TEST_RESONANCES AXIS=0.866025404,-0.5 OUTPUT=raw_data\n"

#: docs/Measuring_Resonances.md:block 89 (paragraph)
msgid "and then use the same command"
msgstr "그런 다음 동일한 명령을 사용하십시오"

#: docs/Measuring_Resonances.md:block 91 (paragraph)
msgid "to generate `/tmp/resonances.png` comparing the resonances."
msgstr "그러면 공명을 비교하는 `/tmp/resonances.png`를 생성합니다."

#: docs/Measuring_Resonances.md:block 3 (paragraph)
msgid ""
"When sourcing ADXL345, be aware that there is a variety of different PCB "
"board designs and different clones of them. Make sure that the board "
"supports SPI mode (small number of boards appear to be hard-configured for "
"I2C by pulling SDO to GND), and, if it is going to be connected to a 5V "
"printer MCU, that it has a voltage regulator and a level shifter."
msgstr ""

#: docs/Measuring_Resonances.md:block 26 (code)
msgid ""
"[mcu rpi]\n"
"serial: /tmp/klipper_host_mcu\n"
"\n"
"[adxl345]\n"
"cs_pin: rpi:None\n"
"\n"
"[resonance_tester]\n"
"accel_chip: adxl345\n"
"probe_points:\n"
"    100, 100, 20  # an example\n"
msgstr ""

#: docs/Measuring_Resonances.md:block 45 (paragraph)
msgid ""
"This will generate 2 CSV files (`/tmp/resonances_x_*.csv` and "
"`/tmp/resonances_y_*.csv`). These files can be processed with the stand-"
"alone script on a Raspberry Pi. To do that, run the following commands:"
msgstr ""

#: docs/Measuring_Resonances.md:block 111 (paragraph)
msgid ""
"The raw data can also be obtained by running the command "
"`ACCELEROMETER_MEASURE` command twice during some normal printer activity - "
"first to start the measurements, and then to stop them and write the output "
"file. Refer to [G-Codes](G-Codes.md#adxl345) for more details."
msgstr ""

#: docs/Measuring_Resonances.md:block 8 (paragraph)
msgid ""
"An alternative to the ADXL345 is the MPU-9250 (or MPU-6050). This "
"accelerometer has been tested to work over I2C on the RPi at 400kbaud. "
"Recommended connection scheme for I2C:"
msgstr ""

#: docs/Measuring_Resonances.md:block 9 (table)
msgid "MPU-9250 pin"
msgstr ""

#: docs/Measuring_Resonances.md:block 9 (table)
msgid "09"
msgstr ""

#: docs/Measuring_Resonances.md:block 9 (table)
msgid "03"
msgstr ""

#: docs/Measuring_Resonances.md:block 9 (table)
msgid "GPIO02 (SDA1)"
msgstr ""

#: docs/Measuring_Resonances.md:block 9 (table)
msgid "05"
msgstr ""

#: docs/Measuring_Resonances.md:block 9 (table)
msgid "GPIO03 (SCL1)"
msgstr ""

#: docs/Measuring_Resonances.md:block 20 (paragraph)
msgid ""
"Note that resonance measurements and shaper auto-calibration require "
"additional software dependencies not installed by default. First, run on "
"your Raspberry Pi the following commands:"
msgstr ""

#: docs/Measuring_Resonances.md:block 21 (code)
msgid ""
"sudo apt update\n"
"sudo apt install python3-numpy python3-matplotlib libatlas-base-dev\n"
msgstr ""

#: docs/Measuring_Resonances.md:block 22 (paragraph)
msgid ""
"Next, in order to install NumPy in the Klipper environment, run the command:"
msgstr ""

#: docs/Measuring_Resonances.md:block 24 (paragraph)
msgid ""
"Note that, depending on the performance of the CPU, it may take *a lot* of "
"time, up to 10-20 minutes. Be patient and wait for the completion of the "
"installation. On some occasions, if the board has too little RAM the "
"installation may fail and you will need to enable swap."
msgstr ""

#: docs/Measuring_Resonances.md:block 27 (paragraph)
msgid "For the ADXL345, add the following to the printer.cfg file:"
msgstr ""

#: docs/Measuring_Resonances.md:block 30 (paragraph)
msgid ""
"For the MPU-9250, make sure the Linux I2C driver is enabled and the baud "
"rate is set to 400000 (see [Enabling I2C](RPi_microcontroller.md#optional-"
"enabling-i2c) section for more details). Then, add the following to the "
"printer.cfg:"
msgstr ""

#: docs/Measuring_Resonances.md:block 31 (code)
msgid ""
"[mcu rpi]\n"
"serial: /tmp/klipper_host_mcu\n"
"\n"
"[mpu9250]\n"
"i2c_mcu: rpi\n"
"i2c_bus: i2c.1\n"
"\n"
"[resonance_tester]\n"
"accel_chip: mpu9250\n"
"probe_points:\n"
"    100, 100, 20  # an example\n"
msgstr ""

#~ msgid ""
#~ "Note that resonance measurements and shaper auto-calibration require "
#~ "additional software dependencies not installed by default. First, you will "
#~ "have to run on your Raspberry Pi the following command:"
#~ msgstr ""
#~ "공진 측정 및 셰이퍼 자동 보정에는 기본적으로 설치가 필요한 소프트웨어가 있습니다. 먼저 Raspberry Pi에서 다음 명령을 실행해야"
#~ " 합니다:"

#~ msgid ""
#~ "to install `numpy` package. Note that, depending on the performance of the "
#~ "CPU, it may take *a lot* of time, up to 10-20 minutes. Be patient and wait "
#~ "for the completion of the installation. On some occasions, if the board has "
#~ "too little RAM, the installation may fail and you will need to enable swap."
#~ msgstr ""
#~ "`numpy` 패키지를 설치합니다. CPU 성능에 따라 최대 10-20분까지 *많은* 시간이 소요될 수 있습니다. 인내심을 갖고 설치가 "
#~ "완료될 때까지 기다리십시오. 경우에 따라 보드에 RAM이 너무 적으면 설치에 실패할 수 있으며 스왑을 활성화해야 합니다."

#~ msgid "Add the following to the printer.cfg file:"
#~ msgstr "다음을 printer.cfg 파일에 추가합니다:"

#~ msgid ""
#~ "Next, run the following commands to install the additional dependencies:"
#~ msgstr "그런 다음 동일한 명령을 사용하여 설치 하십시오:"

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install python3-numpy python3-matplotlib\n"
#~ msgstr ""

#~ msgid ""
#~ "This will generate 2 CSV files (`/tmp/resonances_x_*.csv` and "
#~ "`/tmp/resonances_y_*.csv`). These files can be processed with the stand-"
#~ "alone script on a Raspberry Pi. To do that, run running the following "
#~ "commands:"
#~ msgstr ""
#~ "이렇게 하면 2개의 CSV 파일 (`/tmp/resonances_x_*.csv` 및 `/tmp/resonances_y_*.csv`) 이 "
#~ "생성됩니다. This will generate 2 CSV files (`/tmp/resonances_x_*.csv` and "
#~ "`/tmp/resonances_y_*.csv`). 이 파일들은 Raspberry Pi 에서 독립 실행형 스크립트로 처리할 수 있습니다. "
#~ "그렇게 하려면 다음 명령을 실행하십시오:"

#~ msgid ""
#~ "The raw data can also be obtained by running the command "
#~ "`ACCELEROMETER_MEASURE` command twice during some normal printer activity - "
#~ "first to start the measurements, and then to stop them and write the output "
#~ "file. Refer to [G-Codes](G-Codes.md#adxl345-accelerometer-commands) for more"
#~ " details."
#~ msgstr ""
#~ "원시 데이터는 정상적인 프린터 활동 중에 `ACCELEROMETER_MEASURE` 명령을 두 번 실행하여 얻을 수도 있습니다. 먼저 "
#~ "측정을 시작한 다음 측정을 중지하고 출력 파일을 작성합니다. 자세한 내용은 "
#~ "[G-Codes](G-Codes.md#adxl345-accelerometer-commands) 를 참조하세요."

#~ msgid ""
#~ "[mcu rpi]\n"
#~ "serial: /tmp/klipper_host_mcu\n"
#~ "\n"
#~ "[adxl345]\n"
#~ "cs_pin: rpi:None\n"
#~ "\n"
#~ "[resonance_tester]\n"
#~ "accel_chip: adxl345\n"
#~ "probe_points:\n"
#~ "    100,100,20  # an example\n"
#~ msgstr ""
#~ "[mcu rpi]\n"
#~ "serial: /tmp/klipper_host_mcu\n"
#~ "\n"
#~ "[adxl345]\n"
#~ "cs_pin: rpi:None\n"
#~ "\n"
#~ "[resonance_tester]\n"
#~ "accel_chip: adxl345\n"
#~ "probe_points:\n"
#~ "    100,100,20  # an example\n"

#~ msgid ""
#~ "sudo apt update\n"
#~ "sudo apt install python-numpy python-matplotlib\n"
#~ msgstr ""
#~ "sudo apt update\n"
#~ "sudo apt install python-numpy python-matplotlib\n"

#~ msgid ""
#~ "When sourcing ADLX345, be aware that there is a variety of different PCB "
#~ "board designs and different clones of them. Make sure that the board "
#~ "supports SPI mode (small number of boards appear to be hard-configured for "
#~ "I2C by pulling SDO to GND), and, if it is going to be connected to a 5V "
#~ "printer MCU, that it has a voltage regulator and a level shifter."
#~ msgstr ""
#~ "ADLX345를 구입할 때 다양한 PCB 보드 디자인과 다양한 복제품이 있다는 점에 유의하십시오. 보드가 SPI 모드를 지원하는지 "
#~ "확인하십시오 (어떤 보드는 SDO 를 GND 로 당겨서 I2C 에 대해 하드 구성되어 있는 것으로 나타남). 그리고 5V 프린터 MCU "
#~ "에 연결하려는 경우 전압 레귤레이터 및 레벨 시프터가 필요할 수 있습니다."

#~ msgid ""
#~ "Next, run the following command to install the additional dependencies:"
#~ msgstr ""

#~ msgid "sudo apt install python-numpy python-matplotlib\n"
#~ msgstr ""
