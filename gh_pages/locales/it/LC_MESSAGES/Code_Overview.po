# Dex94 <Dasvaresu@dr.com>, 2022.
# Ale Ale <ale.99.ale@gmail.com>, 2022.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2022-08-19 13:22+0000\n"
"Last-Translator: Ale Ale <ale.99.ale@gmail.com>\n"
"Language-Team: Italian <https://hosted.weblate.org/projects/klipper/code_overview/it/>\n"
"Language: it\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 4.14-dev\n"

msgid ""
"This document describes the overall code layout and major code flow of "
"Klipper."
msgstr ""
"Questo documento descrive il formato generale del codice e il flusso "
"principale del codice di Klipper."

msgid "Directory Layout"
msgstr "Directory Layout"

msgid ""
"The **src/** directory contains the C source for the micro-controller code. "
"The **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, "
"**src/lpc176x/**, **src/pru/**, and **src/stm32/** directories contain "
"architecture specific micro-controller code. The **src/simulator/** contains"
" code stubs that allow the micro-controller to be test compiled on other "
"architectures. The **src/generic/** directory contains helper code that may "
"be useful across different architectures. The build arranges for includes of"
" \"board/somefile.h\" to first look in the current architecture directory "
"(eg, src/avr/somefile.h) and then in the generic directory (eg, "
"src/generic/somefile.h)."
msgstr ""
"La directory **src/** contiene il sorgente C per il codice del "
"microcontrollore. **src/atsam/**, **src/atsamd/**, **src/avr/**, "
"**src/linux/**, **src/lpc176x/**, **src/ Le directory pru/** e "
"**src/stm32/** contengono il codice del microcontrollore specifico "
"dell'architettura. **src/simulator/** contiene stub di codice che consentono"
" la compilazione di test del microcontrollore su altre architetture. La "
"directory **src/generic/** contiene codice di supporto che può essere utile "
"in diverse architetture. La build fa in modo che le include di "
"\"board/somefile.h\" guardino prima nella directory dell'architettura "
"corrente (ad esempio, src/avr/somefile.h) e poi nella directory generica (ad"
" esempio, src/generic/somefile.h)."

msgid ""
"The **klippy/** directory contains the host software. Most of the host "
"software is written in Python, however the **klippy/chelper/** directory "
"contains some C code helpers. The **klippy/kinematics/** directory contains "
"the robot kinematics code. The **klippy/extras/** directory contains the "
"host code extensible \"modules\"."
msgstr ""
"La directory **klippy/** contiene il software host. La maggior parte del "
"software host è scritto in Python, tuttavia la directory **klippy/chelper/**"
" contiene alcuni helper del codice C. La directory **klippy/kinematics/** "
"contiene il codice della cinematica del robot. La directory "
"**klippy/extras/** contiene i \"moduli\" estensibili del codice host."

msgid ""
"The **lib/** directory contains external 3rd-party library code that is "
"necessary to build some targets."
msgstr ""
"La directory **lib/** contiene il codice della libreria di terze parti "
"esterne necessarie per creare alcune destinazioni."

msgid ""
"The **config/** directory contains example printer configuration files."
msgstr ""
"La directory **config/** contiene file di configurazione della stampante di "
"esempio."

msgid ""
"The **scripts/** directory contains build-time scripts useful for compiling "
"the micro-controller code."
msgstr ""
"La directory **scripts/** contiene script di build-time utili per compilare "
"il codice del microcontrollore."

msgid "The **test/** directory contains automated test cases."
msgstr "La directory **test/** contiene test case automatizzati."

msgid ""
"During compilation, the build may create an **out/** directory. This "
"contains temporary build time objects. The final micro-controller object "
"that is built is **out/klipper.elf.hex** on AVR and **out/klipper.bin** on "
"ARM."
msgstr ""
"Durante la compilazione, la build potrebbe creare una directory **out/**. "
"Questa contiene oggetti temporanei di compilazione. L'oggetto "
"microcontrollore finale che viene creato è **out/klipper.elf.hex** su AVR e "
"**out/klipper.bin** su ARM."

msgid "Micro-controller code flow"
msgstr "Flusso del codice del microcontrollore"

msgid ""
"Execution of the micro-controller code starts in architecture specific code "
"(eg, **src/avr/main.c**) which ultimately calls sched_main() located in "
"**src/sched.c**. The sched_main() code starts by running all functions that "
"have been tagged with the DECL_INIT() macro. It then goes on to repeatedly "
"run all functions tagged with the DECL_TASK() macro."
msgstr ""
"L'esecuzione del codice del microcontrollore inizia nel codice specifico "
"dell'architettura (ad esempio, **src/avr/main.c**) che alla fine chiama "
"sched_main() che si trova in **src/sched.c**. Il codice sched_main() inizia "
"eseguendo tutte le funzioni che sono state contrassegnate con la macro "
"DECL_INIT(). Quindi continua a eseguire ripetutamente tutte le funzioni "
"contrassegnate con la macro DECL_TASK()."

msgid ""
"One of the main task functions is command_dispatch() located in "
"**src/command.c**. This function is called from the board specific "
"input/output code (eg, **src/avr/serial.c**, **src/generic/serial_irq.c**) "
"and it runs the command functions associated with the commands found in the "
"input stream. Command functions are declared using the DECL_COMMAND() macro "
"(see the [protocol](Protocol.md) document for more information)."
msgstr ""
"Una delle principali funzioni dell'attività è command_dispatch() che si "
"trova in **src/command.c**. Questa funzione viene richiamata dal codice "
"input/output specifico della scheda (es. **src/avr/serial.c**, "
"**src/generic/serial_irq.c**) ed esegue le funzioni di comando associate ai "
"comandi trovati nel flusso di input. Le funzioni di comando vengono "
"dichiarate utilizzando la macro DECL_COMMAND() (consultare il documento "
"[protocol](Protocol.md) per ulteriori informazioni)."

msgid ""
"Timer functions are scheduled by calling sched_add_timer() (located in "
"**src/sched.c**). The scheduler code will arrange for the given function to "
"be called at the requested clock time. Timer interrupts are initially "
"handled in an architecture specific interrupt handler (eg, "
"**src/avr/timer.c**) which calls sched_timer_dispatch() located in "
"**src/sched.c**. The timer interrupt leads to execution of schedule timer "
"functions. Timer functions always run with interrupts disabled. The timer "
"functions should always complete within a few micro-seconds. At completion "
"of the timer event, the function may choose to reschedule itself."
msgstr ""
"Le funzioni timer vengono pianificate chiamando sched_add_timer() (che si "
"trova in **src/sched.c**). Il codice di pianificazione farà in modo che la "
"funzione data venga chiamata all'ora richiesta. Gli interrupt timer sono "
"inizialmente gestiti in un gestore di interrupt specifico dell'architettura "
"(ad esempio, **src/avr/timer.c**) che chiama sched_timer_dispatch() situato "
"in **src/sched.c**. L'interruzione del timer porta all'esecuzione delle "
"funzioni del timer di pianificazione. Le funzioni timer vengono eseguite "
"sempre con gli interrupt disabilitati. Le funzioni del timer dovrebbero "
"sempre completarsi entro pochi microsecondi. Al completamento dell'evento "
"timer, la funzione può scegliere di riprogrammare se stessa."

msgid ""
"In the event an error is detected the code can invoke shutdown() (a macro "
"which calls sched_shutdown() located in **src/sched.c**). Invoking "
"shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
"run. Shutdown functions always run with interrupts disabled."
msgstr ""
"Nel caso in cui venga rilevato un errore, il codice può invocare shutdown() "
"(una macro che chiama sched_shutdown() situata in **src/sched.c**). Il "
"richiamo di shutdown() provoca l'esecuzione di tutte le funzioni "
"contrassegnate con la macro DECL_SHUTDOWN(). Le funzioni di spegnimento "
"vengono eseguite sempre con gli interrupt disabilitati."

msgid ""
"Much of the functionality of the micro-controller involves working with "
"General-Purpose Input/Output pins (GPIO). In order to abstract the low-level"
" architecture specific code from the high-level task code, all GPIO events "
"are implemented in architecture specific wrappers (eg, **src/avr/gpio.c**). "
"The code is compiled with gcc's \"-flto -fwhole-program\" optimization which"
" does an excellent job of inlining functions across compilation units, so "
"most of these tiny gpio functions are inlined into their callers, and there "
"is no run-time cost to using them."
msgstr ""
"Gran parte delle funzionalità del microcontrollore implica il lavoro con pin"
" di input/output per uso generico (GPIO). Per astrarre il codice specifico "
"dell'architettura di basso livello dal codice dell'attività di alto livello,"
" tutti gli eventi GPIO sono implementati in wrapper specifici "
"dell'architettura (ad esempio, **src/avr/gpio.c**). Il codice è compilato "
"con l'ottimizzazione \"-flto -fwhole-program\" di gcc che fa un ottimo "
"lavoro di inlining delle funzioni tra le unità di compilazione, quindi la "
"maggior parte di queste minuscole funzioni gpio sono integrate nei loro "
"chiamanti e non ci sono costi di runtime per l'utilizzo loro."

msgid "Klippy code overview"
msgstr "Panoramica del codice Klippy"

msgid ""
"The host code (Klippy) is intended to run on a low-cost computer (such as a "
"Raspberry Pi) paired with the micro-controller. The code is primarily "
"written in Python, however it does use CFFI to implement some functionality "
"in C code."
msgstr ""
"Il codice host (Klippy) deve essere eseguito su un computer a basso costo "
"(come un Raspberry Pi) abbinato al microcontrollore. Il codice è scritto "
"principalmente in Python, tuttavia utilizza CFFI per implementare alcune "
"funzionalità nel codice C."

msgid ""
"Initial execution starts in **klippy/klippy.py**. This reads the command-"
"line arguments, opens the printer config file, instantiates the main printer"
" objects, and starts the serial connection. The main execution of G-code "
"commands is in the process_commands() method in **klippy/gcode.py**. This "
"code translates the G-code commands into printer object calls, which "
"frequently translate the actions to commands to be executed on the micro-"
"controller (as declared via the DECL_COMMAND macro in the micro-controller "
"code)."
msgstr ""
"L'esecuzione iniziale comincia in **klippy/klippy.py**. Questo legge gli "
"argomenti della riga di comando, apre il file di configurazione della "
"stampante, crea un'istanza degli oggetti principali della stampante e avvia "
"la connessione seriale. L'esecuzione principale dei comandi G-code è nel "
"metodo process_commands() in **klippy/gcode.py**. Questo codice traduce i "
"comandi del codice G in chiamate a oggetti stampante, che spesso traducono "
"le azioni in comandi da eseguire sul microcontrollore (come dichiarato "
"tramite la macro DECL_COMMAND nel codice del microcontrollore)."

msgid ""
"There are four threads in the Klippy host code. The main thread handles "
"incoming gcode commands. A second thread (which resides entirely in the "
"**klippy/chelper/serialqueue.c** C code) handles low-level IO with the "
"serial port. The third thread is used to process response messages from the "
"micro-controller in the Python code (see **klippy/serialhdl.py**). The "
"fourth thread writes debug messages to the log (see "
"**klippy/queuelogger.py**) so that the other threads never block on log "
"writes."
msgstr ""
"Ci sono quattro thread nel codice host di Klippy. Il thread principale "
"gestisce i comandi gcode in arrivo. Un secondo thread (che risiede "
"interamente nel codice C **klippy/chelper/serialqueue.c**) gestisce l'IO di "
"basso livello con la porta seriale. Il terzo thread viene utilizzato per "
"elaborare i messaggi di risposta dal microcontrollore nel codice Python "
"(vedi **klippy/serialhdl.py**). Il quarto thread scrive i messaggi di debug "
"nel log (vedi **klippy/queuelogger.py**) in modo che gli altri thread non "
"blocchino mai le scritture del log."

msgid "Code flow of a move command"
msgstr "Flusso di codice di un comando di spostamento"

msgid ""
"A typical printer movement starts when a \"G1\" command is sent to the "
"Klippy host and it completes when the corresponding step pulses are produced"
" on the micro-controller. This section outlines the code flow of a typical "
"move command. The [kinematics](Kinematics.md) document provides further "
"information on the mechanics of moves."
msgstr ""
"Un tipico movimento della stampante inizia quando viene inviato un comando "
"\"G1\" all'host Klippy e si completa quando vengono prodotti i "
"corrispondenti impulsi di passo sul microcontrollore. Questa sezione delinea"
" il flusso di codice di un tipico comando di spostamento. Il documento "
"[cinematica](Kinematics.md) fornisce ulteriori informazioni sulla meccanica "
"dei movimenti."

msgid ""
"Processing for a move command starts in gcode.py. The goal of gcode.py is to"
" translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
"klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
"origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
"unit changes (eg, F6000=100mm/s). The code path for a move is: "
"`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
"ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
"ToolHead.move()`"
msgstr ""
"L'elaborazione di un comando di spostamento inizia in gcode.py. L'obiettivo "
"di gcode.py è tradurre il G-code in chiamate interne. Un comando G1 "
"invocherà cmd_G1() in klippy/extras/gcode_move.py. Il codice gcode_move.py "
"gestisce le modifiche all'origine (ad esempio, G92), le modifiche alle "
"posizioni relative rispetto a quelle assolute (ad esempio, G90) e le "
"modifiche alle unità (ad esempio, F6000=100mm/s). Il percorso del codice per"
" una mossa è: `_process_data() -> _process_commands() -> cmd_G1()`. Infine "
"viene invocata la classe ToolHead per eseguire la richiesta effettiva: "
"`cmd_G1() -> ToolHead.move()`"

msgid ""
"The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the "
"timing of printing actions. The main codepath for a move is: "
"`ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> "
"Move.set_junction() -> ToolHead._process_moves()`."
msgstr ""
"La classe ToolHead (in toolhead.py) gestisce \"look-ahead\" e tiene traccia "
"dei tempi delle azioni di stampa. Il percorso di codice principale per una "
"mossa è: `ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> "
"Move.set_junction() -> ToolHead._process_moves()`."

msgid ""
"ToolHead.move() creates a Move() object with the parameters of the move (in "
"cartesian space and in units of seconds and millimeters)."
msgstr ""
"ToolHead.move() crea un oggetto Move() con i parametri del movimento (in "
"spazio cartesiano e in unità di secondi e millimetri)."

msgid ""
"The kinematics class is given the opportunity to audit each move "
"(`ToolHead.move() -> kin.check_move()`). The kinematics classes are located "
"in the klippy/kinematics/ directory. The check_move() code may raise an "
"error if the move is not valid. If check_move() completes successfully then "
"the underlying kinematics must be able to handle the move."
msgstr ""
"Alla classe cinematica viene data l'opportunità di controllare ogni "
"movimento (`ToolHead.move() -> kin.check_move()`). Le classi cinematiche si "
"trovano nella directory klippy/cinematica/. Il codice check_move() può "
"generare un errore se il movimento non è valida. Se check_move() viene "
"completato correttamente, la cinematica sottostante deve essere in grado di "
"gestire lo spostamento."

msgid "MoveQueue.add_move() places the move object on the \"look-ahead\" queue."
msgstr ""
"MoveQueue.add_move() posiziona l'oggetto di spostamento nella coda \"look-"
"ahead\"."

msgid ""
"MoveQueue.flush() determines the start and end velocities of each move."
msgstr ""
"MoveQueue.flush() determina le velocità di inizio e fine di ogni movimento."

msgid ""
"Move.set_junction() implements the \"trapezoid generator\" on a move. The "
"\"trapezoid generator\" breaks every move into three parts: a constant "
"acceleration phase, followed by a constant velocity phase, followed by a "
"constant deceleration phase. Every move contains these three phases in this "
"order, but some phases may be of zero duration."
msgstr ""
"Move.set_junction() implementa il \"generatore di trapezi\" per il "
"movimento. Il \"generatore trapezoidale\" suddivide ogni movimento in tre "
"parti: una fase di accelerazione costante, seguita da una fase di velocità "
"costante, seguita da una fase di decelerazione costante. Ogni mossa contiene"
" queste tre fasi in questo ordine, ma alcune fasi possono avere durata zero."

msgid ""
"When ToolHead._process_moves() is called, everything about the move is known"
" - its start location, its end location, its acceleration, its "
"start/cruising/end velocity, and distance traveled during "
"acceleration/cruising/deceleration. All the information is stored in the "
"Move() class and is in cartesian space in units of millimeters and seconds."
msgstr ""
"Quando viene chiamato ToolHead._process_moves(), tutto ciò che riguarda lo "
"spostamento è noto: la sua posizione iniziale, la sua posizione finale, la "
"sua accelerazione, la sua velocità di inizio/crociera/finale e la distanza "
"percorsa durante l'accelerazione/crociera/decelerazione. Tutte le "
"informazioni sono memorizzate nella classe Move() e sono nello spazio "
"cartesiano in unità di millimetri e secondi."

msgid ""
"Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm) to generate the step times for each stepper. For "
"efficiency reasons, the stepper pulse times are generated in C code. The "
"moves are first placed on a \"trapezoid motion queue\": "
"`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
"The step times are then generated: `ToolHead._process_moves() -> "
"ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
"itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
"klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
"step times given a function that calculates a stepper position from a time. "
"This is done by repeatedly \"guessing\" various times until the stepper "
"position formula returns the desired position of the next step on the "
"stepper. The feedback produced from each guess is used to improve future "
"guesses so that the process rapidly converges to the desired time. The "
"kinematic stepper position formulas are located in the klippy/chelper/ "
"directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
msgstr ""
"Klipper utilizza un [risolutore "
"iterativo](https://en.wikipedia.org/wiki/Root-finding_algorithm) per "
"generare i tempi di passaggio per ogni stepper. Per motivi di efficienza, i "
"tempi di impulso stepper sono generati in codice C. I movimenti vengono "
"prima posizionati su una \"coda di movimento trapezoidale\": "
"`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
"Vengono quindi generati i tempi di passaggio: `ToolHead._process_moves() -> "
"ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
"itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
"klippy/chelper/itersolve.c). L'obiettivo del risolutore iterativo è trovare "
"i tempi di passaggio data una funzione che calcola una posizione passo-passo"
" da un tempo. Questo viene fatto \"indovinando\" ripetutamente varie volte "
"fino a quando la formula della posizione dello stepper non restituisce la "
"posizione desiderata del passaggio successivo sullo stepper. Il feedback "
"prodotto da ciascuna ipotesi viene utilizzato per migliorare le ipotesi "
"future in modo che il processo converga rapidamente al tempo desiderato. Le "
"formule della posizione dello stepper cinematico si trovano nella directory "
"klippy/chelper/ (ad es. kin_cart.c, kin_corexy.c, kin_delta.c, "
"kin_extruder.c)."

msgid ""
"Note that the extruder is handled in its own kinematic class: "
"`ToolHead._process_moves() -> PrinterExtruder.move()`. Since the Move() "
"class specifies the exact movement time and since step pulses are sent to "
"the micro-controller with specific timing, stepper movements produced by the"
" extruder class will be in sync with head movement even though the code is "
"kept separate."
msgstr ""
"Si noti che l'estrusore è gestito nella propria classe cinematica: "
"`ToolHead._process_moves() -> PrinterExtruder.move()`. Poiché la classe "
"Move() specifica l'esatto tempo di movimento e poiché gli impulsi di passo "
"vengono inviati al microcontrollore con una tempistica specifica, i "
"movimenti passo-passo prodotti dalla classe estrusore saranno sincronizzati "
"con il movimento della testa anche se il codice viene mantenuto separato."

msgid ""
"After the iterative solver calculates the step times they are added to an "
"array: `itersolve_gen_steps_range() -> stepcompress_append()` (in "
"klippy/chelper/stepcompress.c). The array (struct stepcompress.queue) stores"
" the corresponding micro-controller clock counter times for every step. Here"
" the \"micro-controller clock counter\" value directly corresponds to the "
"micro-controller's hardware counter - it is relative to when the micro-"
"controller was last powered up."
msgstr ""
"Dopo che il risolutore iterativo ha calcolato i tempi di passaggio, questi "
"vengono aggiunti a un array: `itersolve_gen_steps_range() -> "
"stepcompress_append()` (in klippy/chelper/stepcompress.c). L'array (struct "
"stepcompress.queue) memorizza i corrispondenti tempi del contatore "
"dell'orologio del microcontrollore per ogni passaggio. Qui il valore del "
"\"contatore orologio del microcontrollore\" corrisponde direttamente al "
"contatore hardware del microcontrollore - è relativo a quando il "
"microcontrollore è stato acceso l'ultima volta."

msgid ""
"The next major step is to compress the steps: `stepcompress_flush() -> "
"compress_bisect_add()` (in klippy/chelper/stepcompress.c). This code "
"generates and encodes a series of micro-controller \"queue_step\" commands "
"that correspond to the list of stepper step times built in the previous "
"stage. These \"queue_step\" commands are then queued, prioritized, and sent "
"to the micro-controller (via stepcompress.c:steppersync and "
"serialqueue.c:serialqueue)."
msgstr ""
"Il prossimo passo importante è comprimere i passaggi: `stepcompress_flush() "
"-> compress_bisect_add()` (in klippy/chelper/stepcompress.c). Questo codice "
"genera e codifica una serie di comandi \"queue_step\" del microcontrollore "
"che corrispondono all'elenco dei tempi di stepper compilati nella fase "
"precedente. Questi comandi \"queue_step\" vengono quindi accodati, assegnati"
" a priorità e inviati al microcontrollore (tramite "
"stepcompress.c:steppersync e serialqueue.c:serialqueue)."

msgid ""
"Processing of the queue_step commands on the micro-controller starts in "
"src/command.c which parses the command and calls `command_queue_step()`. The"
" command_queue_step() code (in src/stepper.c) just appends the parameters of"
" each queue_step command to a per stepper queue. Under normal operation the "
"queue_step command is parsed and queued at least 100ms before the time of "
"its first step. Finally, the generation of stepper events is done in "
"`stepper_event()`. It's called from the hardware timer interrupt at the "
"scheduled time of the first step. The stepper_event() code generates a step "
"pulse and then reschedules itself to run at the time of the next step pulse "
"for the given queue_step parameters. The parameters for each queue_step "
"command are \"interval\", \"count\", and \"add\". At a high-level, "
"stepper_event() runs the following, 'count' times: `do_step(); "
"next_wake_time = last_wake_time + interval; interval += add;`"
msgstr ""
"L'elaborazione dei comandi queue_step sul microcontrollore inizia in "
"src/command.c che analizza il comando e chiama `command_queue_step()`. Il "
"codice command_queue_step() (in src/stepper.c) aggiunge semplicemente i "
"parametri di ogni comando queue_step a una coda per stepper. In condizioni "
"normali, il comando queue_step viene analizzato e messo in coda almeno 100 "
"ms prima dell'ora del suo primo passaggio. Infine, la generazione degli "
"eventi stepper viene eseguita in `stepper_event()`. Viene chiamato "
"dall'interruzione del timer hardware all'ora pianificata del primo "
"passaggio. Il codice stepper_event() genera un impulso di passaggio e quindi"
" si riprogramma per essere eseguito al momento dell'impulso di passaggio "
"successivo per i parametri queue_step specificati. I parametri per ogni "
"comando queue_step sono \"interval\", \"count\" e \"add\". Ad alto livello, "
"stepper_event() esegue quanto segue, 'count' volte: `do_step(); "
"next_wake_time = last_wake_time + intervallo; intervallo += aggiungi;`"

msgid ""
"The above may seem like a lot of complexity to execute a movement. However, "
"the only really interesting parts are in the ToolHead and kinematic classes."
" It's this part of the code which specifies the movements and their timings."
" The remaining parts of the processing is mostly just communication and "
"plumbing."
msgstr ""
"Quanto sopra può sembrare un sacco di complessità per eseguire un movimento."
" Tuttavia, le uniche parti veramente interessanti sono nelle classi ToolHead"
" e cinematica. È questa parte del codice che specifica i movimenti e le loro"
" tempistiche. Le restanti parti dell'elaborazione sono per lo più solo "
"comunicazioni e collegamenti."

msgid "Adding a host module"
msgstr "Aggiunta di un modulo host"

msgid ""
"The Klippy host code has a dynamic module loading capability. If a config "
"section named \"[my_module]\" is found in the printer config file then the "
"software will automatically attempt to load the python module "
"klippy/extras/my_module.py . This module system is the preferred method for "
"adding new functionality to Klipper."
msgstr ""
"Il codice host Klippy ha una capacità di caricamento dinamico dei moduli. Se"
" nel file di configurazione della stampante viene trovata una sezione di "
"configurazione denominata \"[my_module]\", il software tenterà "
"automaticamente di caricare il modulo python klippy/extras/my_module.py . "
"Questo sistema di moduli è il metodo preferito per aggiungere nuove "
"funzionalità a Klipper."

msgid ""
"The easiest way to add a new module is to use an existing module as a "
"reference - see **klippy/extras/servo.py** as an example."
msgstr ""
"Il modo più semplice per aggiungere un nuovo modulo è utilizzare un modulo "
"esistente come riferimento - vedere **klippy/extras/servo.py** come esempio."

msgid "The following may also be useful:"
msgstr "Possono essere utili anche:"

msgid ""
"Execution of the module starts in the module level `load_config()` function "
"(for config sections of the form [my_module]) or in `load_config_prefix()` "
"(for config sections of the form [my_module my_name]). This function is "
"passed a \"config\" object and it must return a new \"printer object\" "
"associated with the given config section."
msgstr ""
"L'esecuzione del modulo inizia nella funzione `load_config()` a livello di "
"modulo (per le sezioni di configurazione del modulo [my_module]) o in "
"`load_config_prefix()` (per le sezioni di configurazione del modulo "
"[my_module my_name]). A questa funzione viene passato un oggetto \"config\" "
"e deve restituire un nuovo \"oggetto stampante\" associato alla sezione di "
"configurazione specificata."

msgid ""
"During the process of instantiating a new printer object, the config object "
"can be used to read parameters from the given config section. This is done "
"using `config.get()`, `config.getfloat()`, `config.getint()`, etc. methods. "
"Be sure to read all values from the config during the construction of the "
"printer object - if the user specifies a config parameter that is not read "
"during this phase then it will be assumed it is a typo in the config and an "
"error will be raised."
msgstr ""
"Durante il processo di creazione di un'istanza di un nuovo oggetto "
"stampante, l'oggetto di configurazione può essere utilizzato per leggere i "
"parametri dalla sezione di configurazione specificata. Questo viene fatto "
"usando i metodi `config.get()`, `config.getfloat()`, `config.getint()`, ecc."
" Assicurati di leggere tutti i valori dalla configurazione durante la "
"costruzione dell'oggetto stampante: se l'utente specifica un parametro di "
"configurazione che non viene letto durante questa fase, si presumerà che si "
"tratti di un errore di battitura nella configurazione e verrà generato un "
"errore."

msgid ""
"Use the `config.get_printer()` method to obtain a reference to the main "
"\"printer\" class. This \"printer\" class stores references to all the "
"\"printer objects\" that have been instantiated. Use the "
"`printer.lookup_object()` method to find references to other printer "
"objects. Almost all functionality (even core kinematic modules) are "
"encapsulated in one of these printer objects. Note, though, that when a new "
"module is instantiated, not all other printer objects will have been "
"instantiated. The \"gcode\" and \"pins\" modules will always be available, "
"but for other modules it is a good idea to defer the lookup."
msgstr ""
"Usa il metodo `config.get_printer()` per ottenere un riferimento alla classe"
" principale \"printer\". Questa classe \"stampante\" memorizza i riferimenti"
" a tutti gli \"oggetti stampante\" di cui è stata creata un'istanza. Usa il "
"metodo `printer.lookup_object()` per trovare riferimenti ad altri oggetti "
"stampante. Quasi tutte le funzionalità (anche i moduli cinematici "
"principali) sono incapsulate in uno di questi oggetti stampante. Si noti, "
"tuttavia, che quando viene istanziato un nuovo modulo, non saranno stati "
"istanziati tutti gli altri oggetti stampante. I moduli \"gcode\" e \"pins\" "
"saranno sempre disponibili, ma per altri moduli è una buona idea rinviare la"
" ricerca."

msgid ""
"Register event handlers using the `printer.register_event_handler()` method "
"if the code needs to be called during \"events\" raised by other printer "
"objects. Each event name is a string, and by convention it is the name of "
"the main source module that raises the event along with a short name for the"
" action that is occurring (eg, \"klippy:connect\"). The parameters passed to"
" each event handler are specific to the given event (as are exception "
"handling and execution context). Two common startup events are:"
msgstr ""
"Registra i gestori di eventi usando il metodo "
"`printer.register_event_handler()` se il codice deve essere chiamato durante"
" gli \"events\" generati da altri oggetti stampante. Ogni nome di evento è "
"una stringa e, per convenzione, è il nome del modulo sorgente principale che"
" genera l'evento insieme a un nome breve per l'azione che si sta verificando"
" (ad esempio, \"klippy:connect\"). I parametri passati a ciascun gestore di "
"eventi sono specifici dell'evento dato (così come la gestione delle "
"eccezioni e il contesto di esecuzione). Due eventi di avvio comuni sono:"

msgid ""
"klippy:connect - This event is generated after all printer objects are "
"instantiated. It is commonly used to lookup other printer objects, to verify"
" config settings, and to perform an initial \"handshake\" with printer "
"hardware."
msgstr ""
"klippy:connect - Questo evento viene generato dopo che tutti gli oggetti "
"stampante sono stati istanziati. Viene comunemente utilizzato per cercare "
"altri oggetti stampante, verificare le impostazioni di configurazione ed "
"eseguire un \"handshake\" iniziale con l'hardware della stampante."

msgid ""
"klippy:ready - This event is generated after all connect handlers have "
"completed successfully. It indicates the printer is transitioning to a state"
" ready to handle normal operations. Do not raise an error in this callback."
msgstr ""
"klippy:ready - Questo evento viene generato dopo che tutti i gestori di "
"connessione sono stati completati correttamente. Indica che la stampante sta"
" passando a uno stato pronto per gestire le normali operazioni. Non generare"
" un errore in questo callback."

msgid ""
"If there is an error in the user's config, be sure to raise it during the "
"`load_config()` or \"connect event\" phases. Use either `raise "
"config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
" report the error."
msgstr ""
"Se c'è un errore nella configurazione dell'utente, assicurati di sollevarlo "
"durante le fasi `load_config()` o \"connect event\". Utilizzare `raise "
"config.error(\"my error\")` o `raise printer.config_error (\"my error\")` "
"per segnalare l'errore."

msgid ""
"Use the \"pins\" module to configure a pin on a micro-controller. This is "
"typically done with something similar to "
"`printer.lookup_object(\"pins\").setup_pin(\"pwm\", "
"config.get(\"my_pin\"))`. The returned object can then be commanded at run-"
"time."
msgstr ""
"Utilizzare il modulo \"pin\" per configurare un pin su un microcontrollore. "
"Questo è in genere fatto con qualcosa di simile a "
"`printer.lookup_object(\"pins\").setup_pin(\"pwm\", "
"config.get(\"my_pin\"))`. L'oggetto restituito può quindi essere comandato "
"in fase di esecuzione."

msgid ""
"If the module needs access to system timing or external file descriptors "
"then use `printer.get_reactor()` to obtain access to the global \"event "
"reactor\" class. This reactor class allows one to schedule timers, wait for "
"input on file descriptors, and to \"sleep\" the host code."
msgstr ""
"Se il modulo necessita dell'accesso alla temporizzazione del sistema o a "
"descrittori di file esterni, utilizzare `printer.get_reactor()` per ottenere"
" l'accesso alla classe globale \"event reactor\". Questa classe reattore "
"consente di programmare i timer, attendere l'input sui descrittori di file e"
" di \"sopprimere\" il codice host."

msgid ""
"Do not use global variables. All state should be stored in the printer "
"object returned from the `load_config()` function. This is important as "
"otherwise the RESTART command may not perform as expected. Also, for similar"
" reasons, if any external files (or sockets) are opened then be sure to "
"register a \"klippy:disconnect\" event handler and close them from that "
"callback."
msgstr ""
"Non utilizzare variabili globali. Tutto lo stato dovrebbe essere memorizzato"
" nell'oggetto stampante restituito dalla funzione `load_config()`. Questo è "
"importante, altrimenti il comando RESTART potrebbe non funzionare come "
"previsto. Inoltre, per ragioni simili, se vengono aperti file (o socket) "
"esterni, assicurati di registrare un gestore di eventi \"klippy:disconnect\""
" e chiuderli da quella richiamata."

msgid ""
"Avoid accessing the internal member variables (or calling methods that start"
" with an underscore) of other printer objects. Observing this convention "
"makes it easier to manage future changes."
msgstr ""
"Evitare di accedere alle variabili dei membri interni (o di chiamare metodi "
"che iniziano con un trattino basso) di altri oggetti stampante. L'osservanza"
" di questa convenzione semplifica la gestione delle modifiche future."

msgid ""
"If submitting the module for inclusion in the main Klipper code, be sure to "
"place a copyright notice at the top of the module. See the existing modules "
"for the preferred format."
msgstr ""
"Se invii il modulo per l'inclusione nel codice Klipper principale, "
"assicurati di inserire un avviso di copyright nella parte superiore del "
"modulo. Vedere i moduli esistenti per il formato preferito."

msgid "Adding new kinematics"
msgstr "Aggiunta di una nuova cinematica"

msgid ""
"This section provides some tips on adding support to Klipper for additional "
"types of printer kinematics. This type of activity requires excellent "
"understanding of the math formulas for the target kinematics. It also "
"requires software development skills - though one should only need to update"
" the host software."
msgstr ""
"Questa sezione fornisce alcuni suggerimenti sull'aggiunta del supporto a "
"Klipper per ulteriori tipi di cinematica della stampante. Questo tipo di "
"attività richiede un'ottima comprensione delle formule matematiche per la "
"cinematica di destinazione. Richiede anche capacità di sviluppo software, "
"sebbene sia necessario solo aggiornare il software host."

msgid "Useful steps:"
msgstr "Passi utili:"

msgid ""
"Start by studying the \"[code flow of a move](#code-flow-of-a-move-"
"command)\" section and the [Kinematics document](Kinematics.md)."
msgstr ""
"Inizia studiando la sezione \"[flusso di codice di un movimento](#code-flow-"
"of-a-move-command)\" e il [documento di cinematica](Kinematics.md)."

msgid ""
"Review the existing kinematic classes in the klippy/kinematics/ directory. "
"The kinematic classes are tasked with converting a move in cartesian "
"coordinates to the movement on each stepper. One should be able to copy one "
"of these files as a starting point."
msgstr ""
"Esaminare le classi cinematiche esistenti nella directory "
"klippy/kinematics/. Le classi cinematiche hanno il compito di convertire una"
" mossa in coordinate cartesiane nel movimento su ogni stepper. Si dovrebbe "
"essere in grado di copiare uno di questi file come punto di partenza."

msgid ""
"Implement the C stepper kinematic position functions for each stepper if "
"they are not already available (see kin_cart.c, kin_corexy.c, and "
"kin_delta.c in klippy/chelper/). The function should call `move_get_coord()`"
" to convert a given move time (in seconds) to a cartesian coordinate (in "
"millimeters), and then calculate the desired stepper position (in "
"millimeters) from that cartesian coordinate."
msgstr ""
"Implementa in C le funzioni di posizione cinematica dello stepper per ogni "
"stepper se non sono già disponibili (vedi kin_cart.c, kin_corexy.c e "
"kin_delta.c in klippy/chelper/). La funzione dovrebbe chiamare "
"`move_get_coord()` per convertire un dato tempo di spostamento (in secondi) "
"in una coordinata cartesiana (in millimetri), e quindi calcolare la "
"posizione dello stepper desiderata (in millimetri) da quella coordinata "
"cartesiana."

msgid ""
"Implement the `calc_position()` method in the new kinematics class. This "
"method calculates the position of the toolhead in cartesian coordinates from"
" the position of each stepper. It does not need to be efficient as it is "
"typically only called during homing and probing operations."
msgstr ""
"Implementa il metodo `calc_position()` nella nuova classe cinematica. Questo"
" metodo calcola la posizione della testa di stampa in coordinate cartesiane "
"dalla posizione di ogni stepper. Non è necessario che sia efficiente poiché "
"in genere viene chiamato solo durante le operazioni di homing e probing."

msgid ""
"Other methods. Implement the `check_move()`, `get_status()`, "
"`get_steppers()`, `home()`, and `set_position()` methods. These functions "
"are typically used to provide kinematic specific checks. However, at the "
"start of development one can use boiler-plate code here."
msgstr ""
"Altri metodi. Implementa i metodi `check_move()`, `get_status()`, "
"`get_steppers()`, `home()` e `set_position()`. Queste funzioni sono in "
"genere utilizzate per fornire verifiche cinematiche specifiche. Tuttavia, "
"all'inizio dello sviluppo è possibile utilizzare il codice boilerplate qui."

msgid ""
"Implement test cases. Create a g-code file with a series of moves that can "
"test important cases for the given kinematics. Follow the [debugging "
"documentation](Debugging.md) to convert this g-code file to micro-controller"
" commands. This is useful to exercise corner cases and to check for "
"regressions."
msgstr ""
"Implementare casi di prova. Crea un file g-code con una serie di movimenti "
"che possono testare casi importanti per la cinematica data. Segui la "
"[documentazione di debug](Debugging.md) per convertire questo file di codice"
" G in comandi del microcontrollore. Questo è utile per esercitare corner "
"case e per verificare la presenza di regressioni."

msgid "Porting to a new micro-controller"
msgstr "Porting su un nuovo microcontrollore"

msgid ""
"This section provides some tips on porting Klipper's micro-controller code "
"to a new architecture. This type of activity requires good knowledge of "
"embedded development and hands-on access to the target micro-controller."
msgstr ""
"Questa sezione fornisce alcuni suggerimenti sul porting del codice del "
"microcontrollore di Klipper su una nuova architettura. Questo tipo di "
"attività richiede una buona conoscenza dello sviluppo embedded e un accesso "
"diretto al microcontrollore di destinazione."

msgid ""
"Start by identifying any 3rd party libraries that will be used during the "
"port. Common examples include \"CMSIS\" wrappers and manufacturer \"HAL\" "
"libraries. All 3rd party code needs to be GNU GPLv3 compatible. The 3rd "
"party code should be committed to the Klipper lib/ directory. Update the "
"lib/README file with information on where and when the library was obtained."
" It is preferable to copy the code into the Klipper repository unchanged, "
"but if any changes are required then those changes should be listed "
"explicitly in the lib/README file."
msgstr ""
"Inizia identificando eventuali librerie di terze parti che verranno "
"utilizzate durante il trasferimento. Esempi comuni includono wrapper "
"\"CMSIS\" e librerie \"HAL\" del produttore. Tutto il codice di terze parti "
"deve essere compatibile con GNU GPLv3. Il codice di terze parti dovrebbe "
"essere salvato nella directory lib/ di Klipper. Aggiorna il file lib/README "
"con informazioni su dove e quando è stata ottenuta la libreria. È "
"preferibile copiare il codice nel repository di Klipper senza modifiche, ma "
"se sono necessarie modifiche, tali modifiche dovrebbero essere elencate "
"esplicitamente nel file lib/README."

msgid ""
"Create a new architecture sub-directory in the src/ directory and add "
"initial Kconfig and Makefile support. Use the existing architectures as a "
"guide. The src/simulator provides a basic example of a minimum starting "
"point."
msgstr ""
"Crea una nuova sottodirectory di architettura nella directory src/ e "
"aggiungi il supporto iniziale di Kconfig e Makefile. Utilizzare le "
"architetture esistenti come guida. src/simulator fornisce un esempio di base"
" di un punto di partenza minimo."

msgid ""
"Get familiar with the the console.py tool (as described in the [debugging "
"document](Debugging.md)) and verify connectivity to the micro-controller "
"with it. This tool translates the low-level micro-controller communication "
"protocol to a human readable form."
msgstr ""
"Acquisisci familiarità con lo strumento console.py (come descritto nel "
"[documento di debug](Debugging.md)) e verifica la connettività al "
"microcontrollore con esso. Questo strumento traduce il protocollo di "
"comunicazione del microcontrollore di basso livello in un formato leggibile "
"dall'uomo."

msgid ""
"Create a sample Klipper config file in the config/ directory. Test the "
"micro-controller with the main klippy.py program."
msgstr ""
"Crea un file di configurazione di Klipper di esempio nella directory "
"config/. Testare il microcontrollore con il programma principale klippy.py."

msgid "Consider adding build test cases in the test/ directory."
msgstr ""
"Prendi in considerazione l'aggiunta di build test case nella directory "
"test/."

msgid "Coordinate Systems"
msgstr "Sistemi di coordinate"

msgid ""
"Internally, Klipper primarily tracks the position of the toolhead in "
"cartesian coordinates that are relative to the coordinate system specified "
"in the config file. That is, most of the Klipper code will never experience "
"a change in coordinate systems. If the user makes a request to change the "
"origin (eg, a `G92` command) then that effect is obtained by translating "
"future commands to the primary coordinate system."
msgstr ""
"Internamente, Klipper tiene traccia principalmente della posizione della "
"testa di stampa in coordinate cartesiane relative al sistema di coordinate "
"specificato nel file di configurazione. Cioè, la maggior parte del codice "
"Klipper non subirà mai un cambiamento nei sistemi di coordinate. Se l'utente"
" fa una richiesta per cambiare l'origine (ad esempio, un comando `G92`), "
"allora quell'effetto si ottiene traducendo i comandi futuri nel sistema di "
"coordinate primario."

msgid ""
"However, in some cases it is useful to obtain the toolhead position in some "
"other coordinate system and Klipper has several tools to facilitate that. "
"This can be seen by running the GET_POSITION command. For example:"
msgstr ""
"Tuttavia, in alcuni casi è utile ottenere la posizione della testa di stampa"
" in qualche altro sistema di coordinate e Klipper ha diversi strumenti per "
"facilitarlo. Questo può essere visto eseguendo il comando GET_POSITION. Per "
"esempio:"

msgid ""
"The \"stepper\" position (`stepper.get_commanded_position()`) is the "
"position of the given stepper as tracked by the kinematics code. This "
"generally corresponds to the position (in mm) of the carriage along its "
"rail, relative to the position_endstop specified in the config file. (Some "
"kinematics track stepper positions in radians instead of millimeters.) If "
"the robot is in motion when the query is issued then the reported value "
"includes moves buffered on the micro-controller, but does not include moves "
"on the look-ahead queue. One may use the `toolhead.flush_step_generation()` "
"or `toolhead.wait_moves()` calls to fully flush the look-ahead and step "
"generation code."
msgstr ""
"La posizione \"stepper\" (`stepper.get_commanded_position()`) è la posizione"
" del dato stepper come tracciato dal codice della cinematica. Questo "
"corrisponde generalmente alla posizione (in mm) del carrello lungo il suo "
"binario, rispetto a position_endstop specificato nel file di configurazione."
" (Alcune cinematiche tracciano le posizioni dello stepper in radianti "
"anziché in millimetri.) Se il robot è in movimento quando viene emessa la "
"query, il valore riportato include i movimenti memorizzati nel buffer del "
"microcontrollore, ma non include i movimenti sulla coda di previsione. Si "
"possono usare le chiamate `toolhead.flush_step_generation()` o "
"`toolhead.wait_moves()` per svuotare completamente il codice look-ahead e "
"generazione di passaggi."

msgid ""
"The \"kinematic\" position (`kin.calc_position()`) is the cartesian position"
" of the toolhead as derived from \"stepper\" positions and is relative to "
"the coordinate system specified in the config file. This may differ from the"
" requested cartesian position due to the granularity of the stepper motors. "
"If the robot is in motion when the \"stepper\" positions are taken then the "
"reported value includes moves buffered on the micro-controller, but does not"
" include moves on the look-ahead queue. One may use the "
"`toolhead.flush_step_generation()` or `toolhead.wait_moves()` calls to fully"
" flush the look-ahead and step generation code."
msgstr ""
"La posizione \"cinematica\" (`kin.calc_position()`) è la posizione "
"cartesiana della testa di stampa come derivata dalle posizioni \"stepper\" "
"ed è relativa al sistema di coordinate specificato nel file di "
"configurazione. Questo può differire dalla posizione cartesiana richiesta a "
"causa della granularità dei motori passo-passo. Se il robot è in movimento "
"quando vengono prese le posizioni \"stepper\", il valore riportato include i"
" movimenti memorizzati nel buffer del microcontrollore, ma non include i "
"movimenti sulla coda di previsione. Si possono usare le chiamate "
"`toolhead.flush_step_generation()` o `toolhead.wait_moves()` per svuotare "
"completamente il codice look-ahead e generazione di passaggi."

msgid ""
"The \"toolhead\" position (`toolhead.get_position()`) is the last requested "
"position of the toolhead in cartesian coordinates relative to the coordinate"
" system specified in the config file. If the robot is in motion when the "
"query is issued then the reported value includes all requested moves (even "
"those in buffers waiting to be issued to the stepper motor drivers)."
msgstr ""
"La posizione della \"testa di stampa\" (`toolhead.get_position()`) è "
"l'ultima posizione richiesta della testa di stampa in coordinate cartesiane "
"rispetto al sistema di coordinate specificato nel file di configurazione. Se"
" il robot è in movimento quando viene emessa la richiesta, il valore "
"riportato include tutti i movimenti richiesti (anche quelli nei buffer in "
"attesa di essere inviati ai driver del motore passo-passo)."

msgid ""
"The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
"command in cartesian coordinates relative to the coordinate system specified"
" in the config file. This may differ from the \"toolhead\" position if a "
"g-code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in "
"effect. This may differ from the actual coordinates specified in the last "
"`G1` command if the g-code origin has been changed (eg, `G92`, "
"`SET_GCODE_OFFSET`, `M221`). The `M114` command "
"(`gcode_move.get_status()['gcode_position']`) will report the last g-code "
"position relative to the current g-code coordinate system."
msgstr ""
"La posizione \"gcode\" è l'ultima posizione richiesta da un comando `G1` (o "
"`G0`) in coordinate cartesiane relative al sistema di coordinate specificato"
" nel file di configurazione. Questo può differire dalla posizione "
"\"toolhead\" se è attiva una trasformazione del g-code (ad es. bed_mesh, "
"bed_tilt, skew_correction). Questo può differire dalle coordinate effettive "
"specificate nell'ultimo comando `G1` se l'origine del g-code è stata "
"modificata (ad esempio, `G92`, `SET_GCODE_OFFSET`, `M221`). Il comando "
"`M114` (`gcode_move.get_status()['gcode_position']`) riporterà l'ultima "
"posizione del g-code rispetto al sistema di coordinate del g-code corrente."

msgid ""
"The \"gcode base\" is the location of the g-code origin in cartesian "
"coordinates relative to the coordinate system specified in the config file. "
"Commands such as `G92`, `SET_GCODE_OFFSET`, and `M221` alter this value."
msgstr ""
"La \"gcode base\" è la posizione dell'origine del codice g in coordinate "
"cartesiane rispetto al sistema di coordinate specificato nel file di "
"configurazione. Comandi come `G92`, `SET_GCODE_OFFSET` e `M221` alterano "
"questo valore."

msgid ""
"The \"gcode homing\" is the location to use for the g-code origin (in "
"cartesian coordinates relative to the coordinate system specified in the "
"config file) after a `G28` home command. The `SET_GCODE_OFFSET` command can "
"alter this value."
msgstr ""
"Il \"gcode homing\" è la posizione da usare per l'origine del g-code (in "
"coordinate cartesiane relative al sistema di coordinate specificato nel file"
" di configurazione) dopo un comando home `G28`. Il comando "
"`SET_GCODE_OFFSET` può alterare questo valore."

msgid "Time"
msgstr "Time"

msgid ""
"Fundamental to the operation of Klipper is the handling of clocks, times, "
"and timestamps. Klipper executes actions on the printer by scheduling events"
" to occur in the near future. For example, to turn on a fan, the code might "
"schedule a change to a GPIO pin in a 100ms. It is rare for the code to "
"attempt to take an instantaneous action. Thus, the handling of time within "
"Klipper is critical to correct operation."
msgstr ""
"Fondamentale per il funzionamento di Klipper è la gestione di orologi, orari"
" e timestamp. Klipper esegue azioni sulla stampante programmando eventi che "
"si verificheranno nel prossimo futuro. Ad esempio, per accendere una "
"ventola, il codice potrebbe programmare una modifica a un pin GPIO in 100 "
"ms. È raro che il codice tenti di eseguire un'azione istantanea. Pertanto, "
"la gestione del tempo all'interno di Klipper è fondamentale per il corretto "
"funzionamento."

msgid ""
"There are three types of times tracked internally in the Klipper host "
"software:"
msgstr ""
"Esistono tre tipi di tempi tracciati internamente nel software host di "
"Klipper:"

msgid ""
"System time. The system time uses the system's monotonic clock - it is a "
"floating point number stored as seconds and it is (generally) relative to "
"when the host computer was last started. System times have limited use in "
"the software - they are primarily used when interacting with the operating "
"system. Within the host code, system times are frequently stored in "
"variables named *eventtime* or *curtime*."
msgstr ""
"Ora di sistema. L'ora del sistema utilizza l'orologio del sistema: è un "
"numero in virgola mobile memorizzato come secondi ed è (generalmente) "
"relativo all'ultimo avvio del computer host. I tempi di sistema hanno un uso"
" limitato nel software: vengono utilizzati principalmente durante "
"l'interazione con il sistema operativo. All'interno del codice host, gli "
"orari di sistema sono spesso archiviati in variabili denominate *eventtime* "
"o *curtime*."

msgid ""
"Print time. The print time is synchronized to the main micro-controller "
"clock (the micro-controller defined in the \"[mcu]\" config section). It is "
"a floating point number stored as seconds and is relative to when the main "
"mcu was last restarted. It is possible to convert from a \"print time\" to "
"the main micro-controller's hardware clock by multiplying the print time by "
"the mcu's statically configured frequency rate. The high-level host code "
"uses print times to calculate almost all physical actions (eg, head "
"movement, heater changes, etc.). Within the host code, print times are "
"generally stored in variables named *print_time* or *move_time*."
msgstr ""
"Tempo di stampa. Il tempo di stampa è sincronizzato con l'orologio "
"principale del microcontrollore (il microcontrollore definito nella sezione "
"di configurazione \"[mcu]\"). È un numero in virgola mobile memorizzato come"
" secondi ed è relativo all'ultimo riavvio dell'mcu principale. È possibile "
"convertire da un \"tempo di stampa\" all'orologio hardware del "
"microcontrollore principale moltiplicando il tempo di stampa per la "
"frequenza di frequenza configurata staticamente dell'mcu. Il codice host di "
"alto livello utilizza i tempi di stampa per calcolare quasi tutte le azioni "
"fisiche (ad es. movimento della testa, modifiche del riscaldatore, ecc.). "
"All'interno del codice host, i tempi di stampa sono generalmente memorizzati"
" in variabili denominate *print_time* o *move_time*."

msgid ""
"MCU clock. This is the hardware clock counter on each micro-controller. It "
"is stored as an integer and its update rate is relative to the frequency of "
"the given micro-controller. The host software translates its internal times "
"to clocks before transmission to the mcu. The mcu code only ever tracks time"
" in clock ticks. Within the host code, clock values are tracked as 64bit "
"integers, while the mcu code uses 32bit integers. Within the host code, "
"clocks are generally stored in variables with names containing *clock* or "
"*ticks*."
msgstr ""
"Orologio MCU. Questo è il contatore dell'orologio hardware su ogni "
"microcontrollore. Viene memorizzato come numero intero e la sua velocità di "
"aggiornamento è relativa alla frequenza del microcontrollore specificato. Il"
" software host traduce i suoi tempi interni in orologi prima della "
"trasmissione all'mcu. Il codice mcu tiene traccia del tempo solo in tick "
"dell'orologio. All'interno del codice host, i valori di clock vengono "
"tracciati come interi a 64 bit, mentre il codice mcu utilizza interi a 32 "
"bit. All'interno del codice host, gli orologi sono generalmente memorizzati "
"in variabili con nomi contenenti *clock* o *tick*."

msgid ""
"Conversion between the different time formats is primarily implemented in "
"the **klippy/clocksync.py** code."
msgstr ""
"La conversione tra i diversi formati dell'ora è implementata principalmente "
"nel codice **klippy/clocksync.py**."

msgid "Some things to be aware of when reviewing the code:"
msgstr "Alcune cose da tenere presenti durante la revisione del codice:"

msgid ""
"32bit and 64bit clocks: To reduce bandwidth and to improve micro-controller "
"efficiency, clocks on the micro-controller are tracked as 32bit integers. "
"When comparing two clocks in the mcu code, the `timer_is_before()` function "
"must always be used to ensure integer rollovers are handled properly. The "
"host software converts 32bit clocks to 64bit clocks by appending the high-"
"order bits from the last mcu timestamp it has received - no message from the"
" mcu is ever more than 2^31 clock ticks in the future or past so this "
"conversion is never ambiguous. The host converts from 64bit clocks to 32bit "
"clocks by simply truncating the high-order bits. To ensure there is no "
"ambiguity in this conversion, the **klippy/chelper/serialqueue.c** code will"
" buffer messages until they are within 2^31 clock ticks of their target "
"time."
msgstr ""
"Orologi a 32 bit e 64 bit: per ridurre la larghezza di banda e migliorare "
"l'efficienza del microcontrollore, gli orologi sul microcontrollore vengono "
"tracciati come numeri interi a 32 bit. Quando si confrontano due orologi nel"
" codice mcu, la funzione `timer_is_before()` deve essere sempre utilizzata "
"per garantire che i rollover interi siano gestiti correttamente. Il software"
" host converte gli orologi a 32 bit in orologi a 64 bit aggiungendo i bit di"
" ordine superiore dall'ultimo timestamp mcu che ha ricevuto - nessun "
"messaggio dall'mcu è mai più di 2^31 tick di clock in futuro o nel passato, "
"quindi questa conversione non è mai ambigua . L'host converte da clock a 64 "
"bit a clock a 32 bit semplicemente troncando i bit di ordine superiore. Per "
"garantire che non vi siano ambiguità in questa conversione, il codice "
"**klippy/chelper/serialqueue.c** memorizza i messaggi nel buffer finché non "
"si trovano entro 2^31 tick di clock dall'ora target."

msgid ""
"Multiple micro-controllers: The host software supports using multiple micro-"
"controllers on a single printer. In this case, the \"MCU clock\" of each "
"micro-controller is tracked separately. The clocksync.py code handles clock "
"drift between micro-controllers by modifying the way it converts from "
"\"print time\" to \"MCU clock\". On secondary mcus, the mcu frequency that "
"is used in this conversion is regularly updated to account for measured "
"drift."
msgstr ""
"Microcontrollori multipli: il software host supporta l'utilizzo di più "
"microcontrollori su una singola stampante. In questo caso, il \"clock MCU\" "
"di ogni microcontrollore viene tracciato separatamente. Il codice "
"clocksync.py gestisce la deriva dell'orologio tra i microcontrollori "
"modificando il modo in cui converte da \"tempo di stampa\" a \"orologio "
"MCU\". Sul mcus secondario, la frequenza mcu utilizzata in questa "
"conversione viene regolarmente aggiornata per tenere conto della deriva "
"misurata."

msgid ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"
msgstr ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"

#: docs/Code_Overview.md:block 1 (header)
msgid "Code overview"
msgstr "Panoramica del codice"

#: docs/Code_Overview.md:block 43 (paragraph)
msgid ""
"The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
" number of steps the micro-controller has issued in a positive direction "
"minus the number of steps issued in a negative direction since the micro-"
"controller was last reset. If the robot is in motion when the query is "
"issued then the reported value includes moves buffered on the micro-"
"controller, but does not include moves on the look-ahead queue."
msgstr ""
"La posizione \"mcu\" (`stepper.get_mcu_position()` nel codice) è il numero "
"totale di passaggi che il microcontrollore ha emesso in direzione positiva "
"meno il numero di passaggi emessi in direzione negativa dall'ultimo "
"microcontrollore Ripristina. Se il robot è in movimento quando viene emessa "
"la query, il valore riportato include le mosse memorizzate nel buffer del "
"microcontrollore, ma non include le mosse nella coda di previsione."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Add support for timer dispatch from hardware interrupts. See Klipper [commit"
" "
"970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
" as an example of steps 1-5 done for the LPC176x architecture."
msgstr ""
"Aggiungi il supporto per l'invio del timer da interrupt hardware. Vedere "
"Klipper [commit "
"970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
" come esempio dei passaggi 1-5 eseguiti per l'architettura LPC176x."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up basic GPIO input and output support. See Klipper [commit "
"c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
" as an example of this."
msgstr ""
"Visualizza il supporto di input e output GPIO di base. Vedi Klipper [commit "
"c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
" come esempio di questo."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up additional peripherals - for example see Klipper commit "
"[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
" "
"[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
" and "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
msgstr ""
"Riporta periferiche aggiuntive, ad esempio consulta il commit di Klipper "
"[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
" "
"[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
" e "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If the printer object defines a `get_status()` method then the module can "
"export [status information](Status_Reference.md) via "
"[macros](Command_Templates.md) and via the [API Server](API_Server.md). The "
"`get_status()` method must return a Python dictionary with keys that are "
"strings and values that are integers, floats, strings, lists, dictionaries, "
"True, False, or None. Tuples (and named tuples) may also be used (these "
"appear as lists when accessed via the API Server). Lists and dictionaries "
"that are exported must be treated as \"immutable\" - if their contents "
"change then a new object must be returned from `get_status()`, otherwise the"
" API Server will not detect those changes."
msgstr ""
"Se l'oggetto stampante definisce un metodo `get_status()`, il modulo può "
"esportare [informazioni sullo stato](Status_Reference.md) tramite "
"[macro](Command_Templates.md) e tramite [Server API](API_Server.md). Il "
"metodo `get_status()` deve restituire un dizionario Python con chiavi che "
"sono stringhe e valori che sono interi, float, stringhe, elenchi, dizionari,"
" True, False o None. È possibile utilizzare anche tuple (e tuple con nome) "
"(appaiono come elenchi quando si accede tramite il server API). Gli elenchi "
"e i dizionari esportati devono essere trattati come \"immutabili\" - se il "
"loro contenuto cambia, è necessario restituire un nuovo oggetto da "
"`get_status()`, altrimenti il server API non rileverà tali modifiche."

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"It is recommended to assign a value to all member variables in the Python "
"constructor of Python classes. (And therefore avoid utilizing Python's "
"ability to dynamically create new member variables.)"
msgstr ""
"Si consiglia di assegnare un valore a tutte le variabili membro nel "
"costruttore Python delle classi Python. (E quindi evita di utilizzare la "
"capacità di Python di creare dinamicamente nuove variabili membro.)"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If a Python variable is to store a floating point value then it is "
"recommended to always assign and manipulate that variable with floating "
"point constants (and never use integer constants). For example, prefer "
"`self.speed = 1.` over `self.speed = 1`, and prefer `self.speed = 2. * x` "
"over `self.speed = 2 * x`. Consistent use of floating point values can avoid"
" hard to debug quirks in Python type conversions."
msgstr ""
"Se una variabile Python deve memorizzare un valore in virgola mobile, si "
"consiglia di assegnare e manipolare sempre quella variabile con costanti in "
"virgola mobile (e non utilizzare mai costanti intere). Ad esempio, "
"preferisci `self.speed = 1.` su `self.speed = 1` e preferisci `self.speed = "
"2. * x` su `self.speed = 2 * x`. L'uso coerente di valori in virgola mobile "
"può evitare difficoltà di debug nelle conversioni di tipo Python."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"The first main coding task is to bring up communication support to the "
"target board. This is the most difficult step in a new port. Once basic "
"communication is working, the remaining steps tend to be much easier. It is "
"typical to use a UART type serial device during initial development as these"
" types of hardware devices are generally easier to enable and control. "
"During this phase, make liberal use of helper code from the src/generic/ "
"directory (check how src/simulator/Makefile includes the generic C code into"
" the build). It is also necessary to define timer_read_time() (which returns"
" the current system clock) in this phase, but it is not necessary to fully "
"support timer irq handling."
msgstr ""
"Il primo compito di programmazione è portare il supporto di comunicazione "
"alla scheda di destinazione. Questo è il passo più difficile in un nuovo "
"porting. Una volta che la comunicazione di base funziona, i passaggi "
"rimanenti tendono a essere molto più semplici. È tipico utilizzare un "
"dispositivo seriale di tipo UART durante lo sviluppo iniziale poiché questi "
"tipi di dispositivi hardware sono generalmente più facili da abilitare e "
"controllare. Durante questa fase, fai un uso generoso del codice di supporto"
" dalla directory src/generic/ (controlla come src/simulator/Makefile include"
" il codice C generico nella build). È inoltre necessario definire "
"timer_read_time() (che restituisce l'orologio di sistema corrente) in questa"
" fase, ma non è necessario supportare completamente la gestione di timer "
"irq."

#: docs/Code_Overview.md:block 39 (paragraph)
msgid "Additional coding tips:"
msgstr "Ulteriori suggerimenti per la programmazione:"

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Avoid using \"C bitfields\" to access IO registers; prefer direct read and "
"write operations of 32bit, 16bit, or 8bit integers. The C language "
"specifications don't clearly specify how the compiler must implement C "
"bitfields (eg, endianness, and bit layout), and it's difficult to determine "
"what IO operations will occur on a C bitfield read or write."
msgstr ""
"Evitare di utilizzare \"C bitfields\" per accedere ai registri IO; preferire"
" operazioni di lettura e scrittura dirette di numeri interi a 32 bit, 16 bit"
" o 8 bit. Le specifiche del linguaggio C non specificano chiaramente come il"
" compilatore deve implementare campi di bit C (ad esempio, endianness e "
"layout di bit), ed è difficile determinare quali operazioni di I/O si "
"verificheranno su un campo di bit C letto o scritto."

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Prefer writing explicit values to IO registers instead of using read-modify-"
"write operations. That is, if updating a field in an IO register where the "
"other fields have known values, then it is preferable to explicitly write "
"the full contents of the register. Explicit writes produce code that is "
"smaller, faster, and easier to debug."
msgstr ""
"Preferibilmente scrivere valori espliciti nei registri IO invece di usare "
"operazioni di lettura-modifica-scrittura. Cioè, se si aggiorna un campo in "
"un registro IO in cui gli altri campi hanno valori noti, è preferibile "
"scrivere in modo esplicito il contenuto completo del registro. Le scritture "
"esplicite producono codice più piccolo, più veloce e più facile da eseguire "
"il debug."

#: docs/Code_Overview.md:block 14 (paragraph)
msgid ""
"Task, init, and command functions always run with interrupts enabled "
"(however, they can temporarily disable interrupts if needed). These "
"functions should avoid long pauses, delays, or do work that lasts a "
"significant time. (Long delays in these \"task\" functions result in "
"scheduling jitter for other \"tasks\" - delays over 100us may become "
"noticeable, delays over 500us may result in command retransmissions, delays "
"over 100ms may result in watchdog reboots.) These functions schedule work at"
" specific times by scheduling timers."
msgstr ""
"Le funzioni task, init e comando vengono sempre eseguite con gli interrupt "
"abilitati (tuttavia, possono disabilitare temporaneamente gli interrupt se "
"necessario). Queste funzioni dovrebbero evitare lunghe pause, ritardi o "
"eseguire lavori che durano un tempo significativo. (Lunghi ritardi in queste"
" funzioni di \"attività\" provocano un jitter di pianificazione per altre "
"\"attività\" - ritardi superiori a 100us possono diventare evidenti, ritardi"
" superiori a 500us possono causare ritrasmissioni dei comandi, ritardi "
"superiori a 100 ms possono causare riavvii del watchdog.) Queste funzioni "
"pianificano il lavoro a orari specifici programmando i timer."

#~ msgid ""
#~ "Task, init, and command functions always run with interrupts enabled "
#~ "(however, they can temporarily disable interrupts if needed). These "
#~ "functions should never pause, delay, or do any work that lasts more than a "
#~ "few micro-seconds. These functions schedule work at specific times by "
#~ "scheduling timers."
#~ msgstr ""

#~ msgid ""
#~ "The first main coding task is to bring up communication support to the "
#~ "target board. This is the most difficult step in a new port. Once basic "
#~ "communication is working, the remaining steps tend to be much easier. It is "
#~ "typical to use an RS-232 style serial port during initial development as "
#~ "these types of hardware devices are generally easier to enable and control. "
#~ "During this phase, make liberal use of helper code from the src/generic/ "
#~ "directory (check how src/simulator/Makefile includes the generic C code into"
#~ " the build). It is also necessary to define timer_read_time() (which returns"
#~ " the current system clock) in this phase, but it is not necessary to fully "
#~ "support timer irq handling."
#~ msgstr ""

#~ msgid ""
#~ "Add support for timer dispatch from hardware interrupts. See Klipper [commit"
#~ " "
#~ "970831ee](https://github.com/KevinOConnor/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
#~ " as an example of steps 1-5 done for the LPC176x architecture."
#~ msgstr ""

#~ msgid ""
#~ "Bring up basic GPIO input and output support. See Klipper [commit "
#~ "c78b9076](https://github.com/KevinOConnor/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
#~ " as an example of this."
#~ msgstr ""

#~ msgid ""
#~ "Bring up additional peripherals - for example see Klipper commit "
#~ "[65613aed](https://github.com/KevinOConnor/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
#~ " "
#~ "[c812a40a](https://github.com/KevinOConnor/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
#~ " and "
#~ "[c381d03a](https://github.com/KevinOConnor/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
#~ msgstr ""

#~ msgid ""
#~ "The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
#~ " number of steps the micro-controller has issued in a positive direction "
#~ "minus the number of steps issued in a negative direction since the micro-"
#~ "controller was last reset. The value reported is only valid after the "
#~ "stepper has been homed. If the robot is in motion when the query is issued "
#~ "then the reported value includes moves buffered on the micro-controller, but"
#~ " does not include moves on the look-ahead queue."
#~ msgstr ""
