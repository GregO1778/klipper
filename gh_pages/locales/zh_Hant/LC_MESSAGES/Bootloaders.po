# Fred Chan <fred2088@gmail.com>, 2022.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2022-02-24 08:58+0000\n"
"Last-Translator: Fred Chan <fred2088@gmail.com>\n"
"Language-Team: Chinese (Traditional) <https://hosted.weblate.org/projects/klipper/bootloaders/zh_Hant/>\n"
"Language: zh_Hant\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.11-dev\n"

msgid ""
"This document provides information on common bootloaders found on micro-"
"controllers that Klipper supports."
msgstr "本文件介紹Klipper支援的用於微控制器的底層載入程式（bootloader）。"

msgid ""
"The bootloader is 3rd-party software that runs on the micro-controller when "
"it is first powered on. It is typically used to flash a new application (eg,"
" Klipper) to the micro-controller without requiring specialized hardware. "
"Unfortunately, there is no industry wide standard for flashing a micro-"
"controller, nor is there a standard bootloader that works across all micro-"
"controllers. Worse, it is common for each bootloader to require a different "
"set of steps to flash an application."
msgstr ""
"載入程式是第三方軟體，在微控制器上電后優先執行。該程式可以在不需要特殊硬體（如燒錄器）下對微控制器的程式進行刷寫（如寫入Klipper程式）。然而，目前還沒有一刷寫微控制器的工業標準，也沒有一個適用於所有微控制器的標準載入程式。更麻煩的是，每種引導載入程式需要不同的步驟以觸發刷寫功能。"

msgid ""
"If one can flash a bootloader to a micro-controller then one can generally "
"also use that mechanism to flash an application, but care should be taken "
"when doing this as one may inadvertently remove the bootloader. In contrast,"
" a bootloader will generally only permit a user to flash an application. It "
"is therefore recommended to use a bootloader to flash an application where "
"possible."
msgstr ""
"如果能用某種方式將 bootloader 刷寫到微控制器，使用該方式通常也能完成程式刷寫操作，但是，這種直接刷寫可能會將 bootloader "
"覆蓋掉。相對地，bootloader 只允許使用者刷寫應用程式區域。因此，儘可能使用 bootloader 完成程式的刷寫。"

msgid ""
"This document attempts to describe common bootloaders, the steps needed to "
"flash a bootloader, and the steps needed to flash an application. This "
"document is not an authoritative reference; it is intended as a collection "
"of useful information that the Klipper developers have accumulated."
msgstr ""
"該文件將盡可能介紹常見的bootloaders，刷入bootloader所需的步驟和觸發bootloader進行程式刷寫的流程。該文件亦非官方指引，這只是在Klipper開發人員使用過程中收集到的有用資訊。"

msgid "AVR micro-controllers"
msgstr "AVR 微控制器"

msgid ""
"To flash a bootloader itself, the AVR chips require an external hardware "
"flashing tool (which communicates with the chip using SPI). This tool can be"
" purchased (for example, do a web search for \"avr isp\", \"arduino isp\", "
"or \"usb tiny isp\"). It is also possible to use another Arduino or "
"Raspberry Pi to flash an AVR bootloader (for example, do a web search for "
"\"program an avr using raspberry pi\"). The examples below are written "
"assuming an \"AVR ISP Mk2\" type device is in use."
msgstr ""
"要刷寫載入程式本身，AVR 晶片需要一個外部硬體刷寫工具（它使用 SPI 與晶片進行通訊）。這個工具可以購買（例如，在網上搜索 \"avr "
"isp\"、\"arduino isp \"或 \"usb tiny isp\"）。也可以使用另一個Arduino或Raspberry "
"Pi來快閃記憶體AVR載入程式（例如，在網上搜索 \"用raspberry pi程式設計AVR\"）。下面的例子是在假設使用 \"AVR ISP Mk2"
" \"型別的裝置的情況下編寫的。"

msgid ""
"The \"avrdude\" program is the most common tool used to flash atmega chips "
"(both bootloader flashing and application flashing)."
msgstr "\"avrdude \"程式是最常用的工具，用於刷寫atmega晶片（包括載入程式刷寫和應用程式刷寫）。"

msgid "Atmega2560"
msgstr "Atmega2560"

msgid ""
"This chip is typically found in the \"Arduino Mega\" and is very common in "
"3d printer boards."
msgstr "這個晶片通常出現在 \"Arduino Mega\" 中，在3D印表機主板中也十分普遍。"

msgid "To flash the bootloader itself use something like:"
msgstr "要刷寫載入程式本身，請使用類似以下的方法："

msgid "To flash an application use something like:"
msgstr "要刷寫一個應用程式使用："

msgid "Atmega1280"
msgstr "Atmega1280"

msgid "This chip is typically found in earlier versions of the \"Arduino Mega\"."
msgstr "這個晶片通常出現在早期版本的 \"Arduino Mega \"中。"

msgid "Atmega1284p"
msgstr "Atmega1284p"

msgid "This chip is commonly found in \"Melzi\" style 3d printer boards."
msgstr "這種晶片通常出現在 \"Melzi \"式的3D印表機主板上。"

msgid ""
"Note that a number of \"Melzi\" style boards come preloaded with a "
"bootloader that uses a baud rate of 57600. In this case, to flash an "
"application use something like this instead:"
msgstr "注意，一些 \"Melzi \"風格的板子預載了一個使用57600波特率的載入程式。在這種情況下，要刷寫一個應用程式，請使用類似這樣的東西來代替："

msgid "At90usb1286"
msgstr "At90usb1286"

msgid ""
"This document does not cover the method to flash a bootloader to the "
"At90usb1286 nor does it cover general application flashing to this device."
msgstr "本檔案不包括向At90usb1286刷寫載入程式的方法，也不包括向該裝置刷寫一般應用。"

msgid "Atmega168"
msgstr "Atmega168"

msgid ""
"The atmega168 has limited flash space. If using a bootloader, it is "
"recommended to use the Optiboot bootloader. To flash that bootloader use "
"something like:"
msgstr ""
"atmega168的快閃記憶體空間有限。如果使用載入程式，建議使用Optiboot bootloader。要刷寫該載入程式，請使用這個的方法："

msgid ""
"To flash an application via the Optiboot bootloader use something like:"
msgstr "要通過Optiboot bootloader 刷寫一個應用程式，請使用以下方法："

msgid "SAM3 micro-controllers (Arduino Due)"
msgstr "SAM3 微控制器 (Arduino Due)"

msgid ""
"It is not common to use a bootloader with the SAM3 mcu. The chip itself has "
"a ROM that allows the flash to be programmed from 3.3V serial port or from "
"USB."
msgstr "通常在 SAM 3 微控制器上不使用載入程式。晶片自帶一個允許從3.3V 串列埠或從USB進行程式設計的ROM。"

msgid ""
"To enable the ROM, the \"erase\" pin is held high during a reset, which "
"erases the flash contents, and causes the ROM to run. On an Arduino Due, "
"this sequence can be accomplished by setting a baud rate of 1200 on the "
"\"programming usb port\" (the USB port closest to the power supply)."
msgstr ""
"爲了啟用ROM，將\"erase\"引腳在復位過程中保持高電平，這將擦除快閃記憶體的內容，並使ROM執行。在Arduino Due上，這個程式可以通過在"
" \"programming usb port\"（程式設計USB口，最靠近電源的USB埠）上設定1200的波特率來完成。"

msgid "SAM4 micro-controllers (Duet Wifi)"
msgstr "SAM4 微控制器 (Duet Wifi)"

msgid ""
"It is not common to use a bootloader with the SAM4 mcu. The chip itself has "
"a ROM that allows the flash to be programmed from 3.3V serial port or from "
"USB."
msgstr "通常在 SAM4 微控制器中不使用載入程式。晶片自帶一個可以從 3.3V 串列埠或 USB 進行程式設計的ROM。"

msgid ""
"To enable the ROM, the \"erase\" pin is held high during a reset, which "
"erases the flash contents, and causes the ROM to run."
msgstr "爲了啟用ROM，在復位過程中要將\"erase\"引腳保持為高電平，這將擦除快閃記憶體內容，並使ROM執行。"

msgid "SAMD21 micro-controllers (Arduino Zero)"
msgstr "SAMD21微控制器（Arduino Zero）"

msgid ""
"The SAMD21 bootloader is flashed via the ARM Serial Wire Debug (SWD) "
"interface. This is commonly done with a dedicated SWD hardware dongle. "
"Alternatively, one can use a [Raspberry Pi with OpenOCD](#running-openocd-"
"on-the-raspberry-pi)."
msgstr ""
"SAMD21 引導載入程式通過 ARM 序列線除錯 （SWD） 介面進行刷寫，通常需要一個專用的 SWD 硬體轉換器或者使用[安裝了 OpenOCD 的"
" Raspberry Pi](#running-openocd-on-the-raspberry-pi)來完成。"

msgid "To flash a bootloader with OpenOCD use the following chip config:"
msgstr "要使用 OpenOCD 刷寫引導載入程式，請使用以下晶片配置："

msgid "Obtain a bootloader - for example:"
msgstr "獲取引導載入程式 - 例如："

msgid "Flash with OpenOCD commands similar to:"
msgstr "使用類似下面的 OpenOCD 命令來刷寫："

msgid ""
"The most common bootloader on the SAMD21 is the one found on the \"Arduino "
"Zero\". It uses an 8KiB bootloader (the application must be compiled with a "
"start address of 8KiB). One can enter this bootloader by double clicking the"
" reset button. To flash an application use something like:"
msgstr ""
"SAMD21上最常見的啟動載入程式可以在 \"Arduino Zero \"上找到。它使用一個 8KiB 的載入程式（應用程式必須以 8KiB "
"的起始地址進行編譯），按下復位按鈕兩次就可以進入。要刷寫一個程式，請使用類似以下的方法："

msgid ""
"In contrast, the \"Arduino M0\" uses a 16KiB bootloader (the application "
"must be compiled with a start address of 16KiB). To flash an application on "
"this bootloader, reset the micro-controller and run the flash command within"
" the first few seconds of boot - something like:"
msgstr ""
"相比之下，\"Arduino M0 \"使用一個 16KiB 的啟動載入程式（程式必須用 16KiB "
"的起始地址進行編譯）。使用這個啟動載入程式來刷寫一個程式，請重置微控制器，並在啟動的頭幾秒鐘內執行刷寫命令--類似如下命令："

msgid "SAMD51 micro-controllers (Adafruit Metro-M4 and similar)"
msgstr "SAMD51 微控制器(Adafruit Metro-M4及類似的開發板)"

msgid ""
"Like the SAMD21, the SAMD51 bootloader is flashed via the ARM Serial Wire "
"Debug (SWD) interface. To flash a bootloader with [OpenOCD on a Raspberry "
"Pi](#running-openocd-on-the-raspberry-pi) use the following chip config:"
msgstr ""
"和 SAMD21 一樣，SAMD51 的啟動載入程式也是通過 ARM 序列線除錯（SWD）介面刷寫的。要用[執行 OpenOCD的 Raspberry "
"Pi](#running-openocd-on-the-raspberry-pi)刷寫載入程式，請使用以下晶片配置："

msgid ""
"The SAMD51 uses a 16KiB bootloader (the application must be compiled with a "
"start address of 16KiB). To flash an application use something like:"
msgstr "SAMD51 使用 16KiB 的啟動載入程式（應用程式必須以16KiB的起始地址進行編譯）。要刷寫一個應用程式，請使用類似以下的方法："

msgid "STM32F103 micro-controllers (Blue Pill devices)"
msgstr "STM32F103 微控制器（Blue Pill 開發板）"

msgid ""
"After flashing, set both \"boot 0\" and \"boot 1\" back to low so that "
"future resets boot from flash."
msgstr "刷寫后，將 \"boot 0 \"和 \"boot 1 \"都恢復設為低電平，以便在復位后從快閃記憶體啟動。"

msgid "STM32F103 with stm32duino bootloader"
msgstr "帶有 stm32duino 引導載入程式的 STM32F103"

msgid "This bootloader can be flashed via 3.3V serial with something like:"
msgstr "這個載入程式可以通過3.3V的串列埠用類似以下的命令來刷寫："

msgid ""
"This bootloader uses 8KiB of flash space (the application must be compiled "
"with a start address of 8KiB). Flash an application with something like:"
msgstr "這個載入程式使用 8KiB 的快閃記憶體空間（應用程式必須以 8KiB 的起始地址編譯）。刷寫應用程式需要使用類似以下的命令："

msgid ""
"The bootloader typically runs for only a short period after boot. It may be "
"necessary to time the above command so that it runs while the bootloader is "
"still active (the bootloader will flash a board led while it is running). "
"Alternatively, set the \"boot 0\" pin to low and \"boot 1\" pin to high to "
"stay in the bootloader after a reset."
msgstr ""
"啟動載入程式通常只在啟動后的一小段時間執行。在輸入以上命令的時候，需要確保啟動載入程式還在執行（啟動載入程式執行的時候會控制板上的led閃爍）。此外，啟動后如果設定「boot"
" 0」引腳為低，設定「boot 1」引腳為高則可以一直停留在啟動載入程式。"

msgid "STM32F103 with HID bootloader"
msgstr "帶有 HID 載入程式的STM32F103"

msgid ""
"For generic STM32F103 boards such as the blue pill it is possible to flash "
"the bootloader via 3.3v serial using stm32flash as noted in the stm32duino "
"section above, substituting the file name for the desired hid bootloader "
"binary (ie: hid_generic_pc13.bin for the blue pill)."
msgstr ""
"對於常見的STM32F103板，如Blue Pill，和 stm32duino 章節中一樣，可以通過 3.3v 序列用stm32flash "
"刷寫啟動載入程式，將檔名替換為所需的 hid載入程式二進制檔案（例如Blue Pill 使用的 hid_generic_pc13.bin）。"

msgid ""
"It is not possible to use stm32flash for the SKR Mini E3 as the boot0 pin is"
" tied directly to ground and not broken out via header pins. It is "
"recommended to use a STLink V2 with STM32Cubeprogrammer to flash the "
"bootloader. If you don't have access to a STLink it is also possible to use "
"a [Raspberry Pi and OpenOCD](#running-openocd-on-the-raspberry-pi) with the "
"following chip config:"
msgstr ""
"SKR Mini E3無法使用stm32flash ，因為boot 0引腳被直接接到GND且沒有跳線斷開。推薦使用STLink "
"V2通過STM32Cubeprogrammer刷寫啟動載入程式。如果你沒有STLink "
"，也可以按照以下晶片配置使用[樹莓派和OpenOCD](#running-openocd-on-the-raspberry-pi) 刷寫："

msgid ""
"If you wish you can make a backup of the current flash with the following "
"command. Note that it may take some time to complete:"
msgstr "如果你願意，可以使用下面的命令備份目前快閃記憶體上的程式。請注意，這可能需要一些時間來完成備份："

msgid "finally, you can flash with commands similar to:"
msgstr "最後，你可以用類似以下的命令刷寫韌體："

msgid "NOTES:"
msgstr "注意："

msgid ""
"The example above erases the chip then programs the bootloader. Regardless "
"of the method chosen to flash it is recommended to erase the chip prior to "
"flashing."
msgstr "上面的例子是先擦除晶片，然後再寫入載入程式。無論選擇哪種方法刷寫，都建議在刷寫前擦除晶片。"

msgid ""
"Prior flashing the SKR Mini E3 with this bootloader you should be aware that"
" you will no longer be able to update firmware via the sdcard."
msgstr "在用這個載入程式刷寫SKR Mini E3之前，你需要知道之後你將不能再通過SD卡更新韌體。"

msgid ""
"This bootloader requires 2KiB of flash space (the application must be "
"compiled with a start address of 2KiB)."
msgstr "這個載入程式需要2KiB的快閃記憶體空間（應用程式必須以2KiB的起始地址進行編譯）。"

msgid ""
"The hid-flash program is used to upload a binary to the bootloader. You can "
"install this software with the following commands:"
msgstr "hid-flash程式是用來上傳二進制檔案到啟動載入程式的。你可以用以下命令安裝這個軟體："

msgid "If the bootloader is running you can flash with something like:"
msgstr "如果bootloader正在執行，你可以用這個來刷寫："

msgid "alternatively, you can use `make flash` to flash klipper directly:"
msgstr "或者，你可以使用`make flash`來直接刷寫klipper："

msgid "OR if klipper has been previously flashed:"
msgstr "或者，如果klipper之前已經被寫入過："

msgid ""
"It may be necessary to manually enter the bootloader, this can be done by "
"setting \"boot 0\" low and \"boot 1\" high. On the SKR Mini E3 \"Boot 1\" is"
" not available, so it may be done by setting pin PA2 low if you flashed "
"\"hid_btt_skr_mini_e3.bin\". This pin is labeld \"TX0\" on the TFT header in"
" the SKR Mini E3's \"PIN\" document. There is a ground pin next to PA2 which"
" you can use to pull PA2 low."
msgstr ""
"可能需要手動進入載入程式，這可以通過設定 \"boot 0 \"的低電平和 \"boot 1 \"的高電平來完成。在SKR Mini "
"E3上，\"Boot 1 "
"\"是不可用的，所以如果你寫入過\"hid_btt_skr_mini_e3.bin\"，可以通過設定PA2的低電平來完成。在SKR Mini E3的 "
"\"PIN \"檔案中，這個引腳在TFT插座上被標記為 \"TX0\"。在PA2旁邊有一個接地引腳，你可以用它來把PA2拉低。"

msgid "STM32F4 micro-controllers (SKR Pro 1.1)"
msgstr "STM32F4 微控制器 (SKR Pro 1.1)"

msgid ""
"Unless your board is DFU capable the most accessable flashing method is "
"likely via 3.3v serial, which follows the same procedure as [flashing the "
"STM32F103 using stm32flash](#stm32f103-micro-controllers-blue-pill-devices)."
" For example:"
msgstr ""
"除非你的板子有DFU功能，否則最容易的寫入方法可能是通過3.3v的串列埠，這與[使用stm32flash刷寫STM32F103](#stm32f103-micro-"
"controllers-blue-pill-devices)的步驟相同。例如："

msgid ""
"This bootloader requires 16Kib of flash space on the STM32F4 (the "
"application must be compiled with a start address of 16KiB)."
msgstr "這個載入程式在STM32F4上需要16Kib的快閃記憶體空間（應用程式必須以16KiB的起始地址進行編譯）。"

msgid ""
"As with the STM32F1, the STM32F4 uses the hid-flash tool to upload binaries "
"to the MCU. See the instructions above for details on how to build and use "
"hid-flash."
msgstr ""
"與STM32F1一樣，STM32F4使用hid-flash工具來上傳二進制檔案到MCU。關於如何構建和使用hid-flash的細節，請參見上面的說明。"

msgid ""
"It may be necessary to manually enter the bootloader, this can be done by "
"setting \"boot 0\" low, \"boot 1\" high and plugging in the device. After "
"programming is complete unplug the device and set \"boot 1\" back to low so "
"the application will be loaded."
msgstr ""
"可能需要手動進入載入程式，這可以通過設定 \"boot 0 \"為低電平，\"boot 1 \"為高電平並上電來完成。程式設計完成後，裝置斷電，將 "
"\"boot 1 \"重設為低電平，這樣應用程式就會被載入。"

msgid "LPC176x micro-controllers (Smoothieboards)"
msgstr "LPC176x微控制器（Smoothieboards）"

msgid "Running OpenOCD on the Raspberry PI"
msgstr "在樹莓派上執行OpenOCD"

msgid ""
"OpenOCD is a software package that can perform low-level chip flashing and "
"debugging. It can use the GPIO pins on a Raspberry Pi to communicate with a "
"variety of ARM chips."
msgstr "OpenOCD是一個軟體包，可以進行底層的晶片程式設計和除錯。它可以使用樹莓派上的GPIO引腳與各種ARM晶片通訊。"

msgid ""
"Begin by downloading and compiling the software (each step may take several "
"minutes and the \"make\" step may take 30+ minutes):"
msgstr "開始下載和編譯軟體（每個步驟可能需要數分鐘，\"make \"步驟可能需要30分鐘以上）："

msgid "Configure OpenOCD"
msgstr "配置OpenOCD"

msgid "Create an OpenOCD config file:"
msgstr "建立一個OpenOCD配置檔案："

msgid "Use a config similar to the following:"
msgstr "使用類似於以下的配置："

msgid "Wire the Raspberry Pi to the target chip"
msgstr "將樹莓派與目標晶片相連"

msgid ""
"Poweroff both the the Raspberry Pi and the target chip before wiring! Verify"
" the target chip uses 3.3V prior to connecting to a Raspberry Pi!"
msgstr "在接線之前，請關閉樹莓派和目標晶片的電源! 在連線到樹莓派之前，請確認目標晶片使用3.3V電壓!"

msgid ""
"Connect GND, SWDCLK, SWDIO, and RST on the target chip to GND, GPIO25, "
"GPIO24, and GPIO18 respectively on the Raspberry Pi."
msgstr "將目標晶片上的GND、SWDCLK、SWDIO和RST分別連線到樹莓派上的GND、GPIO25、GPIO24和GPIO18。"

msgid "Then power up the Raspberry Pi and provide power to the target chip."
msgstr "然後給樹莓派上電，再給目標晶片供電。"

msgid "Run OpenOCD"
msgstr "執行OpenOCD"

msgid "Run OpenOCD:"
msgstr "執行OpenOCD："

msgid ""
"The above should cause OpenOCD to emit some text messages and then wait (it "
"should not immediately return to the Unix shell prompt). If OpenOCD exits on"
" its own or if it continues to emit text messages then double check the "
"wiring."
msgstr ""
"上述操作應該使OpenOCD輸出一些文字資訊，然後等待（它不會立即返回到Unix "
"shell提示符）。如果OpenOCD自己退出或繼續輸出文字資訊，那麼請仔細檢查接線。"

msgid ""
"Once OpenOCD is running and is stable, one can send it commands via telnet. "
"Open another ssh session and run the following:"
msgstr "一旦OpenOCD執行穩定，就可以通過telnet向它發送命令。打開另一個ssh會話，執行下面的命令："

msgid ""
"(One can exit telnet by pressing ctrl+] and then running the \"quit\" "
"command.)"
msgstr "(可以按ctrl+]退出telnet，然後執行 \"quit \"命令。)"

msgid "OpenOCD and gdb"
msgstr "OpenOCD和gdb"

msgid ""
"It is possible to use OpenOCD with gdb to debug Klipper. The following "
"commands assume one is running gdb on a desktop class machine."
msgstr "可以使用OpenOCD和gdb來除錯Klipper。下面的命令假設是在臺式機上執行gdb。"

msgid "Add the following to the OpenOCD config file:"
msgstr "在OpenOCD的配置檔案中加入以下內容："

msgid ""
"Restart OpenOCD on the Raspberry Pi and then run the following Unix command "
"on the desktop machine:"
msgstr "在樹莓派上重新啟動OpenOCD，然後在臺式機上執行以下Unix命令："

msgid "Within gdb run:"
msgstr "在gdb中執行："

msgid ""
"(Replace \"octopi\" with the host name of the Raspberry Pi.) Once gdb is "
"running it is possible to set breakpoints and to inspect registers."
msgstr "(用樹莓派的主機名替換 \"octopi\"）一旦gdb執行，就可以設定斷點並檢查暫存器。"

msgid ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/stk500v2/stk500boot_v2_mega2560.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:stk500boot_v2_mega2560.hex\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/stk500v2/stk500boot_v2_mega2560.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:stk500boot_v2_mega2560.hex\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:ATmegaBOOT_168_atmega1280.hex\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:ATmegaBOOT_168_atmega1280.hex\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid ""
"wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/optiboot_atmega1284p.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega1284p.hex\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/optiboot_atmega1284p.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega1284p.hex\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid "teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v\n"
msgstr "teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v\n"

msgid ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/bootloaders/optiboot/optiboot_atmega168.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:optiboot_atmega168.hex\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid ""
"bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b\n"
"bossac -U -p /dev/ttyACM0 -R\n"
msgstr ""
"bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b\n"
"bossac -U -p /dev/ttyACM0 -R\n"

msgid "bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin\n"
msgstr "bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin\n"

msgid "source [find target/at91samdXX.cfg]\n"
msgstr "來源 [查詢目標/at91samdXX.cfg]\n"

msgid ""
"wget 'https://github.com/arduino/ArduinoCore-"
"samd/raw/1.8.3/bootloaders/zero/samd21_sam_ba.bin'\n"
msgstr ""
"wget 'https://github.com/arduino/ArduinoCore-"
"samd/raw/1.8.3/bootloaders/zero/samd21_sam_ba.bin'\n"

msgid ""
"at91samd bootloader 0\n"
"program samd21_sam_ba.bin verify\n"
msgstr ""
"at91samd bootloader 0\n"
"program samd21_sam_ba.bin verify\n"

msgid "bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R\n"
msgstr "bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R\n"

msgid ""
"avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u "
"-Uflash:w:out/klipper.elf.hex:i\n"
msgstr ""
"avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u "
"-Uflash:w:out/klipper.elf.hex:i\n"

msgid "source [find target/atsame5x.cfg]\n"
msgstr "來源 [查詢目標/atsame5x.cfg]\n"

msgid ""
"wget "
"'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/bootloader-"
"itsybitsy_m4-v3.7.0.bin'\n"
msgstr ""
"wget "
"'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/bootloader-"
"itsybitsy_m4-v3.7.0.bin'\n"

msgid ""
"at91samd bootloader 0\n"
"program bootloader-itsybitsy_m4-v3.7.0.bin verify\n"
"at91samd bootloader 16384\n"
msgstr ""
"at91samd bootloader 0\n"
"program bootloader-itsybitsy_m4-v3.7.0.bin verify\n"
"at91samd bootloader 16384\n"

msgid "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"
msgstr "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"

msgid "stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0\n"
msgstr "stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0\n"

msgid ""
"wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin'\n"
"\n"
"stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0\n"
msgstr ""
"wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/master/binaries/generic_boot20_pc13.bin'\n"
"\n"
"stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0\n"

msgid "dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin\n"
msgstr "dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin\n"

msgid "source [find target/stm32f1x.cfg]\n"
msgstr "來源 [查詢目標/stm32f1x.cfg]\n"

msgid "flash read_bank 0 btt_skr_mini_e3_backup.bin\n"
msgstr "flash read_bank 0 btt_skr_mini_e3_backup.bin\n"

msgid ""
"stm32f1x mass_erase 0\n"
"program hid_btt_skr_mini_e3.bin verify 0x08000000\n"
msgstr ""
"stm32f1x mass_erase 0\n"
"program hid_btt_skr_mini_e3.bin verify 0x08000000\n"

msgid ""
"You may need to hold down the reset button on the board while launching OpenOCD. It should display something like:Open On-Chip Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00)\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"DEPRECATED! use 'adapter speed' not 'adapter_khz'\n"
"Info : BCM2835 GPIO JTAG/SWD bitbang driver\n"
"Info : JTAG and SWD modes enabled\n"
"Info : clock speed 40 kHz\n"
"Info : SWD DPIDR 0x1ba01477\n"
"Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"Info : stm32f1x.cpu: external reset detected\n"
"Info : starting gdb server for stm32f1x.cpu on 3333\n"
"Info : Listening on port 3333 for gdb connections\n"
msgstr ""
"You may need to hold down the reset button on the board while launching OpenOCD. It should display something like:Open On-Chip Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00)\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"DEPRECATED! use 'adapter speed' not 'adapter_khz'\n"
"Info : BCM2835 GPIO JTAG/SWD bitbang driver\n"
"Info : JTAG and SWD modes enabled\n"
"Info : clock speed 40 kHz\n"
"Info : SWD DPIDR 0x1ba01477\n"
"Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"Info : stm32f1x.cpu: external reset detected\n"
"Info : starting gdb server for stm32f1x.cpu on 3333\n"
"Info : Listening on port 3333 for gdb connections\n"

msgid "After which you can release the reset button."
msgstr "之後可以鬆開復位按鈕。"

msgid ""
"sudo apt install libusb-1.0\n"
"cd ~/klipper/lib/hidflash\n"
"make\n"
msgstr ""
"sudo apt install libusb-1.0\n"
"cd ~/klipper/lib/hidflash\n"
"make\n"

msgid "~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin\n"
msgstr "~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin\n"

msgid "make flash FLASH_DEVICE=1209:BEBA\n"
msgstr "make flash FLASH_DEVICE=1209:BEBA\n"

msgid "make flash FLASH_DEVICE=/dev/ttyACM0\n"
msgstr "make flash FLASH_DEVICE=/dev/ttyACM0\n"

msgid ""
"wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin\n"
"\n"
"stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0\n"
msgstr ""
"wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-beta/hid_bootloader_SKR_PRO.bin\n"
"\n"
"stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0\n"

msgid ""
"sudo apt-get update\n"
"sudo apt-get install autoconf libtool telnet\n"
"mkdir ~/openocd\n"
"cd ~/openocd/\n"
"git clone http://openocd.zylin.com/openocd\n"
"cd openocd\n"
"./bootstrap\n"
"./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/openocd/install\n"
"make\n"
"make install\n"
msgstr ""
"sudo apt-get update\n"
"sudo apt-get install autoconf libtool telnet\n"
"mkdir ~/openocd\n"
"cd ~/openocd/\n"
"git clone http://openocd.zylin.com/openocd\n"
"cd openocd\n"
"./bootstrap\n"
"./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/openocd/install\n"
"make\n"
"make install\n"

msgid "nano ~/openocd/openocd.cfg\n"
msgstr "nano ~/openocd/openocd.cfg\n"

msgid ""
"# Uses RPi pins: GPIO25 for SWDCLK, GPIO24 for SWDIO, GPIO18 for nRST\n"
"source [find interface/raspberrypi2-native.cfg]\n"
"bcm2835gpio_swd_nums 25 24\n"
"bcm2835gpio_srst_num 18\n"
"transport select swd\n"
"\n"
"# Use hardware reset wire for chip resets\n"
"reset_config srst_only\n"
"adapter_nsrst_delay 100\n"
"adapter_nsrst_assert_width 100\n"
"\n"
"# Specify the chip type\n"
"source [find target/atsame5x.cfg]\n"
"\n"
"# Set the adapter speed\n"
"adapter_khz 40\n"
"\n"
"# Connect to chip\n"
"init\n"
"targets\n"
"reset halt\n"
msgstr ""
"# Uses RPi pins: GPIO25 for SWDCLK, GPIO24 for SWDIO, GPIO18 for nRST\n"
"source [find interface/raspberrypi2-native.cfg]\n"
"bcm2835gpio_swd_nums 25 24\n"
"bcm2835gpio_srst_num 18\n"
"transport select swd\n"
"\n"
"# Use hardware reset wire for chip resets\n"
"reset_config srst_only\n"
"adapter_nsrst_delay 100\n"
"adapter_nsrst_assert_width 100\n"
"\n"
"# Specify the chip type\n"
"source [find target/atsame5x.cfg]\n"
"\n"
"# Set the adapter speed\n"
"adapter_khz 40\n"
"\n"
"# Connect to chip\n"
"init\n"
"targets\n"
"reset halt\n"

msgid ""
"cd ~/openocd/\n"
"sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg\n"
msgstr ""
"cd ~/openocd/\n"
"sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg\n"

msgid "telnet 127.0.0.1 4444\n"
msgstr "telnet 127.0.0.1 4444\n"

msgid ""
"bindto 0.0.0.0\n"
"gdb_port 44444\n"
msgstr ""
"bindto 0.0.0.0\n"
"gdb_port 44444\n"

msgid ""
"cd /path/to/klipper/\n"
"gdb out/klipper.elf\n"
msgstr ""
"cd /path/to/klipper/\n"
"gdb out/klipper.elf\n"

msgid "target remote octopi:44444\n"
msgstr "target remote octopi:44444\n"

#: docs/Bootloaders.md:block 1 (header)
msgid "Bootloaders"
msgstr "底層載入程式"

#: docs/Bootloaders.md:block 7 (paragraph)
msgid ""
"In general, the Arduino project is a good reference for bootloaders and "
"flashing procedures on the 8-bit Atmel Atmega micro-controllers. In "
"particular, the \"boards.txt\" file: "
"<https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt>"
" is a useful reference."
msgstr ""
"總體上來說，Arduino專案是8位Atmel Atmega微控制器的載入程式和刷寫程式的好的參考。特別是\" boards.txt "
"\"檔案。<https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt>是一個有用的參考。"

#: docs/Bootloaders.md:block 32 (paragraph)
msgid ""
"The Teensy++ device from pjrc.com comes with a proprietary bootloader. It "
"requires a custom flashing tool from "
"<https://github.com/PaulStoffregen/teensy_loader_cli>. One can flash an "
"application with it using something like:"
msgstr ""
"來自pjrc.com的Teensy++裝置帶有一個專用的載入程式。它需要一個來自<https://github.com/PaulStoffregen/teensy_loader_cli>的定製刷寫工具。可以用這個工具來刷寫一個應用程式，例如："

#: docs/Bootloaders.md:block 42 (paragraph)
msgid ""
"The code at <https://github.com/shumatech/BOSSA> can be used to program the "
"SAM3. It is recommended to use version 1.9 or later."
msgstr "<https://github.com/shumatech/BOSSA>中的程式碼可以用來為SAM3程式設計。建議使用1.9或更高版本。"

#: docs/Bootloaders.md:block 48 (paragraph)
msgid ""
"The code at <https://github.com/shumatech/BOSSA> can be used to program the "
"SAM4. It is necessary to use version `1.8.0` or higher."
msgstr ""
"<https://github.com/shumatech/BOSSA>中的程式碼可以用來為SAM4程式設計。需要使用`1.8.0`或更高的版本。"

#: docs/Bootloaders.md:block 66 (paragraph)
msgid ""
"Obtain a bootloader - several bootloaders are available from "
"<https://github.com/adafruit/uf2-samdx1/releases/latest>. For example:"
msgstr ""
"獲得一個載入程式--"
"很多載入程式可以從<https://github.com/adafruit/uf2-samdx1/releases/latest>獲得。例如："

#: docs/Bootloaders.md:block 78 (paragraph)
msgid ""
"The \"stm32duino\" project has a USB capable bootloader - see: "
"<https://github.com/rogerclarkmelbourne/STM32duino-bootloader>"
msgstr ""
"\"stm32duino \"專案有一個USB功能的載入程式-"
"參見：<https://github.com/rogerclarkmelbourne/STM32duino-bootloader>"

#: docs/Bootloaders.md:block 113 (paragraph)
msgid ""
"This document does not describe the method to flash a bootloader itself - "
"see: <http://smoothieware.org/flashing-the-bootloader> for further "
"information on that topic."
msgstr ""
"本檔案沒有描述刷寫載入程式本身的方法--見：<http://smoothieware.org/flashing-the-"
"bootloader>以獲得關於該主題的進一步資訊。"

#: docs/Bootloaders.md:block 114 (paragraph)
msgid ""
"It is common for Smoothieboards to come with a bootloader from: "
"<https://github.com/triffid/LPC17xx-DFU-Bootloader>. When using this "
"bootloader the application must be compiled with a start address of 16KiB. "
"The easiest way to flash an application with this bootloader is to copy the "
"application file (eg, `out/klipper.bin`) to a file named `firmware.bin` on "
"an SD card, and then to reboot the micro-controller with that SD card."
msgstr ""
"Smoothieboards通常帶有一個來自<https://github.com/triffid/LPC17xx-DFU-"
"Bootloader>的bootloader。當使用這個載入程式時，應用程式必須以16KiB的起始地址進行編譯。用這個載入程式刷寫應用程式的最簡單方法是將應用程式檔案（例如`out/klipper.bin`）複製到SD卡上一個名為`firmware.bin`的檔案，然後用該SD卡重新啟動微控制器。"

#: docs/Bootloaders.md:block 117 (paragraph)
msgid ""
"This section describes how one can install and launch OpenOCD. It is derived"
" from the instructions at: <https://learn.adafruit.com/programming-"
"microcontrollers-using-openocd-on-raspberry-pi>"
msgstr ""
"本節描述瞭如何安裝和啟動OpenOCD。它來自於以下的說明：<https://learn.adafruit.com/programming-"
"microcontrollers-using-openocd-on-raspberry-pi>"

#: docs/Bootloaders.md:block 75 (paragraph)
msgid ""
"Note that if one is using a Raspberry Pi for the 3.3V serial, the stm32flash"
" protocol uses a serial parity mode which the Raspberry Pi's \"mini UART\" "
"does not support. See "
"<https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-"
"uarts> for details on enabling the full uart on the Raspberry Pi GPIO pins."
msgstr ""
"注意，如果使用樹莓派的3.3V串列埠，stm32flash協議使用的序列奇偶校驗模式，樹莓派的 \"mini UART "
"\"並不支援。關於在樹莓派的GPIO引腳上啟用完整的UART的細節，見<https://www.raspberrypi.com/documentation/computers/configuration.html#configuring-"
"uarts>。"

#: docs/Bootloaders.md:block 85 (paragraph)
msgid ""
"The [HID bootloader](https://github.com/Serasidis/STM32_HID_Bootloader) is a"
" compact, driverless bootloader capable of flashing over USB. Also available"
" is a [fork with builds specific to the SKR Mini E3 "
"1.2](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."
msgstr ""
"[HID "
"bootloader](https://github.com/Serasidis/STM32_HID_Bootloader)是一個緊湊的、不包含驅動的啟動載入程式，能夠通過USB進行刷寫。此外，還有一個[針對SKR"
" Mini E3 "
"1.2構建的分支](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)。"

#: docs/Bootloaders.md:block 106 (paragraph)
msgid ""
"STM32F4 microcontrollers come equipped with a built-in system bootloader "
"capable of flashing over USB (via DFU), 3.3v Serial, and various other "
"methods (see STM Document AN2606 for more information). Some STM32F4 boards,"
" such as the SKR Pro 1.1, are not able to enter the DFU bootloader. The HID "
"bootloader is available for STM32F405/407 based boards should the user "
"prefer flashing over USB over using the sdcard. Note that you may need to "
"configure and build a version specific to your board, a [build for the SKR "
"Pro 1.1 is available "
"here](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."
msgstr ""
"STM32F4微控制器配備了一個內建的系統載入程式，能夠通過USB（通過DFU）、3.3v串列埠和其他各種方法進行刷寫（更多資訊見STM檔案AN2606）。一些STM32F4板，如SKR"
" Pro "
"1.1，不能進入DFU載入程式。基於STM32F405/407的板子可以使用HID載入程式，如果使用者願意通過USB刷寫而不是使用SD卡。請注意，你可能需針對你的板子配置和構建一個特定的版本，[針對SKR"
" Pro "
"1.1的構建可以在這裡找到](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)。"

#: docs/Bootloaders.md:block 105 (header)
msgid "STM32F103/STM32F072 with MSC bootloader"
msgstr ""

#: docs/Bootloaders.md:block 106 (paragraph)
msgid ""
"The [MSC bootloader](https://github.com/Telekatz/MSC-stm32f103-bootloader) "
"is a driverless bootloader capable of flashing over USB."
msgstr ""

#: docs/Bootloaders.md:block 107 (paragraph)
msgid ""
"It is possible to flash the bootloader via 3.3v serial using stm32flash as "
"noted in the stm32duino section above, substituting the file name for the "
"desired MSC bootloader binary (ie: MSCboot-Bluepill.bin for the blue pill)."
msgstr ""

#: docs/Bootloaders.md:block 108 (paragraph)
msgid ""
"For STM32F072 boards it is also possible to flash the bootloader over USB "
"(via DFU) with something like:"
msgstr ""

#: docs/Bootloaders.md:block 109 (code)
msgid ""
" dfu-util -d 0483:df11 -a 0 -R -D  MSCboot-STM32F072.bin "
"-s0x08000000:leave\n"
msgstr ""

#: docs/Bootloaders.md:block 110 (paragraph)
msgid ""
"This bootloader uses 8KiB or 16KiB of flash space, see description of the "
"bootloader (the application must be compiled with with the corresponding "
"starting address)."
msgstr ""

#: docs/Bootloaders.md:block 111 (paragraph)
msgid ""
"The bootloader can be activated by pressing the reset button of the board "
"twice. As soon as the bootloader is activated, the board appears as a USB "
"flash drive onto which the klipper.bin file can be copied."
msgstr ""

#: docs/Bootloaders.md:block 73 (paragraph)
msgid ""
"The STM32F103 devices have a ROM that can flash a bootloader or application "
"via 3.3V serial. Typically one would wire the PA10 (MCU Rx) and PA9 (MCU Tx)"
" pins to a 3.3V UART adapter. To access the ROM, one should connect the "
"\"boot 0\" pin to high and \"boot 1\" pin to low, and then reset the device."
" The \"stm32flash\" package can then be used to flash the device using "
"something like:"
msgstr ""

#: docs/Bootloaders.md:block 112 (header)
msgid "STM32F103/STM32F0x2 with CanBoot bootloader"
msgstr ""

#: docs/Bootloaders.md:block 113 (paragraph)
msgid ""
"The [CanBoot](https://github.com/Arksine/CanBoot) bootloader provides an "
"option for uploading Klipper firmware over the CANBUS. The bootloader itself"
" is derived from Klipper's source code. Currently CanBoot supports the "
"STM32F103, STM32F042, and STM32F072 models."
msgstr ""

#: docs/Bootloaders.md:block 114 (paragraph)
msgid ""
"It is recommended to use a ST-Link Programmer to flash CanBoot, however it "
"should be possible to flash using `stm32flash` on STM32F103 devices, and "
"`dfu-util` on STM32F042/STM32F072 devices. See the previous sections in this"
" document for instructions on these flashing methods, substituting "
"`canboot.bin` for the file name where appropriate. The CanBoot repo linked "
"above provides instructions for building the bootloader."
msgstr ""

#: docs/Bootloaders.md:block 115 (paragraph)
msgid ""
"The first time CanBoot has been flashed it should detect that no application"
" is present and enter the bootloader. If this doesn't occur it is possible "
"to enter the bootloader by pressing the reset button twice in succession."
msgstr ""

#: docs/Bootloaders.md:block 116 (paragraph)
msgid ""
"The `flash_can.py` utility supplied in the `lib/canboot` folder may be used "
"to upload Klipper firmware. The device UUID is necessary to flash. If you do"
" not have a UUID it is possible to query nodes currently running the "
"bootloader:"
msgstr ""

#: docs/Bootloaders.md:block 117 (code)
msgid "python3 flash_can.py -q\n"
msgstr ""

#: docs/Bootloaders.md:block 118 (paragraph)
msgid ""
"This will return UUIDs for all connected nodes not currently assigned a "
"UUID. This should include all nodes currently in the bootloader."
msgstr ""

#: docs/Bootloaders.md:block 119 (paragraph)
msgid "Once you have a UUID, you may upload firmware with following command:"
msgstr ""

#: docs/Bootloaders.md:block 120 (code)
msgid ""
"python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff\n"
msgstr ""

#: docs/Bootloaders.md:block 121 (paragraph)
msgid ""
"Where `aabbccddeeff` is replaced by your UUID. Note that the `-i` and `-f` "
"options may be omitted, they default to `can0` and "
"`~/klipper/out/klipper.bin` respectively."
msgstr ""

#: docs/Bootloaders.md:block 122 (paragraph)
msgid ""
"When building Klipper for use with CanBoot, select the 8 KiB Bootloader "
"option."
msgstr ""

#~ msgid ""
#~ "The STM32F103 devices have a ROM that can flash a bootloader or application "
#~ "via 3.3V serial. To access this ROM, one should connect the \"boot 0\" pin "
#~ "to high and \"boot 1\" pin to low, and then reset the device. The "
#~ "\"stm32flash\" package can then be used to flash the device using something "
#~ "like:"
#~ msgstr ""
#~ "STM32F103 產品線的晶片包含一個可以通過 3.3V 串列埠刷寫載入程式或應用程式的ROM。要訪問這個ROM，在\"boot 0 "
#~ "\"引腳接到高電平\"boot 1 \" 引腳接到低電平後重置晶片。然後，可以使用 \"stm32flash \"軟體包，使用類似以下的命令刷寫："

#~ msgid ""
#~ "The [HID bootloader](https://github.com/Serasidis/STM32_HID_Bootloader) is a"
#~ " compact, driverless bootloader capable of flashing over USB. Also available"
#~ " is a [fork with builds specific to the SKR Mini E3 "
#~ "1.2](https://github.com/Arksine/STM32_HID_Bootloader/releases/tag/v0.5-beta)."
#~ msgstr ""

#~ msgid ""
#~ "STM32F4 microcontrollers come equipped with a built-in system bootloader "
#~ "capable of flashing over USB (via DFU), 3.3v Serial, and various other "
#~ "methods (see STM Document AN2606 for more information). Some STM32F4 boards,"
#~ " such as the SKR Pro 1.1, are not able to enter the DFU bootloader. The HID "
#~ "bootloader is available for STM32F405/407 based boards should the user "
#~ "prefer flashing over USB over using the sdcard. Note that you may need to "
#~ "configure and build a version specific to your board, a [build for the SKR "
#~ "Pro 1.1 is available "
#~ "here](https://github.com/Arksine/STM32_HID_Bootloader/releases/tag/v0.5-beta)."
#~ msgstr ""

#~ msgid ""
#~ "Note that if one is using a Raspberry Pi for the 3.3V serial, the stm32flash"
#~ " protocol uses a serial parity mode which the Raspberry Pi's \"miniuart\" "
#~ "does not support. See "
#~ "<https://www.raspberrypi.org/documentation/configuration/uart.md> for "
#~ "details on enabling the full uart on the Raspberry Pi GPIO pins."
#~ msgstr ""

#~ msgid ""
#~ "In general, the Arduino project is a good reference for bootloaders and "
#~ "flashing procedures on the 8-bit Atmel Atmega micro-controllers. In "
#~ "particular, the \"boards.txt\" file: "
#~ "[https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt](https://github.com/arduino/Arduino/blob/1.8.5/hardware/arduino/avr/boards.txt)"
#~ " is a useful reference."
#~ msgstr ""

#~ msgid ""
#~ "The Teensy++ device from pjrc.com comes with a proprietary bootloader. It "
#~ "requires a custom flashing tool from "
#~ "[https://github.com/PaulStoffregen/teensy_loader_cli](https://github.com/PaulStoffregen/teensy_loader_cli)."
#~ " One can flash an application with it using something like:"
#~ msgstr ""

#~ msgid ""
#~ "The code at "
#~ "[https://github.com/shumatech/BOSSA](https://github.com/shumatech/BOSSA) can"
#~ " be used to program the SAM3. It is recommended to use version 1.9 or later."
#~ msgstr ""

#~ msgid ""
#~ "The code at "
#~ "[https://github.com/shumatech/BOSSA](https://github.com/shumatech/BOSSA) can"
#~ " be used to program the SAM4. It is necessary to use version `1.8.0` or "
#~ "higher."
#~ msgstr ""

#~ msgid ""
#~ "Obtain a bootloader - several bootloaders are available from "
#~ "[https://github.com/adafruit/uf2-samdx1/releases/latest](https://github.com/adafruit/uf2-samdx1/releases/latest)."
#~ " For example:"
#~ msgstr ""

#~ msgid ""
#~ "Note that if one is using a Raspberry Pi for the 3.3V serial, the stm32flash"
#~ " protocol uses a serial parity mode which the Raspberry Pi's \"miniuart\" "
#~ "does not support. See "
#~ "[https://www.raspberrypi.org/documentation/configuration/uart.md](https://www.raspberrypi.org/documentation/configuration/uart.md)"
#~ " for details on enabling the full uart on the Raspberry Pi GPIO pins."
#~ msgstr ""

#~ msgid ""
#~ "The \"stm32duino\" project has a USB capable bootloader - see: "
#~ "[https://github.com/rogerclarkmelbourne/STM32duino-"
#~ "bootloader](https://github.com/rogerclarkmelbourne/STM32duino-bootloader)"
#~ msgstr ""

#~ msgid ""
#~ "This document does not describe the method to flash a bootloader itself - "
#~ "see: [http://smoothieware.org/flashing-the-"
#~ "bootloader](http://smoothieware.org/flashing-the-bootloader) for further "
#~ "information on that topic."
#~ msgstr ""

#~ msgid ""
#~ "It is common for Smoothieboards to come with a bootloader from: "
#~ "[https://github.com/triffid/LPC17xx-DFU-"
#~ "Bootloader](https://github.com/triffid/LPC17xx-DFU-Bootloader). When using "
#~ "this bootloader the application must be compiled with a start address of "
#~ "16KiB. The easiest way to flash an application with this bootloader is to "
#~ "copy the application file (eg, `out/klipper.bin`) to a file named "
#~ "`firmware.bin` on an SD card, and then to reboot the micro-controller with "
#~ "that SD card."
#~ msgstr ""

#~ msgid ""
#~ "This section describes how one can install and launch OpenOCD. It is derived"
#~ " from the instructions at: [https://learn.adafruit.com/programming-"
#~ "microcontrollers-using-openocd-on-raspberry-"
#~ "pi](https://learn.adafruit.com/programming-microcontrollers-using-openocd-"
#~ "on-raspberry-pi)"
#~ msgstr ""

#~ msgid ""
#~ "You may need to hold down the reset button on the board while launching "
#~ "OpenOCD. It should display something like:After which you can release the "
#~ "reset button."
#~ msgstr ""
