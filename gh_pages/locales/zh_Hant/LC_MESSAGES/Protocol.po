# Fred Chan <fred2088@gmail.com>, 2022.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2022-02-23 12:56+0000\n"
"Last-Translator: Fred Chan <fred2088@gmail.com>\n"
"Language-Team: Chinese (Traditional) <https://hosted.weblate.org/projects/klipper/protocol/zh_Hant/>\n"
"Language: zh_Hant\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.11-dev\n"

msgid ""
"The Klipper messaging protocol is used for low-level communication between "
"the Klipper host software and the Klipper micro-controller software. At a "
"high level the protocol can be thought of as a series of command and "
"response strings that are compressed, transmitted, and then processed at the"
" receiving side. An example series of commands in uncompressed human-"
"readable format might look like:"
msgstr ""
"Klipper訊息協議用於Klipper主機軟體和Klipper微控制器軟體之間的低層通訊。在上層看，該協議可以被認為是一系列的命令和響應字串，它們被壓縮、傳輸，然後在接收方進行處理。以下是一個例子，包含一組未經壓縮的人類可讀格式的命令："

msgid ""
"See the [mcu commands](MCU_Commands.md) document for information on "
"available commands. See the [debugging](Debugging.md) document for "
"information on how to translate a G-Code file into its corresponding human-"
"readable micro-controller commands."
msgstr ""
"有關可用命令的資訊，請參閱 [mcu 命令](MCU_Commands.md)文件。有關如何將 G-Code "
"檔案轉換為其相應的可讀的微控制器命令資訊，請參閱[除錯](Debugging.md)文件。"

msgid ""
"This page provides a high-level description of the Klipper messaging "
"protocol itself. It describes how messages are declared, encoded in binary "
"format (the \"compression\" scheme), and transmitted."
msgstr "本頁提供了Klipper訊息傳遞協議本身的高層描述。它描述了訊息是如何被聲明、以二進制格式編碼（\"壓縮 \"方案）和傳輸的。"

msgid ""
"The goal of the protocol is to enable an error-free communication channel "
"between the host and micro-controller that is low-latency, low-bandwidth, "
"and low-complexity for the micro-controller."
msgstr "該協議的目標是在主機和微控制器之間建立一個無錯誤的通訊通道，對微控制器來說是低延遲、低頻寬和低複雜度的。"

msgid "Micro-controller Interface"
msgstr "微控制器介面"

msgid ""
"The Klipper transmission protocol can be thought of as a "
"[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call) mechanism between"
" micro-controller and host. The micro-controller software declares the "
"commands that the host may invoke along with the response messages that it "
"can generate. The host uses that information to command the micro-controller"
" to perform actions and to interpret the results."
msgstr ""
"Klipper傳輸協議可以被認為是微控制器和主機之間的一個[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call)機制。微控制器軟體聲明了主機可以呼叫的命令，以及它可以產生的響應資訊。主機使用這些資訊來命令微控制器執行動作並解釋結果。"

msgid "Declaring commands"
msgstr "宣佈命令"

msgid ""
"The micro-controller software declares a \"command\" by using the "
"DECL_COMMAND() macro in the C code. For example:"
msgstr "微控制器軟體通過使用C程式碼中的DECL_COMMAND()宏來聲明一個 「命令」。例如："

msgid ""
"The above declares a command named \"update_digital_out\". This allows the "
"host to \"invoke\" this command which would cause the "
"command_update_digital_out() C function to be executed in the micro-"
"controller. The above also indicates that the command takes two integer "
"parameters. When the command_update_digital_out() C code is executed, it "
"will be passed an array containing these two integers - the first "
"corresponding to the 'oid' and the second corresponding to the 'value'."
msgstr ""
"以上聲明了一個名為 \"update_digital_out \"的命令。這允許主機 "
"「invoke」這個命令，這將使得command_update_digital_out()C函式在微控制器中被執行。上述內容還表明，該命令需要兩個整數參數。當command_update_digital_out()C程式碼被執行時，它將被傳遞一個包含這兩個整數的陣列"
"--第一個對應于 \"oid\"，第二個對應于 \"value\"。"

msgid ""
"In general, the parameters are described with printf() style syntax (eg, "
"\"%u\"). The formatting directly corresponds to the human-readable view of "
"commands (eg, \"update_digital_out oid=7 value=1\"). In the above example, "
"\"value=\" is a parameter name and \"%c\" indicates the parameter is an "
"integer. Internally, the parameter name is only used as documentation. In "
"this example, the \"%c\" is also used as documentation to indicate the "
"expected integer is 1 byte in size (the declared integer size does not "
"impact the parsing or encoding)."
msgstr ""
"一般來說，參數是用printf()風格的語法描述的（例如，\"%u\"）。這種格式化直接對應於人類可讀的命令（例如，\"update_digital_out"
" oid=7 value=1\"）。在上面的例子中，\"value=\"是一個參數名稱，\"%c "
"\"表示該參數是一個整數。在內部，參數名只作為記錄使用。在這個例子中，\"%c "
"\"也是作為記錄使用的，表示預期的整數是1位元組寬度（聲明的整數寬度不影響編解碼）。"

msgid ""
"The micro-controller build will collect all commands declared with "
"DECL_COMMAND(), determine their parameters, and arrange for them to be "
"callable."
msgstr "微控制器韌體構建的時候包含所有用DECL_COMMAND()聲明的命令，確定其參數，並使得它們可以被呼叫。"

msgid "Declaring responses"
msgstr "聲明響應"

msgid ""
"To send information from the micro-controller to the host a \"response\" is "
"generated. These are both declared and transmitted using the sendf() C "
"macro. For example:"
msgstr "當從微控制器向主機發送資訊時會產生一個 \"響應\"。這些都是使用sendf()C語言宏來聲明和發送的。例如："

msgid ""
"The above transmits a \"status\" response message that contains two integer "
"parameters (\"clock\" and \"status\"). The micro-controller build "
"automatically finds all sendf() calls and generates encoders for them. The "
"first parameter of the sendf() function describes the response and it is in "
"the same format as command declarations."
msgstr ""
"以上傳輸了一個 \"狀態 \"響應訊息，其中包含兩個整數參數（\"時鐘 \"和 "
"\"狀態\"）。微控制器的構建會自動找到所有sendf()的呼叫，併爲其產生編碼器。sendf()函式的第一個參數描述了響應，它的格式與命令聲明相同。"

msgid ""
"The host can arrange to register a callback function for each response. So, "
"in effect, commands allow the host to invoke C functions in the micro-"
"controller and responses allow the micro-controller software to invoke code "
"in the host."
msgstr "主機可以為每個響應註冊一個回撥函式。因此，實際上，命令允許主機在微控制器上呼叫C函式，響應允許微控制器軟體在主機上呼叫程式碼。"

msgid ""
"The sendf() macro should only be invoked from command or task handlers, and "
"it should not be invoked from interrupts or timers. The code does not need "
"to issue a sendf() in response to a received command, it is not limited in "
"the number of times sendf() may be invoked, and it may invoke sendf() at any"
" time from a task handler."
msgstr ""
"sendf()宏只能從命令或任務處理程式中呼叫，而不能從中斷或定時器中呼叫。程式碼不需要在收到命令的響應中發出sendf()，程式碼也不限制sendf()的呼叫次數，任務處理程式在在任何時候都可以呼叫sendf()。"

msgid "Output responses"
msgstr "輸出響應"

msgid ""
"To simplify debugging, there is also an output() C function. For example:"
msgstr "爲了簡化除錯，也有一個output()C函式。例如："

msgid ""
"The output() function is similar in usage to printf() - it is intended to "
"generate and format arbitrary messages for human consumption."
msgstr "output()函式的用法與printf()相似–它的目的是產生和格式化任意的資訊供人閱讀。"

msgid "Declaring enumerations"
msgstr "聲明列舉"

msgid ""
"Enumerations allow the host code to use string identifiers for parameters "
"that the micro-controller handles as integers. They are declared in the "
"micro-controller code - for example:"
msgstr "列舉允許主機程式碼對微控制器作為整數處理的參數使用字串標識。它們在微控制器程式碼中被聲明-例如："

msgid ""
"If the first example, the DECL_ENUMERATION() macro defines an enumeration "
"for any command/response message with a parameter name of \"spi_bus\" or "
"parameter name with a suffix of \"_spi_bus\". For those parameters the "
"string \"spi\" is a valid value and it will be transmitted with an integer "
"value of zero."
msgstr ""
"在第一個例子中，DECL_ENUMERATION()宏定義了一個列舉量可以用於任意的命令/響應訊息，這個列舉量的參數名稱為 \"spi_bus "
"\"或參數名稱後綴為\"_spi_bus \"。對於此參數，字串 \"spi \"是一個有效的值，它將以一個零的整數值被傳遞。"

msgid ""
"It's also possible to declare an enumeration range. In the second example, a"
" \"pin\" parameter (or any parameter with a suffix of \"_pin\") would accept"
" PC0, PC1, PC2, ..., PC7 as valid values. The strings will be transmitted "
"with integers 16, 17, 18, ..., 23."
msgstr ""
"也可以聲明一個列舉範圍。在第二個例子中，\"pin \"參數（或任何後綴為\"_pin "
"\"的參數）將接受PC0、PC1、PC2、...、PC7作為有效值。字串將被轉化成整數16、17、18...23進行傳輸。"

msgid "Declaring constants"
msgstr "聲明常量"

msgid "Constants can also be exported. For example, the following:"
msgstr "常量也可以被導出。例子如下："

msgid ""
"would export a constant named \"SERIAL_BAUD\" with a value of 250000 from "
"the micro-controller to the host. It is also possible to declare a constant "
"that is a string - for example:"
msgstr "可以從微控制器向主機輸出一個名為 \"SERIAL_BAUD \"，值為250000的常數。也可以將字串聲明成常量-例如："

msgid "Low-level message encoding"
msgstr "底層訊息編碼"

msgid ""
"To accomplish the above RPC mechanism, each command and response is encoded "
"into a binary format for transmission. This section describes the "
"transmission system."
msgstr "爲了實現上述RPC機制，每個命令和響應都被編碼成二進制格式進行傳輸。本節介紹這個傳輸系統。"

msgid "Message Blocks"
msgstr "訊息塊"

msgid ""
"All data sent from host to micro-controller and vice-versa are contained in "
"\"message blocks\". A message block has a two byte header and a three byte "
"trailer. The format of a message block is:"
msgstr "所有從主機到微控制器以及從微控制器到主機的數據都包含在 \"訊息塊 \"中。一個訊息塊有一個兩位元組的頭和一個三位元組的尾。資訊塊的格式如下："

msgid ""
"The length byte contains the number of bytes in the message block including "
"the header and trailer bytes (thus the minimum message length is 5 bytes). "
"The maximum message block length is currently 64 bytes. The sequence byte "
"contains a 4 bit sequence number in the low-order bits and the high-order "
"bits always contain 0x10 (the high-order bits are reserved for future use). "
"The content bytes contain arbitrary data and its format is described in the "
"following section. The crc bytes contain a 16bit CCITT "
"[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check) of the message "
"block including the header bytes but excluding the trailer bytes. The sync "
"byte is 0x7e."
msgstr ""
"長度位元組指示訊息塊中的位元組數，包括頭和尾的位元組（因此訊息的最短長度為5位元組）。目前最大的訊息塊長度為64位元組。序號位元組的低4位是序列號，高4位總是0x10（高4位保留給未來用）。內容位元組包含任意數據，其格式在下一節中描述。crc位元組包含訊息塊的16位CCITT[CRC](https://en.wikipedia.org/wiki/Cyclic_redundancy_check)，CRC計算包括頭位元組但不包括尾位元組。同步位元組為0x7e。"

msgid ""
"The format of the message block is inspired by "
"[HDLC](https://en.wikipedia.org/wiki/High-Level_Data_Link_Control) message "
"frames. Like in HDLC, the message block may optionally contain an additional"
" sync character at the start of the block. Unlike in HDLC, a sync character "
"is not exclusive to the framing and may be present in the message block "
"content."
msgstr ""
"訊息塊的格式是受[HDLC](https://en.wikipedia.org/wiki/High-"
"Level_Data_Link_Control)訊息幀的啓發。與HDLC一樣，訊息塊在開始時可以選擇包含一個額外的同步字元。與HDLC不同的是，同步字元並不專屬於框架，也可以出現在訊息塊內容中（不需要轉義）。"

msgid "Message Block Contents"
msgstr "訊息塊內容"

msgid ""
"Each message block sent from host to micro-controller contains a series of "
"zero or more message commands in its contents. Each command starts with a "
"[Variable Length Quantity](#variable-length-quantities) (VLQ) encoded "
"integer command-id followed by zero or more VLQ parameters for the given "
"command."
msgstr ""
"每個從主機發送至微控制器的訊息塊，其內容都包含一系列零個或多個訊息命令。每條命令以[可變長度數值](#variable-length-"
"quantities)(VLQ)編碼的整數command-id開始，後面是這個命令的零或多個VLQ參數。"

msgid ""
"As an example, the following four commands might be placed in a single "
"message block:"
msgstr "例如，以下四個命令可以被放在一個訊息塊中："

msgid "and encoded into the following eight VLQ integers:"
msgstr "並編碼為下面八個VLQ整數："

msgid ""
"In order to encode and parse the message contents, both the host and micro-"
"controller must agree on the command ids and the number of parameters each "
"command has. So, in the above example, both the host and micro-controller "
"would know that \"id_update_digital_out\" is always followed by two "
"parameters, and \"id_get_config\" and \"id_get_clock\" have zero parameters."
" The host and micro-controller share a \"data dictionary\" that maps the "
"command descriptions (eg, \"update_digital_out oid=%c value=%c\") to their "
"integer command-ids. When processing the data, the parser will know to "
"expect a specific number of VLQ encoded parameters following a given command"
" id."
msgstr ""
"爲了對資訊內容進行編解碼，主機和微控制器都必須確保使用的命令的ID和每個命令對應的參數數量一致。因此，在上面的例子中，主機和微控制器都知道 "
"\"id_update_digital_out \"後面總是跟著兩個參數，而 \"id_get_config \"和 \"id_get_clock "
"\"沒有參數。主機和微控制器共享一個 \"數據字典\"，這個數據字典將命令描述（例如，\"update_digital_out oid=%c "
"value=%c\"）對映到它們的整數命令ID。當處理數據時，解析器將知道一個給定的命令ID后預期有特定數量的VLQ編碼參數。"

msgid ""
"The message contents for blocks sent from micro-controller to host follow "
"the same format. The identifiers in these messages are \"response ids\", but"
" they serve the same purpose and follow the same encoding rules. In "
"practice, message blocks sent from the micro-controller to the host never "
"contain more than one response in the message block contents."
msgstr ""
"從微控制器發送到主機的塊的訊息內容遵循相同的格式。這些訊息中的識別符號是 "
"\"響應ID\"，但它們的作用相同，並遵循相同的編碼規則。事實上，從微控制器發送到主機的訊息塊在訊息塊內容中只包含一個響應。"

msgid "Variable Length Quantities"
msgstr "可變長度數值"

msgid ""
"See the [wikipedia article](https://en.wikipedia.org/wiki/Variable-"
"length_quantity) for more information on the general format of VLQ encoded "
"integers. Klipper uses an encoding scheme that supports both positive and "
"negative integers. Integers close to zero use less bytes to encode and "
"positive integers typically encode using less bytes than negative integers. "
"The following table shows the number of bytes each integer takes to encode:"
msgstr ""
"關於VLQ編碼的整數的一般格式的更多資訊，請參見[wikipedia "
"article](https://en.wikipedia.org/wiki/Variable-"
"length_quantity)。Klipper使用支援正負整數的編碼方案。接近零的整數使用較少的位元組來編碼，正整數的編碼通常比負整數的使用位元組更少。下表顯示了每個整數的編碼所需的位元組數："

msgid "Integer"
msgstr "整數"

msgid "Encoded size"
msgstr "編碼長度"

msgid "-32 .. 95"
msgstr "-32 .. 95"

msgid "1"
msgstr "1"

msgid "-4096 .. 12287"
msgstr "-4096 .. 12287"

msgid "2"
msgstr "2"

msgid "-524288 .. 1572863"
msgstr "-524288 .. 1572863"

msgid "3"
msgstr "3"

msgid "-67108864 .. 201326591"
msgstr "-67108864 .. 201326591"

msgid "4"
msgstr "4"

msgid "-2147483648 .. 4294967295"
msgstr "-2147483648 .. 4294967295"

msgid "5"
msgstr "5"

msgid "Variable length strings"
msgstr "可變長度字串"

msgid ""
"As an exception to the above encoding rules, if a parameter to a command or "
"response is a dynamic string then the parameter is not encoded as a simple "
"VLQ integer. Instead it is encoded by transmitting the length as a VLQ "
"encoded integer followed by the contents itself:"
msgstr ""
"作為上述編碼規則的例外，如果一個命令或響應的參數是一個動態字串，那麼該參數不會被編碼為一個簡單的VLQ整數。相反，它的編碼方式是將長度作為一個VLQ編碼的整數並跟著內容本身來傳輸："

msgid ""
"The command descriptions found in the data dictionary allow both the host "
"and micro-controller to know which command parameters use simple VLQ "
"encoding and which parameters use string encoding."
msgstr "在數據字典中的命令描述使主機和微控制器都知道哪些命令參數使用簡單的VLQ編碼，哪些參數使用字串編碼。"

msgid "Data Dictionary"
msgstr "數據字典"

msgid ""
"In order for meaningful communications to be established between micro-"
"controller and host, both sides must agree on a \"data dictionary\". This "
"data dictionary contains the integer identifiers for commands and responses "
"along with their descriptions."
msgstr "爲了在微控制器和主機之間建立有意義的通訊，雙方必須商定一個 \"數據字典\"。這個數據字典包含了命令和響應的整數識別符號及它們的描述。"

msgid ""
"The micro-controller build uses the contents of DECL_COMMAND() and sendf() "
"macros to generate the data dictionary. The build automatically assigns "
"unique identifiers to each command and response. This system allows both the"
" host and micro-controller code to seamlessly use descriptive human-readable"
" names while still using minimal bandwidth."
msgstr ""
"微控制器構建使用DECL_COMMAND()和sendf()宏的內容來產生數據字典。構建會自動為每個命令和響應分配唯一的識別符號。這個系統允許主機和微控制器程式碼既使用人類可讀的描述性名稱又佔用最小的傳輸頻寬。"

msgid ""
"The host queries the data dictionary when it first connects to the micro-"
"controller. Once the host downloads the data dictionary from the micro-"
"controller, it uses that data dictionary to encode all commands and to parse"
" all responses from the micro-controller. The host must therefore handle a "
"dynamic data dictionary. However, to keep the micro-controller software "
"simple, the micro-controller always uses its static (compiled in) data "
"dictionary."
msgstr ""
"當主機第一次連線到微控制器時，會查詢數據字典。一旦主機從微控制器中下載了數據字典，它就使用該數據字典對所有命令進行編碼，並解析來自微控制器的所有響應。因此，主機必須能處理動態的數據字典。然而，爲了保持微控制器軟體的簡單性，微控制器總是使用靜態（編譯的）數據字典。"

msgid ""
"The data dictionary is queried by sending \"identify\" commands to the "
"micro-controller. The micro-controller will respond to each identify command"
" with an \"identify_response\" message. Since these two commands are needed "
"prior to obtaining the data dictionary, their integer ids and parameter "
"types are hard-coded in both the micro-controller and the host. The "
"\"identify_response\" response id is 0, the \"identify\" command id is 1. "
"Other than having hard-coded ids the identify command and its response are "
"declared and transmitted the same way as other commands and responses. No "
"other command or response is hard-coded."
msgstr ""
"數據字典是通過向微控制器發送 \"identify\"命令來查詢的。微控制器將用一個 \"identify_response "
"\"訊息來回應每條識別命令。由於在獲取數據字典之前需要這兩條命令，它們的整數id和參數型別在微控制器和主機中都是硬編碼的。\"identify_response"
" "
"\"的響應id是0，\"identify\"的命令id是1。除了有硬編碼的id外，識別命令及其響應的聲明和傳輸方式與其他命令和響應相同。除此之外沒有其他命令或響應是硬編碼的。"

msgid ""
"The format of the transmitted data dictionary itself is a zlib compressed "
"JSON string. The micro-controller build process generates the string, "
"compresses it, and stores it in the text section of the micro-controller "
"flash. The data dictionary can be much larger than the maximum message block"
" size - the host downloads it by sending multiple identify commands "
"requesting progressive chunks of the data dictionary. Once all chunks are "
"obtained the host will assemble the chunks, uncompress the data, and parse "
"the contents."
msgstr ""
"傳輸的數據字典本身的格式是一個zlib壓縮的JSON字串。微控制器的構建過程會產生該字串，對其進行壓縮，並將其儲存在微控制器快閃記憶體的text部分。數據字典可以比最大的訊息塊大得多"
"--主機通過發送多個識別命令來分塊下載數據字典。一旦獲得所有的數據塊，主機將把這些數據塊組合起來，解壓縮數據並解析內容。"

msgid ""
"In addition to information on the communication protocol, the data "
"dictionary also contains the software version, enumerations (as defined by "
"DECL_ENUMERATION), and constants (as defined by DECL_CONSTANT)."
msgstr "除了通訊協議的資訊外，數據字典還包含軟體版本、列舉值（由DECL_ENUMERATION定義）和常量（由DECL_CONSTANT定義）。"

msgid "Message flow"
msgstr "訊息流"

msgid ""
"Message commands sent from host to micro-controller are intended to be "
"error-free. The micro-controller will check the CRC and sequence numbers in "
"each message block to ensure the commands are accurate and in-order. The "
"micro-controller always processes message blocks in-order - should it "
"receive a block out-of-order it will discard it and any other out-of-order "
"blocks until it receives blocks with the correct sequencing."
msgstr ""
"從主機到微控制器發送的資訊命令應該是無差錯的。微控制器將檢查每個資訊塊中的CRC和順序號，以確保命令的準確性和順序性。微控制器總是按順序處理資訊塊--"
"如果它收到一個不按順序的資訊塊，它將丟棄它和其他不按順序的資訊塊，直到它收到具有正確順序號的資訊塊。"

msgid ""
"The low-level host code implements an automatic retransmission system for "
"lost and corrupt message blocks sent to the micro-controller. To facilitate "
"this, the micro-controller transmits an \"ack message block\" after each "
"successfully received message block. The host schedules a timeout after "
"sending each block and it will retransmit should the timeout expire without "
"receiving a corresponding \"ack\". In addition, if the micro-controller "
"detects a corrupt or out-of-order block it may transmit a \"nak message "
"block\" to facilitate fast retransmission."
msgstr ""
"低層的主機程式碼為發送到微控制器的丟失和損壞的訊息塊實現了一個自動重傳系統。為此，微控制器在每次成功接收的訊息塊之後都會發送一個 \"ack "
"message block\"。主機在發送每個塊後會啟動超時等待，如果超時後沒有收到相應的 "
"\"ack\"，它將重新發送。此外，如果微控制器檢測到一個損壞或順序錯誤的塊，它可以發送一個 \"nak message block\"實現快速重傳。"

msgid ""
"An \"ack\" is a message block with empty content (ie, a 5 byte message "
"block) and a sequence number greater than the last received host sequence "
"number. A \"nak\" is a message block with empty content and a sequence "
"number less than the last received host sequence number."
msgstr ""
"「ack \"是一個內容為空的訊息塊（即一個5位元組的訊息塊），其順序號大於最後收到的主機訊息順序號。一個 \"nak "
"\"是一個內容為空的訊息塊，其順序號小於最後收到的主機訊息順序號。"

msgid ""
"The protocol facilitates a \"window\" transmission system so that the host "
"can have many outstanding message blocks in-flight at a time. (This is in "
"addition to the many commands that may be present in a given message block.)"
" This allows maximum bandwidth utilization even in the event of transmission"
" latency. The timeout, retransmit, windowing, and ack mechanism are inspired"
" by similar mechanisms in "
"[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)."
msgstr ""
"協議實現了 \"視窗 "
"\"傳輸系統，因此主機可以在同一時間允許多未完成的訊息塊在發送。(這是對一個訊息塊中可以包含多個命令的補充）。通過這種方式，即使在傳輸延遲的情況下也能最大化地利用頻寬。超時、重傳、視窗化和響應機制是受到[TCP](https://en.wikipedia.org/wiki/Transmission_Control_Protocol)中類似機制的啓發。"

msgid ""
"In the other direction, message blocks sent from micro-controller to host "
"are designed to be error-free, but they do not have assured transmission. "
"(Responses should not be corrupt, but they may go missing.) This is done to "
"keep the implementation in the micro-controller simple. There is no "
"automatic retransmission system for responses - the high-level code is "
"expected to be capable of handling an occasional missing response (usually "
"by re-requesting the content or setting up a recurring schedule of response "
"transmission). The sequence number field in message blocks sent to the host "
"is always one greater than the last received sequence number of message "
"blocks received from the host. It is not used to track sequences of response"
" message blocks."
msgstr ""
"另一方向，從微控制器發送到主機的資訊塊被設計成無差錯，但並不保證傳輸。(響應不會出錯，但可能會丟失。)這樣做是爲了保持微控制器的實現簡單。響應沒有自動重傳系統"
"--"
"高層程式碼應該能夠處理偶爾丟失的響應（通常通過重新請求內容或設定響應傳輸的循環排程）。發送給主機的資訊塊中的順序號欄位總是比從主機收到的資訊塊的最後接收順序號大1。順序號並不用於跟蹤響應訊息塊的順序。"

msgid ""
"set_digital_out pin=PA3 value=1\n"
"set_digital_out pin=PA7 value=1\n"
"schedule_digital_out oid=8 clock=4000000 value=0\n"
"queue_step oid=7 interval=7458 count=10 add=331\n"
"queue_step oid=7 interval=11717 count=4 add=1281\n"
msgstr ""
"set_digital_out pin=PA3 value=1\n"
"set_digital_out pin=PA7 value=1\n"
"schedule_digital_out oid=8 clock=4000000 value=0\n"
"queue_step oid=7 interval=7458 count=10 add=331\n"
"queue_step oid=7 interval=11717 count=4 add=1281\n"

msgid ""
"DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c "
"value=%c\");\n"
msgstr ""
"DECL_COMMAND(command_update_digital_out, \"update_digital_out oid=%c "
"value=%c\");\n"

msgid ""
"sendf(\"status clock=%u status=%c\", sched_read_time(), "
"sched_is_shutdown());\n"
msgstr ""
"sendf(\"status clock=%u status=%c\", sched_read_time(), "
"sched_is_shutdown());\n"

msgid "output(\"The value of %u is %s with size %u.\", x, buf, buf_len);\n"
msgstr "output(\"The value of %u is %s with size %u.\", x, buf, buf_len);\n"

msgid ""
"DECL_ENUMERATION(\"spi_bus\", \"spi\", 0);\n"
"\n"
"DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8);\n"
msgstr ""
"DECL_ENUMERATION(\"spi_bus\", \"spi\", 0);\n"
"\n"
"DECL_ENUMERATION_RANGE(\"pin\", \"PC0\", 16, 8);\n"

msgid "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"
msgstr "DECL_CONSTANT(\"SERIAL_BAUD\", 250000);\n"

msgid "DECL_CONSTANT_STR(\"MCU\", \"pru\");\n"
msgstr "DECL_CONSTANT_STR(\"MCU\", \"pru\");\n"

msgid ""
"<1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync>\n"
msgstr ""
"<1 byte length><1 byte sequence><n-byte content><2 byte crc><1 byte sync>\n"

msgid ""
"update_digital_out oid=6 value=1\n"
"update_digital_out oid=5 value=0\n"
"get_config\n"
"get_clock\n"
msgstr ""
"update_digital_out oid=6 value=1\n"
"update_digital_out oid=5 value=0\n"
"get_config\n"
"get_clock\n"

msgid ""
"<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock>\n"
msgstr ""
"<id_update_digital_out><6><1><id_update_digital_out><5><0><id_get_config><id_get_clock>\n"

msgid "<VLQ encoded length><n-byte contents>\n"
msgstr "<VLQ encoded length><n-byte contents>\n"

#: docs/Protocol.md:block 1 (header)
msgid "Protocol"
msgstr "協議"
