# Fred Chan <fred2088@gmail.com>, 2022.
msgid ""
msgstr ""
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"PO-Revision-Date: 2022-08-02 07:24+0000\n"
"Last-Translator: Fred Chan <fred2088@gmail.com>\n"
"Language-Team: Chinese (Traditional) <https://hosted.weblate.org/projects/klipper/code_overview/zh_Hant/>\n"
"Language: zh_Hant\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Weblate 4.14-dev\n"

msgid ""
"This document describes the overall code layout and major code flow of "
"Klipper."
msgstr "本文件將描述Klipper的程式碼總體結構和程式碼流。"

msgid "Directory Layout"
msgstr "資料夾結構"

msgid ""
"The **src/** directory contains the C source for the micro-controller code. "
"The **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, "
"**src/lpc176x/**, **src/pru/**, and **src/stm32/** directories contain "
"architecture specific micro-controller code. The **src/simulator/** contains"
" code stubs that allow the micro-controller to be test compiled on other "
"architectures. The **src/generic/** directory contains helper code that may "
"be useful across different architectures. The build arranges for includes of"
" \"board/somefile.h\" to first look in the current architecture directory "
"(eg, src/avr/somefile.h) and then in the generic directory (eg, "
"src/generic/somefile.h)."
msgstr ""
"**src/**包含微控制器的C原始碼。其中**src/atsam/**, **src/atsamd/**, **src/avr/**, "
"**src/linux/**, **src/lpc176x/**, **src/pru/**, and **src/stm32/** "
"為對應微處理器架構的原始碼。 **src/simulator/** "
"包含有用於交叉編譯、測試目標微處理器的程式碼。**src/generic/**為對不同架構均有用的程式碼。編譯\"board/somefile.h\"時，編譯器會優先使用"
" 架構特定的目錄 (即src/avr/somefile.h)隨後找尋通用目錄(即 src/generic/somefile.h)。"

msgid ""
"The **klippy/** directory contains the host software. Most of the host "
"software is written in Python, however the **klippy/chelper/** directory "
"contains some C code helpers. The **klippy/kinematics/** directory contains "
"the robot kinematics code. The **klippy/extras/** directory contains the "
"host code extensible \"modules\"."
msgstr ""
"**klippy/**目錄包含了上位機軟體。軟體大部分由Python實現，同時**klippy/chelper/** "
"目錄包含了由C實現的有用程式碼。**klippy/kinematics/**目錄包含機械運動學的實現程式碼。**klippy/extras/** "
"目錄包含了上位機的擴建模組(\"modules\")。"

msgid ""
"The **lib/** directory contains external 3rd-party library code that is "
"necessary to build some targets."
msgstr "**lib/**包含了構建必須的第三方庫程式碼。"

msgid ""
"The **config/** directory contains example printer configuration files."
msgstr "**config/**包含了印表機配置的實例檔案。"

msgid ""
"The **scripts/** directory contains build-time scripts useful for compiling "
"the micro-controller code."
msgstr "**scripts/**目錄包含了編譯微控制器程式碼時有用的指令碼。"

msgid "The **test/** directory contains automated test cases."
msgstr "**test/**目錄包含了自動測試示例。"

msgid ""
"During compilation, the build may create an **out/** directory. This "
"contains temporary build time objects. The final micro-controller object "
"that is built is **out/klipper.elf.hex** on AVR and **out/klipper.bin** on "
"ARM."
msgstr ""
"在編譯過程重，編譯器會構建**out/**目錄。該目錄包含構建時的臨時檔案。對於AVR架構，編譯器輸出的為**out/klipper.elf.hex**，而對ARM架構則為**out/klipper.bin**。"

msgid "Micro-controller code flow"
msgstr "微處理器的程式碼流"

msgid ""
"Execution of the micro-controller code starts in architecture specific code "
"(eg, **src/avr/main.c**) which ultimately calls sched_main() located in "
"**src/sched.c**. The sched_main() code starts by running all functions that "
"have been tagged with the DECL_INIT() macro. It then goes on to repeatedly "
"run all functions tagged with the DECL_TASK() macro."
msgstr ""
"微控制器的程式碼從對應架構的程式碼(即**src/avr/main.c**)開始執行，前述程式碼會持續呼叫**src/sched.c**中的 "
"sched_main() 函式。sched_main() 程式碼會先執行經 DECL_INIT() 宏標註的所有函式。之後它將不斷重複執行由 "
"DECL_TASK() 宏所標註的函式。"

msgid ""
"One of the main task functions is command_dispatch() located in "
"**src/command.c**. This function is called from the board specific "
"input/output code (eg, **src/avr/serial.c**, **src/generic/serial_irq.c**) "
"and it runs the command functions associated with the commands found in the "
"input stream. Command functions are declared using the DECL_COMMAND() macro "
"(see the [protocol](Protocol.md) document for more information)."
msgstr ""
"其中一個主要的任務函式為**src/command.c** 中的command_dispatch()。上述函式經由微處理器特定的 輸入/輸出 "
"程式碼呼叫(即**src/avr/serial.c**, "
"**src/generic/serial_irq.c**)，並執行輸入流中的命令所對應的命令函式。命令函式通過 DECL_COMMAND() 宏進行定義"
" (詳情參照[協議](Protocol.md) 文件)。"

msgid ""
"Timer functions are scheduled by calling sched_add_timer() (located in "
"**src/sched.c**). The scheduler code will arrange for the given function to "
"be called at the requested clock time. Timer interrupts are initially "
"handled in an architecture specific interrupt handler (eg, "
"**src/avr/timer.c**) which calls sched_timer_dispatch() located in "
"**src/sched.c**. The timer interrupt leads to execution of schedule timer "
"functions. Timer functions always run with interrupts disabled. The timer "
"functions should always complete within a few micro-seconds. At completion "
"of the timer event, the function may choose to reschedule itself."
msgstr ""
"定時函式通過呼叫sched_add_timer() (即 "
"**src/sched.c**)方法進行註冊。排程器會在設定的時間點對註冊的函式進行呼叫。定時器中斷會在微處理器架構特定的初始化處理器中處理(例如 "
"**src/avr/timer.c**)，該程式碼會呼叫 "
"**src/sched.c**中的sched_timer_dispatch()。通過定時器中斷執行註冊的定時函式。定時函式總在中斷禁用下執行。定時函式應總能在數微秒內完成。在定時函式結束時，該函式可對自身進行重新定時。"

msgid ""
"In the event an error is detected the code can invoke shutdown() (a macro "
"which calls sched_shutdown() located in **src/sched.c**). Invoking "
"shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
"run. Shutdown functions always run with interrupts disabled."
msgstr ""
"如果事件中拋出錯誤， "
"程式碼可呼叫shutdown()（**src/sched.c**中的sched_shutdown()）。呼叫shutdown()會導致所有標記為DECL_SHUTDOWN()宏的函式被執行。shutdown()總是在禁用中斷的情況下執行。"

msgid ""
"Much of the functionality of the micro-controller involves working with "
"General-Purpose Input/Output pins (GPIO). In order to abstract the low-level"
" architecture specific code from the high-level task code, all GPIO events "
"are implemented in architecture specific wrappers (eg, **src/avr/gpio.c**). "
"The code is compiled with gcc's \"-flto -fwhole-program\" optimization which"
" does an excellent job of inlining functions across compilation units, so "
"most of these tiny gpio functions are inlined into their callers, and there "
"is no run-time cost to using them."
msgstr ""
"微控制器的大部分功能涉及到通用輸入輸出引腳（GPIO）的操作。爲了從高級任務程式碼中抽像出特定架構底層程式碼，所有的GPIO事件都在特定架構的包裝器中實現（如，**src/avr/gpio.c**）。程式碼使用gcc的\"-flto"
" -fwhole-program "
"\"來優化編譯，以實現行內函數的高效能交叉編譯，大多數微小的GPIO操作函式內聯到它們的呼叫器中，使用這些GPIO將沒有任何執行時成本。"

msgid "Klippy code overview"
msgstr "程式碼總覽"

msgid ""
"The host code (Klippy) is intended to run on a low-cost computer (such as a "
"Raspberry Pi) paired with the micro-controller. The code is primarily "
"written in Python, however it does use CFFI to implement some functionality "
"in C code."
msgstr ""
"上位機程式（klippy）執行在廉價計算機（如 樹莓派）上，配搭mcu使用。該程式的主要程式語言為Python，同時部分功能通過CFFI在C語言上實現。"

msgid ""
"Initial execution starts in **klippy/klippy.py**. This reads the command-"
"line arguments, opens the printer config file, instantiates the main printer"
" objects, and starts the serial connection. The main execution of G-code "
"commands is in the process_commands() method in **klippy/gcode.py**. This "
"code translates the G-code commands into printer object calls, which "
"frequently translate the actions to commands to be executed on the micro-"
"controller (as declared via the DECL_COMMAND macro in the micro-controller "
"code)."
msgstr ""
"上位機程式通過** "
"klippy/klippy.py**初始化。該檔案會讀取命令列參數，打開印表機的設定檔案，實例化印表機的主要模組，並啟用串列埠通訊。G程式碼命令的執行則通過"
" **klippy/gcode.py**中的 process_commands() "
"方法實現。此程式碼將G程式碼轉化為印表機的對象呼叫，它將頻繁地將G程式碼命令轉化為微控制器的行動指令（通過微控制器程式碼中的 DECL_COMMAND "
"進行聲明）。"

msgid ""
"There are four threads in the Klippy host code. The main thread handles "
"incoming gcode commands. A second thread (which resides entirely in the "
"**klippy/chelper/serialqueue.c** C code) handles low-level IO with the "
"serial port. The third thread is used to process response messages from the "
"micro-controller in the Python code (see **klippy/serialhdl.py**). The "
"fourth thread writes debug messages to the log (see "
"**klippy/queuelogger.py**) so that the other threads never block on log "
"writes."
msgstr ""
"Klippy上位機程式包含四個程序。主執行緒用於處理輸入的G程式碼命令。第二執行緒通過串列埠實現底層IO的處理（程式碼位於 "
"**klippy/chelper/serialqueue.c **以C語言實現）。第三執行緒則通過Python程式碼處理微控制器返回的資訊（參照 "
"klippy/serialhdl.py）。第四執行緒則負責將Debug資訊寫入到日誌檔案(見 "
"**klippy/queuelogger.py**)，由此，其他執行緒的執行將不會阻塞日誌的寫入。"

msgid "Code flow of a move command"
msgstr "典型運動命令的程式碼流"

msgid ""
"A typical printer movement starts when a \"G1\" command is sent to the "
"Klippy host and it completes when the corresponding step pulses are produced"
" on the micro-controller. This section outlines the code flow of a typical "
"move command. The [kinematics](Kinematics.md) document provides further "
"information on the mechanics of moves."
msgstr ""
"典型的印表機運動始於klipper上位機接收到\"G1\"命令，並在微控制器發出對應的步進脈衝結束。本節將簡述典型運動命令的程式碼流。[運動學](Kinematics.md)文件將更為細緻的描述運動的機械原理。"

msgid ""
"Processing for a move command starts in gcode.py. The goal of gcode.py is to"
" translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
"klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
"origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
"unit changes (eg, F6000=100mm/s). The code path for a move is: "
"`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
"ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
"ToolHead.move()`"
msgstr ""
"移動命令的處理始於gcode.py，該程式碼將G程式碼轉化為內部呼叫。G1命令將呼叫klippy/extras/gcode_move.py中的cmd_G1()函式。gcode_move.py中的程式碼將處理"
" 原點變換（G92），絕對座標模式（G90）和單位變換（如F6000=100mm/s）。一個移動命令的處理路徑為：`_process_data() ->"
" _process_commands() -> cmd_G1()`。最終將呼叫ToolHead類的方法實現移動 `cmd_G1() -> "
"ToolHead.move()`。"

msgid ""
"The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the "
"timing of printing actions. The main codepath for a move is: "
"`ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> "
"Move.set_junction() -> ToolHead._process_moves()`."
msgstr ""
"ToolHead類（位於toolhead.py）處理「前瞻」行為和記錄列印的時間點。移動命令的程式碼路徑為 `ToolHead.move() -> "
"MoveQueue.add_move() -> MoveQueue.flush() -> Move.set_junction() -> "
"ToolHead._process_moves()`。"

msgid ""
"ToolHead.move() creates a Move() object with the parameters of the move (in "
"cartesian space and in units of seconds and millimeters)."
msgstr "ToolHead.move()將建立一個Move()對像實例，其中將包含移動的參數（在笛卡爾空間中，並這些參數以mm和s為單位）。"

msgid ""
"The kinematics class is given the opportunity to audit each move "
"(`ToolHead.move() -> kin.check_move()`). The kinematics classes are located "
"in the klippy/kinematics/ directory. The check_move() code may raise an "
"error if the move is not valid. If check_move() completes successfully then "
"the underlying kinematics must be able to handle the move."
msgstr ""
"kinematics類將檢查每個運動命令（`ToolHead.move() -> kin.check_move()`）。各種kinematics類存放于"
" klippy/kinematics/ 目錄。check_move()能在運動命令不合理時拋出錯誤。如果 "
"check_move()成功，這意味著印表機必定能完成運動命令。"

msgid "MoveQueue.add_move() places the move object on the \"look-ahead\" queue."
msgstr "MoveQueue.add_move()將一個move實例新增到「前瞻」佇列。"

msgid ""
"MoveQueue.flush() determines the start and end velocities of each move."
msgstr "MoveQueue.flush()將進行每次運動 起始和結束 速度。"

msgid ""
"Move.set_junction() implements the \"trapezoid generator\" on a move. The "
"\"trapezoid generator\" breaks every move into three parts: a constant "
"acceleration phase, followed by a constant velocity phase, followed by a "
"constant deceleration phase. Every move contains these three phases in this "
"order, but some phases may be of zero duration."
msgstr ""
"Move.set_junction()實現移動的「梯形加減速（trapezoid "
"generator）」。「梯形加減速」將每次移動拆分為三部分：恒加速度加速階段、恒速度階段、恒加速度減速階段。所有移動均含有上述三個階段，但單個階段的持續時間可能為0。"

msgid ""
"When ToolHead._process_moves() is called, everything about the move is known"
" - its start location, its end location, its acceleration, its "
"start/cruising/end velocity, and distance traveled during "
"acceleration/cruising/deceleration. All the information is stored in the "
"Move() class and is in cartesian space in units of millimeters and seconds."
msgstr ""
"當ToolHead._process_moves()被呼叫時，一次移動的所有要素均已就緒——移動的起始位置、結束位置、加速度、起始/巡航/結束速度、以及起始/巡航/結束的距離。所有資訊以笛卡爾座標的形式儲存在Move()實例中，單位為mm和s。"

msgid ""
"Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm) to generate the step times for each stepper. For "
"efficiency reasons, the stepper pulse times are generated in C code. The "
"moves are first placed on a \"trapezoid motion queue\": "
"`ToolHead._process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). "
"The step times are then generated: `ToolHead._process_moves() -> "
"ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
"itersolve_generate_steps() -> itersolve_gen_steps_range()` (in "
"klippy/chelper/itersolve.c). The goal of the iterative solver is to find "
"step times given a function that calculates a stepper position from a time. "
"This is done by repeatedly \"guessing\" various times until the stepper "
"position formula returns the desired position of the next step on the "
"stepper. The feedback produced from each guess is used to improve future "
"guesses so that the process rapidly converges to the desired time. The "
"kinematic stepper position formulas are located in the klippy/chelper/ "
"directory (eg, kin_cart.c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
msgstr ""
"Klipper使用[迭代求解](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm)的方式產生步進電機的每步的時長。爲了提高效率，步進脈衝時間是以C語言程式碼產生。一個運動先經過「梯形運動佇列化」 "
"：`ToolHead._process_moves() -> trapq_append()` (位於 "
"klippy/chelper/trapq.c)，然後產生步進時間 `ToolHead._process_moves() -> "
"ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
"itersolve_generate_steps() -> itersolve_gen_steps_range()` (位於 "
"klippy/chelper/itersolve.c)。迭代求解器通過一個時間-位置方程計算出步進時間。求解時通過「假定」時間點，以時間-"
"位置方程計算出下一步的位置。如果計算結果與實際需求的下一步位置一致，假定值將用於實際運動；否則，通過計算結果對「假定時間」進行修正，並進行下一次試算。這種反饋方式會使迭代快速收斂。運動學所使用的時間-"
"位置函式位於 klippy/chelper/ 目錄 (例如, kin_cart.c, kin_corexy.c, kin_delta.c, "
"kin_extruder.c)。"

msgid ""
"Note that the extruder is handled in its own kinematic class: "
"`ToolHead._process_moves() -> PrinterExtruder.move()`. Since the Move() "
"class specifies the exact movement time and since step pulses are sent to "
"the micro-controller with specific timing, stepper movements produced by the"
" extruder class will be in sync with head movement even though the code is "
"kept separate."
msgstr ""
"需要注意，擠出機有獨特的運動學模型，使用`ToolHead._process_moves() -> "
"PrinterExtruder.move()`類繼續寧處理。儘管擠出機使用了獨立的Move()類，由於Move() "
"實例包含了實際運動的時間，並且脈衝時間的裝置是定時發送到微控制器上，因此由擠出機類產生的步進運動將與列印頭的運動同步。"

msgid ""
"After the iterative solver calculates the step times they are added to an "
"array: `itersolve_gen_steps_range() -> stepcompress_append()` (in "
"klippy/chelper/stepcompress.c). The array (struct stepcompress.queue) stores"
" the corresponding micro-controller clock counter times for every step. Here"
" the \"micro-controller clock counter\" value directly corresponds to the "
"micro-controller's hardware counter - it is relative to when the micro-"
"controller was last powered up."
msgstr ""
"當迭代計算器計算出步進時長后，計算結果將被置於一個陣列中：`itersolve_gen_steps_range() -> "
"stepcompress_append()` (位於 klippy/chelper/stepcompress.c)。陣列(結構體 "
"stepcompress.queue)儲存每一步對應的微處理器時鐘計數器時間。上述的「微處理器計數器」的值指的是微處理器硬體上的計數器——其值基於微處理器最後一次上電而定。"

msgid ""
"The next major step is to compress the steps: `stepcompress_flush() -> "
"compress_bisect_add()` (in klippy/chelper/stepcompress.c). This code "
"generates and encodes a series of micro-controller \"queue_step\" commands "
"that correspond to the list of stepper step times built in the previous "
"stage. These \"queue_step\" commands are then queued, prioritized, and sent "
"to the micro-controller (via stepcompress.c:steppersync and "
"serialqueue.c:serialqueue)."
msgstr ""
"接下來重要的是，對步進數據進行壓縮： `stepcompress_flush() -> compress_bisect_add()` (位於 "
"klippy/chelper/stepcompress.c)。上述程式碼將基於前述的 步進時間列表 "
"產生和編碼一系列的微控制器\"queue_step\"（佇列步進）命令。這些\"queue_step\"命令將被佇列化，優先處理，併發送到微控制器中（上位機通過"
" stepcompress.c:steppersync；下位機通過serialqueue.c:serialqueue)）。"

msgid ""
"Processing of the queue_step commands on the micro-controller starts in "
"src/command.c which parses the command and calls `command_queue_step()`. The"
" command_queue_step() code (in src/stepper.c) just appends the parameters of"
" each queue_step command to a per stepper queue. Under normal operation the "
"queue_step command is parsed and queued at least 100ms before the time of "
"its first step. Finally, the generation of stepper events is done in "
"`stepper_event()`. It's called from the hardware timer interrupt at the "
"scheduled time of the first step. The stepper_event() code generates a step "
"pulse and then reschedules itself to run at the time of the next step pulse "
"for the given queue_step parameters. The parameters for each queue_step "
"command are \"interval\", \"count\", and \"add\". At a high-level, "
"stepper_event() runs the following, 'count' times: `do_step(); "
"next_wake_time = last_wake_time + interval; interval += add;`"
msgstr ""
"在微控制器，queue_step命令將經由 src/command.c 處理。改程式碼將對命令進行解釋，並呼叫 "
"`command_queue_step()`。command_queue_step()（位於src/stepper.c）將每個queue_step命令的參數附加到對應的步進佇列中。正常執行下，一「步」將在其執行前100ms被解釋並加入佇列。最後通過"
" "
"`stepper_event()`結束步進事件的產生。該程式碼會基於queue_step命令的參數產生步進脈衝，並安排下一次步進脈衝產生的時間。硬體定時器發出中斷，在設定的事件呼叫相應的stepper_event。queue_step命令的參數包含「間隔」、「計數」、「增量」。總體而言，stepper_event()將執行下列內容，「記錄時間」:"
" `do_step(); next_wake_time = last_wake_time + interval; interval += add;`"

msgid ""
"The above may seem like a lot of complexity to execute a movement. However, "
"the only really interesting parts are in the ToolHead and kinematic classes."
" It's this part of the code which specifies the movements and their timings."
" The remaining parts of the processing is mostly just communication and "
"plumbing."
msgstr ""
"上面的運動過程看似十分複雜。然而，真正需要注意的只有ToolHead（列印頭） 和 kinematic "
"（運動學）類，上述兩個類的程式碼確定了運動執行和定時。剩下的程式碼僅用於處理通訊和管道的問題。"

msgid "Adding a host module"
msgstr "新增上位機模組"

msgid ""
"The Klippy host code has a dynamic module loading capability. If a config "
"section named \"[my_module]\" is found in the printer config file then the "
"software will automatically attempt to load the python module "
"klippy/extras/my_module.py . This module system is the preferred method for "
"adding new functionality to Klipper."
msgstr ""
"Klippy上位機的主程式能對模組進行熱載入。如果設定檔案中出現了類似\"[my_module]\" 的欄位名，程式會自動嘗試載入 "
"klippy/extras/my_module.py 檔案內的模組。Klipper推薦使用上述方式擴充套件Klipper功能。"

msgid ""
"The easiest way to add a new module is to use an existing module as a "
"reference - see **klippy/extras/servo.py** as an example."
msgstr "新增模組的最簡單的方式是參照已有的模組 - 下面將以 **klippy/extras/servo.py **作為例子。"

msgid "The following may also be useful:"
msgstr "下面是另一些有用的資訊："

msgid ""
"Execution of the module starts in the module level `load_config()` function "
"(for config sections of the form [my_module]) or in `load_config_prefix()` "
"(for config sections of the form [my_module my_name]). This function is "
"passed a \"config\" object and it must return a new \"printer object\" "
"associated with the given config section."
msgstr ""
"模組的運作起始於模組級別的`load_config()`函式（針對形如 [my_module] "
"的配置塊）或`load_config_prefix()`（對 [my_module my_name] 配置塊）。該方法將接受一個 \"config\" "
"對象並必須返回一個與目標功能相關的新\"printer object\"。"

msgid ""
"During the process of instantiating a new printer object, the config object "
"can be used to read parameters from the given config section. This is done "
"using `config.get()`, `config.getfloat()`, `config.getint()`, etc. methods. "
"Be sure to read all values from the config during the construction of the "
"printer object - if the user specifies a config parameter that is not read "
"during this phase then it will be assumed it is a typo in the config and an "
"error will be raised."
msgstr ""
"在建立新\"printer object\"的實例時，可以使用\"config\"對像讀取配置檔案中相應配置塊中的資訊。此時可使用 "
"`config.get()`，`config.getfloat()`， `config.getint()`等方法。應確保所需的參數在 \"printer"
" object\" 構建階段時完成讀取。如果使用者參數沒有在該階段完成讀取，程式將認為這是配置中的錯字，並拋出異常。"

msgid ""
"Use the `config.get_printer()` method to obtain a reference to the main "
"\"printer\" class. This \"printer\" class stores references to all the "
"\"printer objects\" that have been instantiated. Use the "
"`printer.lookup_object()` method to find references to other printer "
"objects. Almost all functionality (even core kinematic modules) are "
"encapsulated in one of these printer objects. Note, though, that when a new "
"module is instantiated, not all other printer objects will have been "
"instantiated. The \"gcode\" and \"pins\" modules will always be available, "
"but for other modules it is a good idea to defer the lookup."
msgstr ""
"使用 `config.get_printer()` "
"方法獲取主\"printer\"類的引用。該\"printer\"類儲存了所有實例化了的\"printer "
"objects\"的引用。使用`printer.lookup_object()`方法獲取其他\"printer "
"objects\"的引用。幾乎全部的功能（包括運動控制模組）都包裝為\"printer "
"objects\"。需要注意的是，當一個新模組實例化的時候，並非所有其他的\"printer "
"objects\"均已完成實例化。其中\"gcode\"和\"pins\"模組總是可用，但對於其他模組最好推遲查詢。"

msgid ""
"Register event handlers using the `printer.register_event_handler()` method "
"if the code needs to be called during \"events\" raised by other printer "
"objects. Each event name is a string, and by convention it is the name of "
"the main source module that raises the event along with a short name for the"
" action that is occurring (eg, \"klippy:connect\"). The parameters passed to"
" each event handler are specific to the given event (as are exception "
"handling and execution context). Two common startup events are:"
msgstr ""
"如果程式碼需要在其他\"printer "
"objects\"發起事件（event）時被呼叫，可通過`printer.register_event_handler()`註冊事件處理函式。每個事件的名稱是一個字串，按照慣例，它是引發該事件的主要源模組的名稱，以及正在發生的動作的簡短名稱（例如，\"klippy:connect\"）。傳遞給事件處理函式的參數因處理函式而異（異常處理和執行環境也是如此）。常見的兩種起始事件為："

msgid ""
"klippy:connect - This event is generated after all printer objects are "
"instantiated. It is commonly used to lookup other printer objects, to verify"
" config settings, and to perform an initial \"handshake\" with printer "
"hardware."
msgstr ""
"klippy:connect - 該事件在所有 \"printer objects\" 實例化后發起。它通常用於查詢其他\"printer "
"objects\"，覈實配置，並與mcu進行初始握手。"

msgid ""
"klippy:ready - This event is generated after all connect handlers have "
"completed successfully. It indicates the printer is transitioning to a state"
" ready to handle normal operations. Do not raise an error in this callback."
msgstr ""
"klippy:ready - 該事件在所有connect處理程式成功地完成後發起。它意味著印表機轉為等待常規指令的待命狀態。不應在該回調函式中拋出異常。"

msgid ""
"If there is an error in the user's config, be sure to raise it during the "
"`load_config()` or \"connect event\" phases. Use either `raise "
"config.error(\"my error\")` or `raise printer.config_error(\"my error\")` to"
" report the error."
msgstr ""
"如果使用者配置中存在錯誤，應在`load_config()`或連線事件（connect event）中拋出異常。使用 `raise "
"config.error(\"my error\")` 或 `raise printer.config_error(\"my error\")` "
"進行告警。"

msgid ""
"Use the \"pins\" module to configure a pin on a micro-controller. This is "
"typically done with something similar to "
"`printer.lookup_object(\"pins\").setup_pin(\"pwm\", "
"config.get(\"my_pin\"))`. The returned object can then be commanded at run-"
"time."
msgstr ""
"使用\"pins\"模組對微控制器的引腳進行定義，例如`printer.lookup_object(\"pins\").setup_pin(\"pwm\","
" config.get(\"my_pin\"))`。此後，執行時，可通過返回的對象對針腳進行控制。"

msgid ""
"If the module needs access to system timing or external file descriptors "
"then use `printer.get_reactor()` to obtain access to the global \"event "
"reactor\" class. This reactor class allows one to schedule timers, wait for "
"input on file descriptors, and to \"sleep\" the host code."
msgstr ""
"如果模組需要使用系統時鐘或外部檔案描述符，可通過`printer.get_reactor()`對獲取全域性事件反應器進行訪問（event "
"reactor）。通過該反應器類可以部署定時器，等待檔案描述符輸入，或者「掛起」上位機程式。"

msgid ""
"Do not use global variables. All state should be stored in the printer "
"object returned from the `load_config()` function. This is important as "
"otherwise the RESTART command may not perform as expected. Also, for similar"
" reasons, if any external files (or sockets) are opened then be sure to "
"register a \"klippy:disconnect\" event handler and close them from that "
"callback."
msgstr ""
"不應使用全域性變數。全部狀態量應儲存于 \"printer objects\"，並通過 "
"`load_config()`進行訪問。否則，RESTART命令的行為將無法預測。同樣，任何在執行時打開的外部檔案（或套接字），應在\"klippy:disconnect\"的事件內註冊相應的回撥函式進行關閉。"

msgid ""
"Avoid accessing the internal member variables (or calling methods that start"
" with an underscore) of other printer objects. Observing this convention "
"makes it easier to manage future changes."
msgstr "應避免訪問其他\"printer objects\"私有對象屬性（或呼叫命名以下劃線開始的方法）。遵循這一方式可方便之後的變更。"

msgid ""
"If submitting the module for inclusion in the main Klipper code, be sure to "
"place a copyright notice at the top of the module. See the existing modules "
"for the preferred format."
msgstr "若需向 klipper 母分支提交模組的程式碼，請在模組程式碼的頭部加入版權聲明。詳請參考已有模組的格式。"

msgid "Adding new kinematics"
msgstr "增加新運動學模型"

msgid ""
"This section provides some tips on adding support to Klipper for additional "
"types of printer kinematics. This type of activity requires excellent "
"understanding of the math formulas for the target kinematics. It also "
"requires software development skills - though one should only need to update"
" the host software."
msgstr ""
"本節將提供為Klipper增加新運動學模型的提示。這需要對目標運動學方程有深入的瞭解。這同時需要一定的軟件開發技巧——儘管人們應該只需要更新上位機軟體。"

msgid "Useful steps:"
msgstr "步驟："

msgid ""
"Start by studying the \"[code flow of a move](#code-flow-of-a-move-"
"command)\" section and the [Kinematics document](Kinematics.md)."
msgstr ""
"開始應研究 \"[移動命令的程式碼流](#code-flow-of-a-move-command)\" 章節和 "
"[動力學文件](Kinematics.md)."

msgid ""
"Review the existing kinematic classes in the klippy/kinematics/ directory. "
"The kinematic classes are tasked with converting a move in cartesian "
"coordinates to the movement on each stepper. One should be able to copy one "
"of these files as a starting point."
msgstr ""
"參考位於klippy/kinematics/目錄已有的運動學類。動力學類旨在將一個笛卡爾座標系中的運動轉化為各個步進電機的運動。建議複製已有的程式碼，並在其基礎上進行修改。"

msgid ""
"Implement the C stepper kinematic position functions for each stepper if "
"they are not already available (see kin_cart.c, kin_corexy.c, and "
"kin_delta.c in klippy/chelper/). The function should call `move_get_coord()`"
" to convert a given move time (in seconds) to a cartesian coordinate (in "
"millimeters), and then calculate the desired stepper position (in "
"millimeters) from that cartesian coordinate."
msgstr ""
"若需要的運動學方程未被Klipper涵蓋，則應使用C語言實現新動力學體系中各個步進電機的位置方程（見klippy/chelper/，如kin_cart.c,"
" kin_corexy.c, and kin_delta.c）。位置方程中應呼叫`move_get_coord()`以將運動的時間點（單位 "
"：秒）轉化為對應的笛卡爾座標位置（單位：毫米），進而計算目標步進電機運動目標位置（單位：毫米）。"

msgid ""
"Implement the `calc_position()` method in the new kinematics class. This "
"method calculates the position of the toolhead in cartesian coordinates from"
" the position of each stepper. It does not need to be efficient as it is "
"typically only called during homing and probing operations."
msgstr ""
"在新的運動學類中實現`calc_position`方法。該方法將通過各個步進電機的位置計算笛卡爾座標系下的列印頭位置；同時該方法通常只在回零和z探測時使用，因此無需過分追求效率。"

msgid ""
"Other methods. Implement the `check_move()`, `get_status()`, "
"`get_steppers()`, `home()`, and `set_position()` methods. These functions "
"are typically used to provide kinematic specific checks. However, at the "
"start of development one can use boiler-plate code here."
msgstr ""
"之後實現`check_move()`, `get_status()`, `get_steppers()`, `home()`, "
"`set_position()`方法。這些函式用於特定的運動學檢查。在開發的初期，可以直接使用已有程式碼。"

msgid ""
"Implement test cases. Create a g-code file with a series of moves that can "
"test important cases for the given kinematics. Follow the [debugging "
"documentation](Debugging.md) to convert this g-code file to micro-controller"
" commands. This is useful to exercise corner cases and to check for "
"regressions."
msgstr ""
"新增測試實例。建立一個G程式碼檔案，其中包含一系列的運動命令用於測試新增的運動學模型。 按照[除錯文件](Debugging.md)將該G程式碼檔案轉換為微控制器命令。在遭遇困難狀況和檢查數據傳遞相當有用。"

msgid "Porting to a new micro-controller"
msgstr "移植到新的微控制器"

msgid ""
"This section provides some tips on porting Klipper's micro-controller code "
"to a new architecture. This type of activity requires good knowledge of "
"embedded development and hands-on access to the target micro-controller."
msgstr "該節將介紹將Klipper微控制器程式碼移植到新架構時的一些提示。該操作將需要對嵌入式開發有一定的認識並應有目標微控制器的開發平臺。"

msgid ""
"Start by identifying any 3rd party libraries that will be used during the "
"port. Common examples include \"CMSIS\" wrappers and manufacturer \"HAL\" "
"libraries. All 3rd party code needs to be GNU GPLv3 compatible. The 3rd "
"party code should be committed to the Klipper lib/ directory. Update the "
"lib/README file with information on where and when the library was obtained."
" It is preferable to copy the code into the Klipper repository unchanged, "
"but if any changes are required then those changes should be listed "
"explicitly in the lib/README file."
msgstr ""
"首先應確定移植所需的第三方庫。常見的例子為「CMSIS」包裝器和廠商的「HAL」庫。全部第三方程式碼應遵循或相容GNU "
"GPLv3協議。第三方程式碼應提交到Klipper的/lib資料夾。更新lib/README註明第三方庫的獲取途徑和更新時間。推薦不改變內容，直接將程式碼複製到Klipper，但如果需要進行變更，應將所做的修改列在lib/README檔案中。"

msgid ""
"Create a new architecture sub-directory in the src/ directory and add "
"initial Kconfig and Makefile support. Use the existing architectures as a "
"guide. The src/simulator provides a basic example of a minimum starting "
"point."
msgstr ""
"在src/下新建一個新架構的子目錄，並建立對應的初始Kconfig和Makefile。以已有的架構作為模版，其中src/simulator給出了微控制器架構的基本需求。"

msgid ""
"Get familiar with the the console.py tool (as described in the [debugging "
"document](Debugging.md)) and verify connectivity to the micro-controller "
"with it. This tool translates the low-level micro-controller communication "
"protocol to a human readable form."
msgstr ""
"依照[除錯文件](Debugging.md)熟悉console.py工具，並使用該工具覈實微控制器的連線。該工具將底層微控制器通訊協議轉換為可讀形式。"

msgid ""
"Create a sample Klipper config file in the config/ directory. Test the "
"micro-controller with the main klippy.py program."
msgstr "在config/目錄新建一個配置事例，並使用Klipper.py的主程式進行設定。"

msgid "Consider adding build test cases in the test/ directory."
msgstr "考慮在test/目錄加入構建測試的事例。"

msgid "Coordinate Systems"
msgstr "座標系變換"

msgid ""
"Internally, Klipper primarily tracks the position of the toolhead in "
"cartesian coordinates that are relative to the coordinate system specified "
"in the config file. That is, most of the Klipper code will never experience "
"a change in coordinate systems. If the user makes a request to change the "
"origin (eg, a `G92` command) then that effect is obtained by translating "
"future commands to the primary coordinate system."
msgstr ""
"內部而言，Klipper使用笛卡爾座標系追蹤列印頭的位置，其座標系設定相對於設定檔案中的座標系而變化。因此，KIlipper的執行在絕大部分情況下都不會變換座標系。如果使用者進行原點的變換（如執行`G92`命令），Klipper會將後續命令轉化到原始座標系上進行執行。"

msgid ""
"However, in some cases it is useful to obtain the toolhead position in some "
"other coordinate system and Klipper has several tools to facilitate that. "
"This can be seen by running the GET_POSITION command. For example:"
msgstr ""
"然而，在部分情況下，需要獲取其他座標系中列印頭的位置。Klipper提供數種工具以實現上述功能。執行GET_POSITION可以獲得上述數據，如："

msgid ""
"The \"stepper\" position (`stepper.get_commanded_position()`) is the "
"position of the given stepper as tracked by the kinematics code. This "
"generally corresponds to the position (in mm) of the carriage along its "
"rail, relative to the position_endstop specified in the config file. (Some "
"kinematics track stepper positions in radians instead of millimeters.) If "
"the robot is in motion when the query is issued then the reported value "
"includes moves buffered on the micro-controller, but does not include moves "
"on the look-ahead queue. One may use the `toolhead.flush_step_generation()` "
"or `toolhead.wait_moves()` calls to fully flush the look-ahead and step "
"generation code."
msgstr ""
"「步進電機」部分（`stepper.get_commanded_position()`）是運動學模型中記錄的特定步進電機位置。通常是對應軌道的相對於設定中的position_endstop設定值的滑車位置（單位為毫米，但部分設定中使用的是弧度單位而非線性單位）。如果在機械運動時觸發上述程式碼，則返回的值為微控制器中快取的位置，而不包含預計佇列（look-"
"ahead "
"queue）中的預計位置。可使用`toolhead.flush_step_generation()`或`toolhead.wati_moves()`呼叫完全重新整理預計佇列和步進脈衝產生程式碼。"

msgid ""
"The \"kinematic\" position (`kin.calc_position()`) is the cartesian position"
" of the toolhead as derived from \"stepper\" positions and is relative to "
"the coordinate system specified in the config file. This may differ from the"
" requested cartesian position due to the granularity of the stepper motors. "
"If the robot is in motion when the \"stepper\" positions are taken then the "
"reported value includes moves buffered on the micro-controller, but does not"
" include moves on the look-ahead queue. One may use the "
"`toolhead.flush_step_generation()` or `toolhead.wait_moves()` calls to fully"
" flush the look-ahead and step generation code."
msgstr ""
"運動學位置（`kin.cal_position()`）是在笛卡爾座標上的，衍生於步進電機位置的，相對於設定檔案中position_endstop值的位置。由於步進電機的解析度原因，這可能與請求的笛卡爾座標值不一致。如果在機械運動時觸發上述程式碼，則返回的值為微控制器中快取的位置，而不包含預計佇列（look-"
"ahead "
"queue）中的預計位置。可使用`toolhead.flush_step_generation()`或`toolhead.wati_moves()`呼叫完全重新整理預計佇列和步進脈衝產生程式碼。"

msgid ""
"The \"toolhead\" position (`toolhead.get_position()`) is the last requested "
"position of the toolhead in cartesian coordinates relative to the coordinate"
" system specified in the config file. If the robot is in motion when the "
"query is issued then the reported value includes all requested moves (even "
"those in buffers waiting to be issued to the stepper motor drivers)."
msgstr ""
"列印頭位置（`toolhead.get_position()`）是最後的運動請求對應的，相對於設定檔案限位位置的，笛卡爾座標上的列印頭位置。如果在機械運動時觸發上述程式碼，那麼返回值會依據請求運動序列中的運動終點給出（儘管buffer中的運動還沒由步進電機觸發）。"

msgid ""
"The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
"command in cartesian coordinates relative to the coordinate system specified"
" in the config file. This may differ from the \"toolhead\" position if a "
"g-code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in "
"effect. This may differ from the actual coordinates specified in the last "
"`G1` command if the g-code origin has been changed (eg, `G92`, "
"`SET_GCODE_OFFSET`, `M221`). The `M114` command "
"(`gcode_move.get_status()['gcode_position']`) will report the last g-code "
"position relative to the current g-code coordinate system."
msgstr ""
"G程式碼位置時最後一次位置請求命令（`G1`或`G0`）對應的，在笛卡爾座標系中相對設定檔案中的設定原點的相對位置。這可能與「列印頭位置」不一致，這是因為G程式碼修正的影響（比如床網，床傾角修正，調平螺母修正）。這也會因為G程式碼原點變更（如`G92`，`SET_GCODE_OFFSET`，`M221`）而導致返回值跟最後一次`G1`命令請求的位置不一致。`Ｍ114`命令（`gcode_move.get_status()[』gcode_position』]`）會返回現時G程式碼相對於此時的G程式碼原點的位置。"

msgid ""
"The \"gcode base\" is the location of the g-code origin in cartesian "
"coordinates relative to the coordinate system specified in the config file. "
"Commands such as `G92`, `SET_GCODE_OFFSET`, and `M221` alter this value."
msgstr ""
"G程式碼基準是笛卡爾座標系中相對於設定檔案中的設定原點的相對位置。諸如`G92`，`SET_GCODE_OFFSET`和`M221`會改變的返回值。"

msgid ""
"The \"gcode homing\" is the location to use for the g-code origin (in "
"cartesian coordinates relative to the coordinate system specified in the "
"config file) after a `G28` home command. The `SET_GCODE_OFFSET` command can "
"alter this value."
msgstr ""
"G程式碼回零點是在`G28`命令執行后G程式碼原點。同樣，該位置是笛卡爾座標系中，相對於設定檔案原點的位置。`SET_GCODE_OFFSET`命令會改變該值。"

msgid "Time"
msgstr "定時"

msgid ""
"Fundamental to the operation of Klipper is the handling of clocks, times, "
"and timestamps. Klipper executes actions on the printer by scheduling events"
" to occur in the near future. For example, to turn on a fan, the code might "
"schedule a change to a GPIO pin in a 100ms. It is rare for the code to "
"attempt to take an instantaneous action. Thus, the handling of time within "
"Klipper is critical to correct operation."
msgstr ""
"該節將描述Klipper如何處理時鐘，定時和時間戳。Klipper通過提前安排需要執行的行為事件從而執行動作。例如，要啟動風扇，程式碼需要安排GPIO針腳在100ms后變化。程式碼立即執行動作反而是罕見的狀況。因此，Klipper的正確執行離不開對時間的精確處理。"

msgid ""
"There are three types of times tracked internally in the Klipper host "
"software:"
msgstr "Klipper內部使用三種不同的時間："

msgid ""
"System time. The system time uses the system's monotonic clock - it is a "
"floating point number stored as seconds and it is (generally) relative to "
"when the host computer was last started. System times have limited use in "
"the software - they are primarily used when interacting with the operating "
"system. Within the host code, system times are frequently stored in "
"variables named *eventtime* or *curtime*."
msgstr ""
"系統時間（System "
"time）。系統時間使用系統的單調時鐘。這是一個以秒為單位儲存的浮點數，在系統啟動后開始累計。系統時鐘的用途有限，通常只會在與操作系統進行互動時使用。在上位機中，系統時間儲存在*eventtime*或*curtime*變數中。"

msgid ""
"Print time. The print time is synchronized to the main micro-controller "
"clock (the micro-controller defined in the \"[mcu]\" config section). It is "
"a floating point number stored as seconds and is relative to when the main "
"mcu was last restarted. It is possible to convert from a \"print time\" to "
"the main micro-controller's hardware clock by multiplying the print time by "
"the mcu's statically configured frequency rate. The high-level host code "
"uses print times to calculate almost all physical actions (eg, head "
"movement, heater changes, etc.). Within the host code, print times are "
"generally stored in variables named *print_time* or *move_time*."
msgstr ""
"列印時間（Print "
"time）。列印時間會與主微控制器時鐘同步（在「[MCU]」設定段中定義的微控制器。）這是一個以秒為單位儲存的浮點數，並在主微控制最後一次啟動后開始從0累加。通過乘以設定的微控制器頻率，可以獲得主微控制器內部硬體時鐘值。上層應用可以通過列印時間計算幾乎所有物理行為（比如列印頭運動，加熱器變動等）。在上位機程式碼中，列印時間通常儲存在*print_time*和*move_time*變數中。"

msgid ""
"MCU clock. This is the hardware clock counter on each micro-controller. It "
"is stored as an integer and its update rate is relative to the frequency of "
"the given micro-controller. The host software translates its internal times "
"to clocks before transmission to the mcu. The mcu code only ever tracks time"
" in clock ticks. Within the host code, clock values are tracked as 64bit "
"integers, while the mcu code uses 32bit integers. Within the host code, "
"clocks are generally stored in variables with names containing *clock* or "
"*ticks*."
msgstr ""
"MCU時鐘，是各個微控制內部的硬體時鐘累加器。它是基於微控制器設定頻率為速率進行累加的，以整形儲存的值。上位機軟體將軟體內部時間轉換為mcu時間並將命令傳輸到微控制器上。微控制程式碼僅在時鐘跳動時更新和追蹤時間。在上位機程式碼中，時鐘值以64位整形記錄，而微控制程式碼則使用32位整形。在上位機程式碼中，時鐘通常以*clock*或*tick*變數儲存。"

msgid ""
"Conversion between the different time formats is primarily implemented in "
"the **klippy/clocksync.py** code."
msgstr "不同時鐘格式的轉換主要在**klipper/clocksync.py**中實現。"

msgid "Some things to be aware of when reviewing the code:"
msgstr "在檢查程式碼時需要注意："

msgid ""
"32bit and 64bit clocks: To reduce bandwidth and to improve micro-controller "
"efficiency, clocks on the micro-controller are tracked as 32bit integers. "
"When comparing two clocks in the mcu code, the `timer_is_before()` function "
"must always be used to ensure integer rollovers are handled properly. The "
"host software converts 32bit clocks to 64bit clocks by appending the high-"
"order bits from the last mcu timestamp it has received - no message from the"
" mcu is ever more than 2^31 clock ticks in the future or past so this "
"conversion is never ambiguous. The host converts from 64bit clocks to 32bit "
"clocks by simply truncating the high-order bits. To ensure there is no "
"ambiguity in this conversion, the **klippy/chelper/serialqueue.c** code will"
" buffer messages until they are within 2^31 clock ticks of their target "
"time."
msgstr ""
"32位和64位時鐘：爲了降低頻寬消耗和提高微控制器效率，微控制器時鐘使用32位整形進行追蹤。在微控制器程式碼中對比兩個時鐘時，應保持呼叫`time_is_before`以確定整形時鐘沒有出現溢出的情況。上位機軟體通過將微控制器最後一次返回的時間戳累加到主機程式碼時鐘的高位地址中，以實現32位時鐘到64位時鐘的轉換，由於來自微控制器的資訊不可能來自2^31個時間刻度的過去或未來，因此時間轉換不會出現錯誤。主機通過簡單截斷高位中的值，實現64位到32位的轉換。爲了確保轉換沒有歧義，**klippy/chelper/serialqueque.c**程式碼會快取資訊直到程式碼目標時間的2^31個時間刻度內。"

msgid ""
"Multiple micro-controllers: The host software supports using multiple micro-"
"controllers on a single printer. In this case, the \"MCU clock\" of each "
"micro-controller is tracked separately. The clocksync.py code handles clock "
"drift between micro-controllers by modifying the way it converts from "
"\"print time\" to \"MCU clock\". On secondary mcus, the mcu frequency that "
"is used in this conversion is regularly updated to account for measured "
"drift."
msgstr ""
"複數微控制器的情況：上位機軟體支援單體印表機使用複數微控制器。此時，各微控制器的「微控制器時鐘」將被分開記錄。clocksync.py處理微處理器之間的時間飄變，方法在「列印時間」和「微處理器時間」的轉換方法上修改得出。在次要微處理上，微處理器頻率被用於上述處理，並通過持續測量漂變對次要微控制器頻率進行更新。"

msgid ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"
msgstr ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"

#: docs/Code_Overview.md:block 1 (header)
msgid "Code overview"
msgstr "程式碼總覽"

#: docs/Code_Overview.md:block 43 (paragraph)
msgid ""
"The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
" number of steps the micro-controller has issued in a positive direction "
"minus the number of steps issued in a negative direction since the micro-"
"controller was last reset. If the robot is in motion when the query is "
"issued then the reported value includes moves buffered on the micro-"
"controller, but does not include moves on the look-ahead queue."
msgstr ""
"「微控制器位置」（`stepper.get_mcu_position()`）是微控制器最後一次重置后執行的「正向」步數總數 - "
"「負向」步數總數的值。如果裝置處於機械運動時，該方法將返回包含運動緩衝區中的位置值，但不包含預計佇列中的運動值。"

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Add support for timer dispatch from hardware interrupts. See Klipper [commit"
" "
"970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
" as an example of steps 1-5 done for the LPC176x architecture."
msgstr ""
"增加對硬體中斷的定時器排程的支援。參見 Klipper [commit "
"970831ee](https://github.com/Klipper3d/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)，作為針對LPC176x架構的步驟1-5的例子。"

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up basic GPIO input and output support. See Klipper [commit "
"c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
" as an example of this."
msgstr ""
"提供基本的 GPIO 輸入和輸出支援。參見 Klipper [commit "
"c78b9076](https://github.com/Klipper3d/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
" 作為一個例子。"

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up additional peripherals - for example see Klipper commit "
"[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
" "
"[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
" and "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
msgstr ""
"啟動其他外圍裝置-"
"參閱Klipper提交[65613aed](https://github.com/Klipper3d/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27)，[c812a40a](https://github.com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5)，和[c381d03a](https://github.com/Klipper3d/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)的例子。"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If the printer object defines a `get_status()` method then the module can "
"export [status information](Status_Reference.md) via "
"[macros](Command_Templates.md) and via the [API Server](API_Server.md). The "
"`get_status()` method must return a Python dictionary with keys that are "
"strings and values that are integers, floats, strings, lists, dictionaries, "
"True, False, or None. Tuples (and named tuples) may also be used (these "
"appear as lists when accessed via the API Server). Lists and dictionaries "
"that are exported must be treated as \"immutable\" - if their contents "
"change then a new object must be returned from `get_status()`, otherwise the"
" API Server will not detect those changes."
msgstr ""
"如果印表機對像中定義了 `get_status()` "
"方法，則在模組中可以通過[宏](Command_Templates.md)或[API服務](API_Server.md)輸出[狀態資訊](Status_Reference.md)。"
" `get_status()` "
"必須返回一個Python字典對象，其鍵需要為字串，而值應為整形、浮點數、列表、字典、True、False或者None。元組（或命名元組）也可以作為值（它們在API服務中將被視為列表）。列表和字典的輸出值必須為「不可變的（immutable）」，即在函式內，如果"
" `get_status()` 需要輸出上述型別的實例，則需要新建或者進行深層複製，否則API服務會識別出輸出值中的內容變更。"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"It is recommended to assign a value to all member variables in the Python "
"constructor of Python classes. (And therefore avoid utilizing Python's "
"ability to dynamically create new member variables.)"
msgstr "推薦在類的工廠函式中將所有成員變數實例化（即避免使用Python的動態變動成員變數的功能）。"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If a Python variable is to store a floating point value then it is "
"recommended to always assign and manipulate that variable with floating "
"point constants (and never use integer constants). For example, prefer "
"`self.speed = 1.` over `self.speed = 1`, and prefer `self.speed = 2. * x` "
"over `self.speed = 2 * x`. Consistent use of floating point values can avoid"
" hard to debug quirks in Python type conversions."
msgstr ""
"若一Python變數存放有一浮點數，那麼建議該變數應總賦予浮點型別的量，並僅使用浮點數常量進行值運算（並絕不使用整形常數進行運算）。例如，應使用`self.speed"
" = 1.`而非`self.speed = 1`，並以`self.speed = 2. * x` 替代 ` self.speed = 2 "
"*x`。一致地使用浮點值可以避免Python型別轉換中難以除錯的怪異現象。"

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"The first main coding task is to bring up communication support to the "
"target board. This is the most difficult step in a new port. Once basic "
"communication is working, the remaining steps tend to be much easier. It is "
"typical to use a UART type serial device during initial development as these"
" types of hardware devices are generally easier to enable and control. "
"During this phase, make liberal use of helper code from the src/generic/ "
"directory (check how src/simulator/Makefile includes the generic C code into"
" the build). It is also necessary to define timer_read_time() (which returns"
" the current system clock) in this phase, but it is not necessary to fully "
"support timer irq handling."
msgstr ""
"首要任務是在目標印表機主板上實現通訊。這是增加支援中最難的一步，實現該功能后一切將闊然開朗。在開荒時，一般使用序列匯流排進行開發，因為通常序列匯流排已於應用和控制。在此階段，可大量使用"
" src/generic/ 目錄中的中的輔助程式碼（可參考 src/simulator/Makefile "
"中如何將上述程式碼加入構建）。同時，需要在這階段完成 timer_read_time() 的定義（用於獲取現時系統時鐘），但無需完全實現定時中斷功能。"

#: docs/Code_Overview.md:block 39 (paragraph)
msgid "Additional coding tips:"
msgstr "還有一些tips："

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Avoid using \"C bitfields\" to access IO registers; prefer direct read and "
"write operations of 32bit, 16bit, or 8bit integers. The C language "
"specifications don't clearly specify how the compiler must implement C "
"bitfields (eg, endianness, and bit layout), and it's difficult to determine "
"what IO operations will occur on a C bitfield read or write."
msgstr ""
"避免使用「C位段」（C "
"bitfield）訪問IO暫存器；應使用直接對32位、16位和8位的整數讀寫代替。C語言規範中沒有對位段操作進行清晰定義（例如端序、字佈局等），且在IO操作時使用C段位讀寫，將難以確定具體進行了何種IO操作。"

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Prefer writing explicit values to IO registers instead of using read-modify-"
"write operations. That is, if updating a field in an IO register where the "
"other fields have known values, then it is preferable to explicitly write "
"the full contents of the register. Explicit writes produce code that is "
"smaller, faster, and easier to debug."
msgstr ""
"IO暫存器操作時應使用顯式賦值，避免使用「讀-改-寫」。也就是說，如果在一個IO暫存器中更新一個欄位，而其他欄位的值是已知的，那麼最好是顯式地寫入暫存器的全部內容。顯式寫入產生的程式碼更小，更快，更容易除錯。"

#: docs/Code_Overview.md:block 14 (paragraph)
msgid ""
"Task, init, and command functions always run with interrupts enabled "
"(however, they can temporarily disable interrupts if needed). These "
"functions should avoid long pauses, delays, or do work that lasts a "
"significant time. (Long delays in these \"task\" functions result in "
"scheduling jitter for other \"tasks\" - delays over 100us may become "
"noticeable, delays over 500us may result in command retransmissions, delays "
"over 100ms may result in watchdog reboots.) These functions schedule work at"
" specific times by scheduling timers."
msgstr ""
"任務”功能的長時間延遲會導致其他“任務”的調度抖動 - 超過 100us 的延遲可能會變得很明顯，超過 500us 的延遲可能會導致命令重傳，超過 "
"100ms 的延遲可能會導致看門狗重新啟動。）這些功能將工作安排在通過安排計時器的特定時間。"

#~ msgid ""
#~ "Task, init, and command functions always run with interrupts enabled "
#~ "(however, they can temporarily disable interrupts if needed). These "
#~ "functions should never pause, delay, or do any work that lasts more than a "
#~ "few micro-seconds. These functions schedule work at specific times by "
#~ "scheduling timers."
#~ msgstr ""
#~ "任務、初始化和命令函式總是在中斷啟用的情況下執行（然而，可根據需要將中斷功能停用）。這些函式不應出現暫停、延遲或執行持續事件長於數微秒的任務。這些函式應由排程定時器在特定的事件進行呼叫。"

#~ msgid ""
#~ "The first main coding task is to bring up communication support to the "
#~ "target board. This is the most difficult step in a new port. Once basic "
#~ "communication is working, the remaining steps tend to be much easier. It is "
#~ "typical to use an RS-232 style serial port during initial development as "
#~ "these types of hardware devices are generally easier to enable and control. "
#~ "During this phase, make liberal use of helper code from the src/generic/ "
#~ "directory (check how src/simulator/Makefile includes the generic C code into"
#~ " the build). It is also necessary to define timer_read_time() (which returns"
#~ " the current system clock) in this phase, but it is not necessary to fully "
#~ "support timer irq handling."
#~ msgstr ""

#~ msgid ""
#~ "Add support for timer dispatch from hardware interrupts. See Klipper [commit"
#~ " "
#~ "970831ee](https://github.com/KevinOConnor/klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f)"
#~ " as an example of steps 1-5 done for the LPC176x architecture."
#~ msgstr ""

#~ msgid ""
#~ "Bring up basic GPIO input and output support. See Klipper [commit "
#~ "c78b9076](https://github.com/KevinOConnor/klipper/commit/c78b90767f19c9e8510c3155b89fb7ad64ca3c54)"
#~ " as an example of this."
#~ msgstr ""

#~ msgid ""
#~ "Bring up additional peripherals - for example see Klipper commit "
#~ "[65613aed](https://github.com/KevinOConnor/klipper/commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27),"
#~ " "
#~ "[c812a40a](https://github.com/KevinOConnor/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5),"
#~ " and "
#~ "[c381d03a](https://github.com/KevinOConnor/klipper/commit/c381d03aad5c3ee761169b7c7bced519cc14da29)."
#~ msgstr ""

#~ msgid ""
#~ "The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total"
#~ " number of steps the micro-controller has issued in a positive direction "
#~ "minus the number of steps issued in a negative direction since the micro-"
#~ "controller was last reset. The value reported is only valid after the "
#~ "stepper has been homed. If the robot is in motion when the query is issued "
#~ "then the reported value includes moves buffered on the micro-controller, but"
#~ " does not include moves on the look-ahead queue."
#~ msgstr ""
