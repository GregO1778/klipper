# Zs.Antal <zsikaiantal@gmail.com>, 2022.
# Yifei Ding <dingyifeiair@gmail.com>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2022-09-18 19:21+0000\n"
"Last-Translator: Zs.Antal <zsikaiantal@gmail.com>\n"
"Language-Team: Hungarian <https://hosted.weblate.org/projects/klipper/"
"code_overview/hu/>\n"
"Language: hu\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 4.14.1\n"

msgid ""
"This document describes the overall code layout and major code flow of "
"Klipper."
msgstr ""
"Ez a dokumentum a Klipper általános kódelrendezését és főbb kódfolyamát írja "
"le."

msgid "Directory Layout"
msgstr "Könyvtár elrendezése"

msgid ""
"The **src/** directory contains the C source for the micro-controller code. "
"The **src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, **src/"
"lpc176x/**, **src/pru/**, and **src/stm32/** directories contain "
"architecture specific micro-controller code. The **src/simulator/** contains "
"code stubs that allow the micro-controller to be test compiled on other "
"architectures. The **src/generic/** directory contains helper code that may "
"be useful across different architectures. The build arranges for includes of "
"\"board/somefile.h\" to first look in the current architecture directory "
"(eg, src/avr/somefile.h) and then in the generic directory (eg, src/generic/"
"somefile.h)."
msgstr ""
"Az **src/** könyvtár tartalmazza a mikrovezérlő kódjának C forrását. Az "
"**src/atsam/**, **src/atsamd/**, **src/avr/**, **src/linux/**, **src/lpc176x/"
"**, **src/ A pru/** és **src/stm32/** könyvtárak architektúra specifikus "
"mikrovezérlő kódot tartalmaznak. Az **src/simulator/** kódcsonkokat "
"tartalmaz, amelyek lehetővé teszik a mikrokontroller tesztelését más "
"architektúrákon. Az **src/generic/** könyvtár segédkódot tartalmaz, amely "
"hasznos lehet a különböző architektúrákban. A build gondoskodik arról, hogy "
"az include \"board/somefile.h\" először az aktuális architektúra könyvtárban "
"(pl. src/avr/somefile.h), majd az általános könyvtárban (pl. src/generic/"
"somefile.h) keressen."

msgid ""
"The **klippy/** directory contains the host software. Most of the host "
"software is written in Python, however the **klippy/chelper/** directory "
"contains some C code helpers. The **klippy/kinematics/** directory contains "
"the robot kinematics code. The **klippy/extras/** directory contains the "
"host code extensible \"modules\"."
msgstr ""
"A **klippy/** könyvtár tartalmazza a gazdaszoftvert. A gazdaszoftver nagy "
"része Python nyelven íródott, azonban a **klippy/chelper/** könyvtár "
"tartalmaz néhány C kódú segédprogramot. A **klippy/kinematics/** könyvtár "
"tartalmazza a gép kinematikai kódját. A **klippy/extras/** könyvtár "
"tartalmazza a gazdakód bővíthető \"moduljait\"."

msgid ""
"The **lib/** directory contains external 3rd-party library code that is "
"necessary to build some targets."
msgstr ""
"A **lib/** könyvtár külső, harmadik féltől származó könyvtári kódot "
"tartalmaz, amely néhány célprogram elkészítéséhez szükséges."

msgid "The **config/** directory contains example printer configuration files."
msgstr ""
"A **config/** könyvtár a nyomtató konfigurációs példafájljait tartalmazza."

msgid ""
"The **scripts/** directory contains build-time scripts useful for compiling "
"the micro-controller code."
msgstr ""
"A **scripts/** könyvtár a mikrokontroller kódjának fordításához hasznos, "
"építési-idejű szkripteket tartalmaz."

msgid "The **test/** directory contains automated test cases."
msgstr "A **test/** könyvtár automatikus teszteseteket tartalmaz."

msgid ""
"During compilation, the build may create an **out/** directory. This "
"contains temporary build time objects. The final micro-controller object "
"that is built is **out/klipper.elf.hex** on AVR and **out/klipper.bin** on "
"ARM."
msgstr ""
"Fordítás során a build létrehozhat egy **out/** könyvtárat. Ez ideiglenes "
"elkészítésű objektumokat tartalmaz. A végső mikrokontroller objektum, amely "
"elkészül, AVR esetén **out/klipper.elf.hex**, ARM esetén **out/klipper.bin**."

msgid "Micro-controller code flow"
msgstr "Mikrokontroller kódfolyamat"

msgid ""
"Execution of the micro-controller code starts in architecture specific code "
"(eg, **src/avr/main.c**) which ultimately calls sched_main() located in "
"**src/sched.c**. The sched_main() code starts by running all functions that "
"have been tagged with the DECL_INIT() macro. It then goes on to repeatedly "
"run all functions tagged with the DECL_TASK() macro."
msgstr ""
"A mikrokontroller kódjának végrehajtása az architektúra specifikus kódban "
"kezdődik (pl. **src/avr/main.c**), amely végül a **src/sched.c**-ban "
"található sched_main() parancsot hívja meg. A sched_main() kód a DECL_INIT() "
"makróval jelölt összes függvény futtatásával kezdődik. Ezután a DECL_TASK() "
"makróval megjelölt függvények ismételt futtatására kerül sor."

msgid ""
"One of the main task functions is command_dispatch() located in **src/"
"command.c**. This function is called from the board specific input/output "
"code (eg, **src/avr/serial.c**, **src/generic/serial_irq.c**) and it runs "
"the command functions associated with the commands found in the input "
"stream. Command functions are declared using the DECL_COMMAND() macro (see "
"the [protocol](Protocol.md) document for more information)."
msgstr ""
"Az egyik fő feladatfüggvény a command_dispatch(), amely a **src/command.c** "
"fájlban található. Ezt a függvényt a kártyaspecifikus bemeneti/kimeneti "
"kódból (pl. **src/avr/serial.c**, **src/generic/serial_irq.c**) hívjuk meg, "
"és a bemeneti folyamban található parancsokhoz tartozó parancsfüggvényeket "
"futtatja. A parancsfüggvények deklarálása a DECL_COMMAND() makróval történik "
"(további információkért lásd a [protokol](Protocol.md) dokumentumot)."

msgid ""
"Timer functions are scheduled by calling sched_add_timer() (located in **src/"
"sched.c**). The scheduler code will arrange for the given function to be "
"called at the requested clock time. Timer interrupts are initially handled "
"in an architecture specific interrupt handler (eg, **src/avr/timer.c**) "
"which calls sched_timer_dispatch() located in **src/sched.c**. The timer "
"interrupt leads to execution of schedule timer functions. Timer functions "
"always run with interrupts disabled. The timer functions should always "
"complete within a few micro-seconds. At completion of the timer event, the "
"function may choose to reschedule itself."
msgstr ""
"Az időzítő függvények ütemezése a sched_add_timer() meghívásával történik (a "
"**src/sched.c** fájlban található). Az ütemező kód gondoskodik arról, hogy "
"az adott függvényt a kért időben hívja meg. Az időzítő megszakítások "
"kezelése kezdetben egy architektúra-specifikus megszakításkezelőben történik "
"(pl. **src/avr/timer.c**), amely a **src/sched.c**-ban található "
"sched_timer_dispatch() funkciót hívja. Az időzítő megszakítása az ütemező "
"időzítő függvények végrehajtásához vezet. Az időzítő függvények mindig "
"megszakítások kikapcsolásával futnak. Az időzítőfüggvényeknek mindig néhány "
"mikroszekundumon belül kell befejeződniük. Az időzítő esemény befejezésekor "
"a függvény dönthet úgy, hogy átütemezi magát."

msgid ""
"In the event an error is detected the code can invoke shutdown() (a macro "
"which calls sched_shutdown() located in **src/sched.c**). Invoking "
"shutdown() causes all functions tagged with the DECL_SHUTDOWN() macro to be "
"run. Shutdown functions always run with interrupts disabled."
msgstr ""
"Hiba észlelése esetén a kód meghívhatja a shutdown() funkciót (egy makró, "
"amely a **src/sched.c**-ben található sched_shutdown() funkciót hívja). A "
"shutdown() meghívása a DECL_SHUTDOWN() makróval jelölt összes függvény "
"futtatását eredményezi. A leállítási függvények mindig megszakítások "
"letiltásával futnak."

msgid ""
"Much of the functionality of the micro-controller involves working with "
"General-Purpose Input/Output pins (GPIO). In order to abstract the low-level "
"architecture specific code from the high-level task code, all GPIO events "
"are implemented in architecture specific wrappers (eg, **src/avr/gpio.c**). "
"The code is compiled with gcc's \"-flto -fwhole-program\" optimization which "
"does an excellent job of inlining functions across compilation units, so "
"most of these tiny gpio functions are inlined into their callers, and there "
"is no run-time cost to using them."
msgstr ""
"A mikrokontroller funkcióinak nagy része az általános célú bemeneti/kimeneti "
"érintkezőkkel (GPIO) való munkát foglalja magában. Annak érdekében, hogy az "
"alacsony szintű architektúra specifikus kódot elvonatkoztassuk a magas "
"szintű feladatkódtól, minden GPIO eseményt architektúra specifikus "
"burkolatokban valósítunk meg (pl. **src/avr/gpio.c**). A kódot a gcc's \"-"
"flto -fwhole-program\" optimalizálással fordítottuk, amely kiváló munkát "
"végez a függvények sorolásában a fordítási egységeken keresztül, így a "
"legtöbb ilyen apró GPIO függvény sorolva van a hívóikban, és nincs "
"futásidejű költsége a használatuknak."

msgid "Klippy code overview"
msgstr "Klippy kód áttekintése"

msgid ""
"The host code (Klippy) is intended to run on a low-cost computer (such as a "
"Raspberry Pi) paired with the micro-controller. The code is primarily "
"written in Python, however it does use CFFI to implement some functionality "
"in C code."
msgstr ""
"A gazdakódot (Klippy) egy olcsó számítógépen (például egy Raspberry Pi) kell "
"futtatni a mikrokontrollerrel párosítva. A kód elsősorban Pythonban íródott, "
"azonban a CFFI-t használja néhány funkció C kódban történő megvalósításához."

msgid ""
"Initial execution starts in **klippy/klippy.py**. This reads the command-"
"line arguments, opens the printer config file, instantiates the main printer "
"objects, and starts the serial connection. The main execution of G-code "
"commands is in the process_commands() method in **klippy/gcode.py**. This "
"code translates the G-code commands into printer object calls, which "
"frequently translate the actions to commands to be executed on the micro-"
"controller (as declared via the DECL_COMMAND macro in the micro-controller "
"code)."
msgstr ""
"A kezdeti végrehajtás a **klippy/klippy.py** fájlban kezdődik. Ez beolvassa "
"a parancssori argumentumokat, megnyitja a nyomtató konfigurációs fájlját, "
"példányosítja a fő nyomtatóobjektumokat, és elindítja a soros kapcsolatot. A "
"G-kód parancsok fő végrehajtása a process_commands() metódusban történik az "
"**klippy/gcode.py** fájlban. Ez a kód a G-kód parancsokat nyomtatóobjektum "
"hívásokká fordítja le, amelyek gyakran a műveleteket a mikrovezérlőn "
"végrehajtandó parancsokká alakítják (a mikrovezérlő kódjában a DECL_COMMAND "
"makrón keresztül)."

msgid ""
"There are four threads in the Klippy host code. The main thread handles "
"incoming gcode commands. A second thread (which resides entirely in the "
"**klippy/chelper/serialqueue.c** C code) handles low-level IO with the "
"serial port. The third thread is used to process response messages from the "
"micro-controller in the Python code (see **klippy/serialhdl.py**). The "
"fourth thread writes debug messages to the log (see **klippy/queuelogger."
"py**) so that the other threads never block on log writes."
msgstr ""
"A Klippy gazdagép kódjában négy szál van. A fő szál kezeli a bejövő G-kód "
"parancsokat. Egy második szál (amely teljes egészében a **klippy/chelper/"
"serialqueue.c** C kódban található) az alacsony szintű IO-t kezeli a soros "
"portal. A harmadik szál a Python kódban (lásd **klippy/serialhdl.py**) a "
"mikrokontroller válaszüzeneteinek feldolgozására szolgál. A negyedik szál "
"hibakeresési üzeneteket ír a naplóba (lásd **klippy/queuelogger.py**), hogy "
"a többi szál soha ne blokkoljon a naplóíráskor."

msgid "Code flow of a move command"
msgstr "Mozgásparancs kódfolyama"

msgid ""
"A typical printer movement starts when a \"G1\" command is sent to the "
"Klippy host and it completes when the corresponding step pulses are produced "
"on the micro-controller. This section outlines the code flow of a typical "
"move command. The [kinematics](Kinematics.md) document provides further "
"information on the mechanics of moves."
msgstr ""
"Egy tipikus nyomtatómozgás akkor kezdődik, amikor egy \"G1\" parancsot "
"küldünk a Klippy gazdagépnek, és akkor fejeződik be, amikor a megfelelő "
"lépésimpulzusok megjelennek a mikrokontrolleren. Ez a szakasz egy tipikus "
"mozgatási parancs kódfolyamatát vázolja fel. A [kinematika](Kinematics.md) "
"dokumentum további információkat tartalmaz a mozgások mechanikájáról."

msgid ""
"Processing for a move command starts in gcode.py. The goal of gcode.py is to "
"translate G-code into internal calls. A G1 command will invoke cmd_G1() in "
"klippy/extras/gcode_move.py. The gcode_move.py code handles changes in "
"origin (eg, G92), changes in relative vs absolute positions (eg, G90), and "
"unit changes (eg, F6000=100mm/s). The code path for a move is: "
"`_process_data() -> _process_commands() -> cmd_G1()`. Ultimately the "
"ToolHead class is invoked to execute the actual request: `cmd_G1() -> "
"ToolHead.move()`"
msgstr ""
"A mozgás parancs feldolgozása a gcode.py fájlban kezdődik. A gcode.py célja "
"a G-kód lefordítása belső hívásokká. Egy G1 parancs a klippy/extras/"
"gcode_move.py állományban lévő cmd_G1() parancsot hívja meg. A gcode_move.py "
"kód kezeli az eredetváltozásokat (pl. G92), a relatív és abszolút pozíciók "
"közötti változásokat (pl. G90) és az egységváltozásokat (pl. F6000=100mm/s). "
"A kód útvonala a mozgatáshoz a következő: `_process_data() -> "
"_process_commands() -> cmd_G1()`. Végül a ToolHead osztályt hívjuk meg a "
"tényleges kérés végrehajtásához: `cmd_G1() -> ToolHead.move()`"

msgid ""
"The ToolHead class (in toolhead.py) handles \"look-ahead\" and tracks the "
"timing of printing actions. The main codepath for a move is: `ToolHead."
"move() -> MoveQueue.add_move() -> MoveQueue.flush() -> Move.set_junction() -"
"> ToolHead._process_moves()`."
msgstr ""
"A ToolHead osztály (a toolhead.py állományban) kezeli a \"look-ahead\" és "
"követi a nyomtatási műveletek időzítését. A fő kódútvonal egy mozdulathoz a "
"következő: `ToolHead.move() -> MoveQueue.add_move() -> MoveQueue.flush() -> "
"Move.set_junction() -> ToolHead._process_moves()`."

msgid ""
"ToolHead.move() creates a Move() object with the parameters of the move (in "
"cartesian space and in units of seconds and millimeters)."
msgstr ""
"A ToolHead.move() létrehoz egy Move() objektumot a mozgás paramétereivel "
"(cartesian térben, másodperc és milliméter egységekben)."

msgid ""
"The kinematics class is given the opportunity to audit each move (`ToolHead."
"move() -> kin.check_move()`). The kinematics classes are located in the "
"klippy/kinematics/ directory. The check_move() code may raise an error if "
"the move is not valid. If check_move() completes successfully then the "
"underlying kinematics must be able to handle the move."
msgstr ""
"A kinematikai osztály lehetőséget kap az egyes mozgások ellenőrzésére "
"(`ToolHead.move() -> kin.check_move()`). A kinematikai osztályok a klippy/"
"kinematics/ könyvtárban találhatók. A check_move() kód hibát adhat ki, ha a "
"mozgás nem érvényes. Ha a check_move() sikeresen befejeződik, akkor az "
"alapul szolgáló kinematikának képesnek kell lennie a mozgás kezelésére."

msgid ""
"MoveQueue.add_move() places the move object on the \"look-ahead\" queue."
msgstr ""
"A MoveQueue.add_move() elhelyezi a move objektumot a \"look-ahead\" "
"várólistán."

msgid "MoveQueue.flush() determines the start and end velocities of each move."
msgstr ""
"A MoveQueue.flush() meghatározza az egyes mozgások kezdő és végsebességét."

msgid ""
"Move.set_junction() implements the \"trapezoid generator\" on a move. The "
"\"trapezoid generator\" breaks every move into three parts: a constant "
"acceleration phase, followed by a constant velocity phase, followed by a "
"constant deceleration phase. Every move contains these three phases in this "
"order, but some phases may be of zero duration."
msgstr ""
"A Move.set_junction() a \"trapézgenerátort\" valósítja meg egy mozgásban. A "
"\"trapézgenerátor\" minden mozgást három részre bont: egy állandó gyorsulási "
"fázisra, majd egy állandó sebesség fázisra, majd egy állandó lassulási "
"fázisra. Minden mozgás ebben a sorrendben tartalmazza ezt a három fázist, de "
"egyes fázisok időtartama lehet nulla is."

msgid ""
"When ToolHead._process_moves() is called, everything about the move is known "
"- its start location, its end location, its acceleration, its start/cruising/"
"end velocity, and distance traveled during acceleration/cruising/"
"deceleration. All the information is stored in the Move() class and is in "
"cartesian space in units of millimeters and seconds."
msgstr ""
"Amikor a ToolHead._process_moves() meghívásra kerül, a mozgással "
"kapcsolatban minden ismert a kezdőhelye, a véghelye, a gyorsulása, a kezdő/"
"körözési/végsebessége és a gyorsulás/körözési/végsebesség alatt megtett "
"távolság. Minden információ a Move() osztályban tárolódik, és cartesian "
"térben, milliméter és másodperc egységekben van megadva."

msgid ""
"Klipper uses an [iterative solver](https://en.wikipedia.org/wiki/Root-"
"finding_algorithm) to generate the step times for each stepper. For "
"efficiency reasons, the stepper pulse times are generated in C code. The "
"moves are first placed on a \"trapezoid motion queue\": `ToolHead."
"_process_moves() -> trapq_append()` (in klippy/chelper/trapq.c). The step "
"times are then generated: `ToolHead._process_moves() -> ToolHead."
"_update_move_time() -> MCU_Stepper.generate_steps() -> "
"itersolve_generate_steps() -> itersolve_gen_steps_range()` (in klippy/"
"chelper/itersolve.c). The goal of the iterative solver is to find step times "
"given a function that calculates a stepper position from a time. This is "
"done by repeatedly \"guessing\" various times until the stepper position "
"formula returns the desired position of the next step on the stepper. The "
"feedback produced from each guess is used to improve future guesses so that "
"the process rapidly converges to the desired time. The kinematic stepper "
"position formulas are located in the klippy/chelper/ directory (eg, kin_cart."
"c, kin_corexy.c, kin_delta.c, kin_extruder.c)."
msgstr ""
"A Klipper egy [iteratív megoldót](https://hu.wikipedia.org/wiki/Gy"
"%C3%B6kkeres%C5%91_algoritmus) használ az egyes léptetők lépésidejének "
"létrehozásához. Hatékonysági okokból a léptető impulzusidőket C kódban "
"generálja. A mozgásokat először egy \"trapézmozgás várólistára\" helyezzük: "
"`ToolHead._process_moves() -> trapq_append()` (a klippy/chelper/trapq.c-"
"ben). A lépésidők ezután generálódnak: `ToolHead._process_moves() -> "
"ToolHead._update_move_time() -> MCU_Stepper.generate_steps() -> "
"itersolve_generate_steps() -> itersolve_gen_steps_range()` (a klippy/chelper/"
"itersolve.c-ben). Az iteratív megoldó célja, hogy lépésidőket találjon egy "
"olyan függvényt adva, amely egy időből kiszámítja a lépéshelyzetet. Ez úgy "
"történik, hogy többször \"találgatja\" a különböző időket, amíg a léptető "
"pozíció képlet vissza nem adja a léptető következő lépésének kívánt "
"pozícióját. Az egyes találgatásokból származó visszajelzéseket a jövőbeli "
"találgatások javítására használja, hogy a folyamat gyorsan konvergáljon a "
"kívánt időhöz. A kinematikus léptető pozíció képletek a klippy/chelper/ "
"könyvtárban találhatók (pl. kin_cart.c, kin_corexy.c, kin_delta.c, "
"kin_extruder.c)."

msgid ""
"Note that the extruder is handled in its own kinematic class: `ToolHead."
"_process_moves() -> PrinterExtruder.move()`. Since the Move() class "
"specifies the exact movement time and since step pulses are sent to the "
"micro-controller with specific timing, stepper movements produced by the "
"extruder class will be in sync with head movement even though the code is "
"kept separate."
msgstr ""
"Vedd figyelembe, hogy az extruder saját kinematikai osztályban van kezelve: "
"`ToolHead._process_moves() -> PrinterExtruder.move()`. Mivel a Move() "
"osztály pontosan megadja a mozgás idejét, és mivel a lépésimpulzusokat "
"meghatározott időzítéssel küldi a mikrokontrollerhez, az extruder osztály "
"által előállított léptetőmozgások szinkronban lesznek a fejmozgással, annak "
"ellenére, hogy a kódot elkülönítve tartjuk."

msgid ""
"After the iterative solver calculates the step times they are added to an "
"array: `itersolve_gen_steps_range() -> stepcompress_append()` (in klippy/"
"chelper/stepcompress.c). The array (struct stepcompress.queue) stores the "
"corresponding micro-controller clock counter times for every step. Here the "
"\"micro-controller clock counter\" value directly corresponds to the micro-"
"controller's hardware counter - it is relative to when the micro-controller "
"was last powered up."
msgstr ""
"Miután az iteratív megoldó kiszámítja a lépésidőket, azok egy tömbhöz "
"kerülnek hozzáadásra: `itersolve_gen_steps_range() -> stepcompress_append()` "
"(in klippy/chelper/stepcompress.c). A tömb (struct stepcompress.queue) "
"minden lépéshez tárolja a mikrokontroller megfelelő óraszámláló idejét. Itt "
"a \"mikrokontroller óraszámláló\" értéke közvetlenül megfelel a "
"mikrokontroller hardveres számlálójának, a mikrokontroller utolsó "
"bekapcsolásának időpontjához viszonyítva."

msgid ""
"The next major step is to compress the steps: `stepcompress_flush() -> "
"compress_bisect_add()` (in klippy/chelper/stepcompress.c). This code "
"generates and encodes a series of micro-controller \"queue_step\" commands "
"that correspond to the list of stepper step times built in the previous "
"stage. These \"queue_step\" commands are then queued, prioritized, and sent "
"to the micro-controller (via stepcompress.c:steppersync and serialqueue.c:"
"serialqueue)."
msgstr ""
"A következő fontos lépés a lépések tömörítése: `stepcompress_flush() -> "
"compress_bisect_add()` (in klippy/chelper/stepcompress.c). Ez a kód "
"generálja és kódolja a mikrokontroller \"queue_step\" parancsainak "
"sorozatát, amelyek megfelelnek az előző szakaszban felépített léptető "
"lépésidők listájának. Ezek a \"queue_step\" parancsok ezután sorba kerülnek, "
"prioritást kapnak, és elküldésre kerülnek a mikrokontrollernek (a "
"stepcompress.c:steppersync és a serialqueue.c:serialqueue kódokon keresztül)."

msgid ""
"Processing of the queue_step commands on the micro-controller starts in src/"
"command.c which parses the command and calls `command_queue_step()`. The "
"command_queue_step() code (in src/stepper.c) just appends the parameters of "
"each queue_step command to a per stepper queue. Under normal operation the "
"queue_step command is parsed and queued at least 100ms before the time of "
"its first step. Finally, the generation of stepper events is done in "
"`stepper_event()`. It's called from the hardware timer interrupt at the "
"scheduled time of the first step. The stepper_event() code generates a step "
"pulse and then reschedules itself to run at the time of the next step pulse "
"for the given queue_step parameters. The parameters for each queue_step "
"command are \"interval\", \"count\", and \"add\". At a high-level, "
"stepper_event() runs the following, 'count' times: `do_step(); "
"next_wake_time = last_wake_time + interval; interval += add;`"
msgstr ""
"A queue_step parancsok feldolgozása a mikrokontrollerben az src/command.c "
"állományban kezdődik, amely elemzi a parancsot és meghívja a "
"`command_queue_step()` parancsot. A command_queue_step() kód (az src/stepper."
"c-ben) csak az egyes queue_step parancsok paramétereit csatolja egy-egy "
"stepper sorba. Normál működés esetén a queue_step parancsot legalább 100ms-"
"mal az első lépés időpontja előtt elemzi és beállítja a sorba. Végül a "
"léptető események generálása a `stepper_event()`-ban történik. Ezt a "
"hardveres időzítő megszakításából hívjuk meg az első lépés tervezett "
"időpontjában. A stepper_event() kód generál egy lépésimpulzust, majd "
"átütemezi magát a következő lépésimpulzus idejére a megadott queue_step "
"paraméterekhez. Az egyes queue_step parancsok paraméterei a következők: "
"\"interval\", \"count\" és \"add\". Magas szinten a stepper_event() a "
"következőket hajtja végre, 'count' times: `do_step(); next_wake_time = "
"last_wake_time + interval; interval += add;`"

msgid ""
"The above may seem like a lot of complexity to execute a movement. However, "
"the only really interesting parts are in the ToolHead and kinematic classes. "
"It's this part of the code which specifies the movements and their timings. "
"The remaining parts of the processing is mostly just communication and "
"plumbing."
msgstr ""
"A fentiek soknak tűnhetnek egy mozdulat végrehajtásához. Az egyetlen igazán "
"érdekes rész azonban a ToolHead és a kinematikai osztályokban található. Ez "
"a kódnak azon része, amely meghatározza a mozgásokat és azok időzítését. A "
"feldolgozás többi része többnyire csak kommunikáció és munka."

msgid "Adding a host module"
msgstr "Gazdamodul hozzáadása"

msgid ""
"The Klippy host code has a dynamic module loading capability. If a config "
"section named \"[my_module]\" is found in the printer config file then the "
"software will automatically attempt to load the python module klippy/extras/"
"my_module.py . This module system is the preferred method for adding new "
"functionality to Klipper."
msgstr ""
"A Klippy host kódja dinamikus modulbetöltési képességgel rendelkezik. Ha a "
"nyomtató konfigurációs fájljában található egy \"[my_module]\" nevű "
"konfigurációs szakasz, akkor a szoftver automatikusan megpróbálja betölteni "
"a klippy/extras/my_module.py modult. Ez a modulrendszer a Klipper új "
"funkciók hozzáadásának előnyben részesített módszere."

msgid ""
"The easiest way to add a new module is to use an existing module as a "
"reference - see **klippy/extras/servo.py** as an example."
msgstr ""
"Egy új modul hozzáadásának legegyszerűbb módja, ha egy meglévő modult "
"használunk hivatkozásként. Lásd **klippy/extras/servo.py** példaként."

msgid "The following may also be useful:"
msgstr "A következők is hasznosak lehetnek:"

msgid ""
"Execution of the module starts in the module level `load_config()` function "
"(for config sections of the form [my_module]) or in `load_config_prefix()` "
"(for config sections of the form [my_module my_name]). This function is "
"passed a \"config\" object and it must return a new \"printer object\" "
"associated with the given config section."
msgstr ""
"A modul végrehajtása a modulszintű `load_config()` függvényben kezdődik (a "
"[my_module] formájú config szakaszok esetén) vagy a `load_config_prefix()` "
"függvényben (a [my_module my_name] formájú config szakaszok esetén). Ennek a "
"függvénynek egy \"config\" objektumot kell átadni, és egy új \"printer "
"objektumot\" kell visszaadnia, amely az adott config szakaszhoz kapcsolódik."

msgid ""
"During the process of instantiating a new printer object, the config object "
"can be used to read parameters from the given config section. This is done "
"using `config.get()`, `config.getfloat()`, `config.getint()`, etc. methods. "
"Be sure to read all values from the config during the construction of the "
"printer object - if the user specifies a config parameter that is not read "
"during this phase then it will be assumed it is a typo in the config and an "
"error will be raised."
msgstr ""
"Egy új nyomtatóobjektum példányosítása során a config objektum segítségével "
"paramétereket olvashat be az adott config szakaszból. Erre a `config.get()`, "
"`config.getfloat()`, `config.getint()` stb. metódusok szolgálnak. Ügyelj "
"arra, hogy a nyomtató objektum felépítése során minden értéket beolvasson a "
"config-ból. Ha a felhasználó olyan config paramétert ad meg, amelyet ebben a "
"fázisban nem olvas be, akkor azt feltételezi, hogy elírás történt a config-"
"ban, és hibaüzenetet ad."

msgid ""
"Use the `config.get_printer()` method to obtain a reference to the main "
"\"printer\" class. This \"printer\" class stores references to all the "
"\"printer objects\" that have been instantiated. Use the `printer."
"lookup_object()` method to find references to other printer objects. Almost "
"all functionality (even core kinematic modules) are encapsulated in one of "
"these printer objects. Note, though, that when a new module is instantiated, "
"not all other printer objects will have been instantiated. The \"gcode\" and "
"\"pins\" modules will always be available, but for other modules it is a "
"good idea to defer the lookup."
msgstr ""
"A `config.get_printer()` metódus segítségével megkapjuk a fő \"printer\" "
"osztályra való hivatkozást. Ez a \"printer\" osztály tárolja a "
"hivatkozásokat az összes \"nyomtató objektumra\", amelyet már "
"példányosítottak. A `printer.lookup_object()` metódus segítségével "
"megkereshetjük a többi nyomtató objektumra mutató hivatkozásokat. Szinte "
"minden funkció (még az alapvető kinematikai modulok is) egy ilyen nyomtató "
"objektumba vannak kapszulázva. Vegyük azonban figyelembe, hogy egy új modul "
"példányosításakor nem minden más nyomtató objektumot példányosítottunk. A "
"\"gcode\" és a \"pins\" modulok mindig elérhetőek lesznek, de a többi modul "
"esetében érdemes elhalasztani a keresést."

msgid ""
"Register event handlers using the `printer.register_event_handler()` method "
"if the code needs to be called during \"events\" raised by other printer "
"objects. Each event name is a string, and by convention it is the name of "
"the main source module that raises the event along with a short name for the "
"action that is occurring (eg, \"klippy:connect\"). The parameters passed to "
"each event handler are specific to the given event (as are exception "
"handling and execution context). Two common startup events are:"
msgstr ""
"Az eseménykezelőket a `printer.register_event_handler()` módszerrel "
"regisztrálhatja, ha a kódot más nyomtató objektumok által kiváltott \"events"
"\" során kell meghívni. Minden esemény neve egy karakterlánc, és a konvenció "
"szerint az eseményt kiváltó fő forrásmodul neve, valamint az eseményt "
"kiváltó művelet rövid neve (pl. \"klippy:connect\"). Az egyes "
"eseménykezelőknek átadott paraméterek az adott eseményre jellemzőek (ahogy a "
"kivételkezelés és a végrehajtási kontextus is). Két gyakori indítási esemény "
"a következő:"

msgid ""
"klippy:connect - This event is generated after all printer objects are "
"instantiated. It is commonly used to lookup other printer objects, to verify "
"config settings, and to perform an initial \"handshake\" with printer "
"hardware."
msgstr ""
"klippy:connect - Ez az esemény az összes nyomtató objektum példányosítása "
"után generálódik. Általában más nyomtató objektumok keresésére, a "
"konfigurációs beállítások ellenőrzésére és a kezdeti \"handshake\" "
"végrehajtására használják a nyomtató hardverével."

msgid ""
"klippy:ready - This event is generated after all connect handlers have "
"completed successfully. It indicates the printer is transitioning to a state "
"ready to handle normal operations. Do not raise an error in this callback."
msgstr ""
"klippy:ready - Ez az esemény az összes csatlakozási kezelő sikeres "
"befejezése után generálódik. Jelzi, hogy a nyomtató átvált a normál "
"műveletek kezelésére kész állapotba. Ebben a visszahívásban ne jelezzen "
"hibát."

msgid ""
"If there is an error in the user's config, be sure to raise it during the "
"`load_config()` or \"connect event\" phases. Use either `raise config."
"error(\"my error\")` or `raise printer.config_error(\"my error\")` to report "
"the error."
msgstr ""
"Ha hiba van a felhasználó konfigurációjában, mindenképpen hívja fel a "
"figyelmet a `load_config()` vagy a \"connect event\" fázisokban. Használja a "
"`raise config.error(\"my error\")` vagy `raise printer.config_error(\"my "
"error\")` hibajelzést."

msgid ""
"Use the \"pins\" module to configure a pin on a micro-controller. This is "
"typically done with something similar to `printer.lookup_object(\"pins\")."
"setup_pin(\"pwm\", config.get(\"my_pin\"))`. The returned object can then be "
"commanded at run-time."
msgstr ""
"A \"pins\" modul segítségével konfigurálhat egy tűt a mikrokontrollerben. Ez "
"általában a `printer.lookup_object(\"pins\").setup_pin(\"pwm\", config."
"get(\"my_pin\"))`-hoz hasonló módon történik. A visszakapott objektumot "
"ezután futásidőben lehet utasítani."

msgid ""
"If the module needs access to system timing or external file descriptors "
"then use `printer.get_reactor()` to obtain access to the global \"event "
"reactor\" class. This reactor class allows one to schedule timers, wait for "
"input on file descriptors, and to \"sleep\" the host code."
msgstr ""
"Ha a modulnak hozzáférésre van szüksége a rendszer időzítéséhez vagy külső "
"fájlleírókhoz, akkor a `printer.get_reactor()` segítségével hozzáférhetünk a "
"globális \"event reactor\" osztályhoz. Ez a reactor osztály lehetővé teszi "
"az időzítők ütemezését, a fájlleírók bemenetének várakozását, valamint a "
"gazdakód \"sleep\" használatát."

msgid ""
"Do not use global variables. All state should be stored in the printer "
"object returned from the `load_config()` function. This is important as "
"otherwise the RESTART command may not perform as expected. Also, for similar "
"reasons, if any external files (or sockets) are opened then be sure to "
"register a \"klippy:disconnect\" event handler and close them from that "
"callback."
msgstr ""
"Ne használjon globális változókat. Minden állapotot a `load_config()` "
"függvény által visszaadott nyomtató objektumban kell tárolni. Ez azért "
"fontos, mert ellenkező esetben a RESTART parancs nem az elvártaknak "
"megfelelően fog működni. Szintén hasonló okokból, ha bármilyen külső fájl "
"(vagy foglalat) megnyílt, akkor mindenképpen regisztráljunk egy \"klippy:"
"disconnect\" eseménykezelőt, és zárjuk be őket ebből a visszahívásból."

msgid ""
"Avoid accessing the internal member variables (or calling methods that start "
"with an underscore) of other printer objects. Observing this convention "
"makes it easier to manage future changes."
msgstr ""
"Kerülje a más nyomtató objektumok belső tagváltozóinak elérését (vagy az "
"aláhúzással kezdődő metódusok hívását). Ennek a konvenciónak a betartása "
"megkönnyíti a jövőbeli változások kezelését."

msgid ""
"If submitting the module for inclusion in the main Klipper code, be sure to "
"place a copyright notice at the top of the module. See the existing modules "
"for the preferred format."
msgstr ""
"Ha a modult a Klipper főkódjába való beépítésre küldöd, mindenképpen helyezz "
"el egy szerzői jogi megjegyzést a modul tetején. Az előnyben részesített "
"formátumot lásd a meglévő moduloknál."

msgid "Adding new kinematics"
msgstr "Új kinematika hozzáadása"

msgid ""
"This section provides some tips on adding support to Klipper for additional "
"types of printer kinematics. This type of activity requires excellent "
"understanding of the math formulas for the target kinematics. It also "
"requires software development skills - though one should only need to update "
"the host software."
msgstr ""
"Ez a szakasz néhány tippet ad a Klipper további nyomtató kinematikai típusok "
"támogatásának hozzáadásához. Az ilyen típusú tevékenységhez a cél "
"kinematikához tartozó matematikai képletek kiváló ismerete szükséges. "
"Szoftverfejlesztési ismereteket is igényel, bár csak a gazdaszoftvert kell "
"frissíteni."

msgid "Useful steps:"
msgstr "Hasznos lépések:"

msgid ""
"Start by studying the \"[code flow of a move](#code-flow-of-a-move-"
"command)\" section and the [Kinematics document](Kinematics.md)."
msgstr ""
"Kezdd \"[Egy mozgás kódfolyamata](#code-flow-of-a-move-command)\" szakasz és "
"a [Kinematika dokumentum](Kinematics.md) tanulmányozásával."

msgid ""
"Review the existing kinematic classes in the klippy/kinematics/ directory. "
"The kinematic classes are tasked with converting a move in cartesian "
"coordinates to the movement on each stepper. One should be able to copy one "
"of these files as a starting point."
msgstr ""
"Tekintse át a klippy/kinematics/ könyvtárban található kinematikai "
"osztályokat. A kinematikai osztályok feladata egy cartesian koordinátákban "
"megadott mozgás átalakítása az egyes léptetőkön történő mozgássá. "
"Kiindulópontként le kell tudni másolni az egyik ilyen fájlt."

msgid ""
"Implement the C stepper kinematic position functions for each stepper if "
"they are not already available (see kin_cart.c, kin_corexy.c, and kin_delta."
"c in klippy/chelper/). The function should call `move_get_coord()` to "
"convert a given move time (in seconds) to a cartesian coordinate (in "
"millimeters), and then calculate the desired stepper position (in "
"millimeters) from that cartesian coordinate."
msgstr ""
"Implementáljuk a C léptetőket kinematikai pozíciófüggvényeit minden "
"léptetőhöz, ha azok még nem állnak rendelkezésre (lásd a kin_cart.c, "
"kin_corexy.c és kin_delta.c fájlokat a klippy/chelper/ állományban). A "
"függvénynek meg kell hívnia `move_get_coord()`, hogy egy adott mozgásidőt "
"(másodpercben) cartesian koordinátává (milliméterben) konvertáljon, majd "
"ebből a cartesian koordinátából kiszámítsa a kívánt léptető pozíciót "
"(milliméterben)."

msgid ""
"Implement the `calc_position()` method in the new kinematics class. This "
"method calculates the position of the toolhead in cartesian coordinates from "
"the position of each stepper. It does not need to be efficient as it is "
"typically only called during homing and probing operations."
msgstr ""
"Az új kinematikai osztályban implementáljuk a `calc_position()` módszert. Ez "
"a metódus kiszámítja a nyomtatófej pozícióját cartesian koordinátákban az "
"egyes léptetőmotorok pozíciójából. Nem kell, hogy hatékony legyen, mivel "
"jellemzően csak a kezdőpont és az érintési műveletek során hívjuk meg."

msgid ""
"Other methods. Implement the `check_move()`, `get_status()`, "
"`get_steppers()`, `home()`, and `set_position()` methods. These functions "
"are typically used to provide kinematic specific checks. However, at the "
"start of development one can use boiler-plate code here."
msgstr ""
"Egyéb módszerek. Implementálja a `check_move()`, `get_status()` metódusokat, "
"`get_steppers()`, `home()` és `set_position()` módszereket. Ezeket a "
"függvényeket általában kinematikai specifikus ellenőrzések biztosítására "
"használják. A fejlesztés kezdetén azonban használhatunk itt kazán-lemez "
"szerű kódot."

msgid ""
"Implement test cases. Create a g-code file with a series of moves that can "
"test important cases for the given kinematics. Follow the [debugging "
"documentation](Debugging.md) to convert this g-code file to micro-controller "
"commands. This is useful to exercise corner cases and to check for "
"regressions."
msgstr ""
"Tesztelési esetek végrehajtása. Készítsen egy G-kód fájlt egy sor olyan "
"mozgással, amelyekkel az adott kinematika fontos eseteit tesztelheti. "
"Kövesse a [Hibakeresési dokumentációt](Debugging.md), hogy ezt a G-kód fájlt "
"mikrokontroller parancsokká alakítsa át. Ez hasznos a sarokesetek "
"gyakorlására és a regressziók ellenőrzésére."

msgid "Porting to a new micro-controller"
msgstr "Portolás új mikrokontrollerre"

msgid ""
"This section provides some tips on porting Klipper's micro-controller code "
"to a new architecture. This type of activity requires good knowledge of "
"embedded development and hands-on access to the target micro-controller."
msgstr ""
"Ez a szakasz néhány tippet ad a Klipper mikrokontroller kódjának új "
"architektúrára történő átviteléhez. Ez a fajta tevékenység jó beágyazott "
"fejlesztési ismereteket és gyakorlati hozzáférést igényel a "
"célmikrokontrollerhez."

msgid ""
"Start by identifying any 3rd party libraries that will be used during the "
"port. Common examples include \"CMSIS\" wrappers and manufacturer \"HAL\" "
"libraries. All 3rd party code needs to be GNU GPLv3 compatible. The 3rd "
"party code should be committed to the Klipper lib/ directory. Update the lib/"
"README file with information on where and when the library was obtained. It "
"is preferable to copy the code into the Klipper repository unchanged, but if "
"any changes are required then those changes should be listed explicitly in "
"the lib/README file."
msgstr ""
"Kezd a portolás során használni kívánt harmadik féltől származó könyvtárak "
"azonosításával. Gyakori példa erre a \"CMSIS\" csomagolások és a gyártó \"HAL"
"\" könyvtárak. Minden harmadik féltől származó kódnak GNU GPLv3 "
"kompatibilisnek kell lennie. A harmadik féltől származó kódot a Klipper lib/ "
"könyvtárba kell átvinni. Frissítse a lib/README fájlt azzal az "
"információval, hogy hol és mikor szerezte meg a könyvtárat. A kódot "
"lehetőleg változatlanul másold be a Klipper tárolóba, de ha bármilyen "
"változtatásra van szükség, akkor ezeket a változtatásokat kifejezetten fel "
"kell tüntetni a lib/README fájlban."

msgid ""
"Create a new architecture sub-directory in the src/ directory and add "
"initial Kconfig and Makefile support. Use the existing architectures as a "
"guide. The src/simulator provides a basic example of a minimum starting "
"point."
msgstr ""
"Hozzon létre egy új architektúra alkönyvtárat az src/ könyvtárban, és adjon "
"hozzá kezdeti Config és Makefile támogatást. Használja a meglévő "
"architektúrákat útmutatóként. Az src/simulator egy alapvető példát nyújt egy "
"minimális kiindulási pontra."

msgid ""
"Get familiar with the the console.py tool (as described in the [debugging "
"document](Debugging.md)) and verify connectivity to the micro-controller "
"with it. This tool translates the low-level micro-controller communication "
"protocol to a human readable form."
msgstr ""
"Ismerkedjen meg a console.py eszközzel (a [Hibakeresési dokumentumban]"
"(Debugging.md) leírtak szerint), és ellenőrizze vele a mikrokontrollerrel "
"való kapcsolatot. Ez az eszköz lefordítja az alacsony szintű mikrokontroller "
"kommunikációs protokollt ember által olvasható formára."

msgid ""
"Create a sample Klipper config file in the config/ directory. Test the micro-"
"controller with the main klippy.py program."
msgstr ""
"Hozzon létre egy minta Klipper konfigurációs fájlt a config/ könyvtárban. "
"Teszteljük a mikrokontrollert a klippy.py főprogrammal."

msgid "Consider adding build test cases in the test/ directory."
msgstr "Fontolja meg a test/ könyvtárban lévő build tesztesetek hozzáadását."

msgid "Coordinate Systems"
msgstr "Koordináta rendszerek"

msgid ""
"Internally, Klipper primarily tracks the position of the toolhead in "
"cartesian coordinates that are relative to the coordinate system specified "
"in the config file. That is, most of the Klipper code will never experience "
"a change in coordinate systems. If the user makes a request to change the "
"origin (eg, a `G92` command) then that effect is obtained by translating "
"future commands to the primary coordinate system."
msgstr ""
"A Klipper belsőleg elsősorban a nyomtatófej helyzetét követi cartesian "
"koordinátákban, amelyek a konfigurációs fájlban megadott koordináta "
"rendszerhez viszonyítva vannak. Ez azt jelenti, hogy a Klipper kód nagy "
"része soha nem tapasztal koordináta rendszer változást. Ha a felhasználó az "
"origó megváltoztatását kéri (pl. egy `G92` parancsal), akkor ezt a hatást a "
"jövőbeli parancsok elsődleges koordináta rendszerre történő átváltásával "
"érjük el."

msgid ""
"However, in some cases it is useful to obtain the toolhead position in some "
"other coordinate system and Klipper has several tools to facilitate that. "
"This can be seen by running the GET_POSITION command. For example:"
msgstr ""
"Bizonyos esetekben azonban hasznos, ha a nyomtatófej helyzetét más "
"koordináta rendszerben szeretnénk megkapni, és a Klipper több eszközzel is "
"megkönnyíti ezt. Ez a GET_POSITION parancs futtatásával látható. Például:"

msgid ""
"The \"stepper\" position (`stepper.get_commanded_position()`) is the "
"position of the given stepper as tracked by the kinematics code. This "
"generally corresponds to the position (in mm) of the carriage along its "
"rail, relative to the position_endstop specified in the config file. (Some "
"kinematics track stepper positions in radians instead of millimeters.) If "
"the robot is in motion when the query is issued then the reported value "
"includes moves buffered on the micro-controller, but does not include moves "
"on the look-ahead queue. One may use the `toolhead.flush_step_generation()` "
"or `toolhead.wait_moves()` calls to fully flush the look-ahead and step "
"generation code."
msgstr ""
"A \"stepper\" pozíció (`stepper.get_commanded_position()`) az adott léptető "
"pozíciója, ahogyan azt a kinematikai kód követi. Ez általában megfelel a "
"kocsinak a sín mentén a konfigurációs fájlban megadott position_endstop-hoz "
"viszonyított pozíciójának (mm-ben). (Egyes kinematikák a léptetők pozícióját "
"milliméter helyett radiánban követik.) Ha a gép a lekérdezéskor mozgásban "
"van, akkor a jelentett érték tartalmazza a mikrokontrollerben pufferelt "
"mozgásokat, de nem tartalmazza a look-ahead sorban lévő mozgásokat. "
"Használhatjuk a `toolhead.flush_step_generation()` vagy `toolhead."
"wait_moves()` hívásokat a look-ahead és a lépésgeneráló kód teljes "
"kiürítéséhez."

msgid ""
"The \"kinematic\" position (`kin.calc_position()`) is the cartesian position "
"of the toolhead as derived from \"stepper\" positions and is relative to the "
"coordinate system specified in the config file. This may differ from the "
"requested cartesian position due to the granularity of the stepper motors. "
"If the robot is in motion when the \"stepper\" positions are taken then the "
"reported value includes moves buffered on the micro-controller, but does not "
"include moves on the look-ahead queue. One may use the `toolhead."
"flush_step_generation()` or `toolhead.wait_moves()` calls to fully flush the "
"look-ahead and step generation code."
msgstr ""
"A \"kinematic\" pozíció (`kin.calc_position()`) a nyomtatófej \"stepper\" "
"pozíciókból származtatott cartesian pozíciója, és a konfigurációs fájlban "
"megadott koordinátarendszerhez képest relatív. Ez eltérhet a kért cartesian "
"pozíciótól a léptetőmotorok szaggatottsága miatt. Ha a gép a \"stepper\" "
"pozíciók felvételekor mozgásban van, akkor a jelentett érték tartalmazza a "
"mikrokontrollerben pufferelt mozgásokat, de nem tartalmazza a look-ahead "
"várólistán lévő mozgásokat. Használhatjuk a `toolhead."
"flush_step_generation()` vagy `toolhead.wait_moves()` hívásokat a look-ahead "
"és a lépésgeneráló kód teljes kiürítéséhez."

msgid ""
"The \"toolhead\" position (`toolhead.get_position()`) is the last requested "
"position of the toolhead in cartesian coordinates relative to the coordinate "
"system specified in the config file. If the robot is in motion when the "
"query is issued then the reported value includes all requested moves (even "
"those in buffers waiting to be issued to the stepper motor drivers)."
msgstr ""
"A \"toolhead\" pozíció (`toolhead.get_position()`) a nyomtatófej utolsó kért "
"pozíciója cartesian koordinátákban a konfigurációs fájlban megadott "
"koordinátarendszerhez képest. Ha a gép a lekérdezés kiadásakor mozgásban "
"van, akkor a jelentett érték tartalmazza az összes kért mozgást (még azokat "
"is, amelyek a pufferben vannak és a motorvezérlőknek való kiadásra várnak)."

msgid ""
"The \"gcode\" position is the last requested position from a `G1` (or `G0`) "
"command in cartesian coordinates relative to the coordinate system specified "
"in the config file. This may differ from the \"toolhead\" position if a g-"
"code transformation (eg, bed_mesh, bed_tilt, skew_correction) is in effect. "
"This may differ from the actual coordinates specified in the last `G1` "
"command if the g-code origin has been changed (eg, `G92`, "
"`SET_GCODE_OFFSET`, `M221`). The `M114` command (`gcode_move.get_status()"
"['gcode_position']`) will report the last g-code position relative to the "
"current g-code coordinate system."
msgstr ""
"A \"gcode\" pozíció a `G1` (vagy `G0`) parancs utolsó kért pozíciója "
"cartesian koordinátákban, a konfigurációs fájlban megadott "
"koordinátarendszerhez képest. Ez eltérhet a \"toolhead\" pozíciótól, ha egy "
"G-kód transzformáció (pl. bed_mesh, bed_tilt, skew_correction) van "
"érvényben. Ez eltérhet az utolsó `G1` parancsban megadott tényleges "
"koordinátáktól, ha a G-kód origója megváltozott (pl, `G92`, "
"`SET_GCODE_OFFSET`, `M221`). A `M114` parancs (`gcode_move.get_status()"
"['gcode_position']`) az aktuális G-kód koordinátarendszerhez viszonyított "
"utolsó G-kód pozíciót jelenti."

msgid ""
"The \"gcode base\" is the location of the g-code origin in cartesian "
"coordinates relative to the coordinate system specified in the config file. "
"Commands such as `G92`, `SET_GCODE_OFFSET`, and `M221` alter this value."
msgstr ""
"A \"gcode base\" a G-kód origójának helye cartesian koordinátákban a "
"konfigurációs fájlban megadott koordinátarendszerhez képest. Az olyan "
"parancsok, mint a `G92`, `SET_GCODE_OFFSET` és `M221` módosítják ezt az "
"értéket."

msgid ""
"The \"gcode homing\" is the location to use for the g-code origin (in "
"cartesian coordinates relative to the coordinate system specified in the "
"config file) after a `G28` home command. The `SET_GCODE_OFFSET` command can "
"alter this value."
msgstr ""
"A \"gcode homing\" az a hely, amelyet a G-kód origójaként (a konfigurációs "
"fájlban megadott koordinátarendszerhez viszonyított cartesian "
"koordinátákban) a `G28` home parancs után használni kell. A "
"`SET_GCODE_OFFSET` parancs megváltoztathatja ezt az értéket."

msgid "Time"
msgstr "Idő"

msgid ""
"Fundamental to the operation of Klipper is the handling of clocks, times, "
"and timestamps. Klipper executes actions on the printer by scheduling events "
"to occur in the near future. For example, to turn on a fan, the code might "
"schedule a change to a GPIO pin in a 100ms. It is rare for the code to "
"attempt to take an instantaneous action. Thus, the handling of time within "
"Klipper is critical to correct operation."
msgstr ""
"A Klipper működésének alapvető eleme az órák, időpontok és időbélyegek "
"kezelése. A Klipper a nyomtatón végrehajtott műveleteket a közeljövőben "
"bekövetkező események ütemezésével hajtja végre. Például egy ventilátor "
"bekapcsolásához a kód ütemezheti egy GPIO-tű változását 100ms alatt. Ritkán "
"fordul elő, hogy a kód azonnali műveletet próbál végrehajtani. Ezért az idő "
"kezelése a Klipperben kritikus fontosságú a helyes működés szempontjából."

msgid ""
"There are three types of times tracked internally in the Klipper host "
"software:"
msgstr "A Klipper gazdaszoftverben háromféle időtípust követhetünk nyomon:"

msgid ""
"System time. The system time uses the system's monotonic clock - it is a "
"floating point number stored as seconds and it is (generally) relative to "
"when the host computer was last started. System times have limited use in "
"the software - they are primarily used when interacting with the operating "
"system. Within the host code, system times are frequently stored in "
"variables named *eventtime* or *curtime*."
msgstr ""
"Rendszeridő. A rendszeridő a rendszer monoton óráját használja. Ez egy "
"lebegőpontos szám, amelyet másodpercként tárolnak, és (általában) a "
"gazdaszámítógép utolsó indításakor. A rendszeridők korlátozottan "
"használhatók a szoftverben. Elsősorban az operációs rendszerrel való "
"interakció során használják őket. Az állomáskódon belül a rendszeridőket "
"gyakran az *eventtime* vagy *curtime* nevű változók tárolják."

msgid ""
"Print time. The print time is synchronized to the main micro-controller "
"clock (the micro-controller defined in the \"[mcu]\" config section). It is "
"a floating point number stored as seconds and is relative to when the main "
"mcu was last restarted. It is possible to convert from a \"print time\" to "
"the main micro-controller's hardware clock by multiplying the print time by "
"the mcu's statically configured frequency rate. The high-level host code "
"uses print times to calculate almost all physical actions (eg, head "
"movement, heater changes, etc.). Within the host code, print times are "
"generally stored in variables named *print_time* or *move_time*."
msgstr ""
"Nyomtatási idő. A nyomtatási idő a mikrokontroller fő órájához "
"szinkronizálódik az (\"[mcu]\" config) szakaszban meghatározott "
"mikrokontrollerhez. Ez egy másodpercben tárolt lebegőpontos szám, és a fő "
"MCU utolsó újraindításának időpontjához viszonyítva van. Lehetőség van a "
"\"nyomtatási idő\"-ről a fő mikrokontroller hardveres órájára való "
"átváltásra. A nyomtatási időnek az MCU-val való megszorzásával a statikusan "
"konfigurált frekvenciával. A magas szintű gazdakód szinte minden fizikai "
"művelet (pl. fejmozgás, fűtésváltás stb.) kiszámításához nyomtatási időt "
"használ. A gazdakódon belül a nyomtatási időket általában a *print_time* "
"vagy *move_time* nevű változókban tárolják."

msgid ""
"MCU clock. This is the hardware clock counter on each micro-controller. It "
"is stored as an integer and its update rate is relative to the frequency of "
"the given micro-controller. The host software translates its internal times "
"to clocks before transmission to the mcu. The mcu code only ever tracks time "
"in clock ticks. Within the host code, clock values are tracked as 64bit "
"integers, while the mcu code uses 32bit integers. Within the host code, "
"clocks are generally stored in variables with names containing *clock* or "
"*ticks*."
msgstr ""
"MCU óra. Ez az egyes mikrovezérlők hardveres óraszámlálója. Egész számként "
"van tárolva, frissítési gyakorisága az adott mikrovezérlő frekvenciájához "
"viszonyított. A gazdaszoftver belső idejét lefordítja órákra, mielőtt "
"továbbítaná az MCU-nak. Az MCU kód mindig csak az óra ketyegésében követi az "
"időt. A gazdagép kódon belül az óraértékeket 64 bites egész számként követi "
"nyomon, míg az MCU kód 32 bites egész számokat használ. A gazdagép kódon "
"belül az órák általában *clock* vagy *tick* nevet tartalmazó változókban "
"tárolódnak."

msgid ""
"Conversion between the different time formats is primarily implemented in "
"the **klippy/clocksync.py** code."
msgstr ""
"A különböző időformátumok közötti konverzió elsősorban a **klippy/clocksync."
"py** kódban valósul meg."

msgid "Some things to be aware of when reviewing the code:"
msgstr "Néhány dolog, amire figyelni kell a kód áttekintésekor:"

msgid ""
"32bit and 64bit clocks: To reduce bandwidth and to improve micro-controller "
"efficiency, clocks on the micro-controller are tracked as 32bit integers. "
"When comparing two clocks in the mcu code, the `timer_is_before()` function "
"must always be used to ensure integer rollovers are handled properly. The "
"host software converts 32bit clocks to 64bit clocks by appending the high-"
"order bits from the last mcu timestamp it has received - no message from the "
"mcu is ever more than 2^31 clock ticks in the future or past so this "
"conversion is never ambiguous. The host converts from 64bit clocks to 32bit "
"clocks by simply truncating the high-order bits. To ensure there is no "
"ambiguity in this conversion, the **klippy/chelper/serialqueue.c** code will "
"buffer messages until they are within 2^31 clock ticks of their target time."
msgstr ""
"32 bites és 64 bites órajelek: A sávszélesség csökkentése és a "
"mikrokontroller hatékonyságának javítása érdekében a mikrokontroller "
"órajeleit 32 bites egész számokként követik. Két órajel összehasonlításakor "
"az MCU kódban mindig a `timer_is_before()` függvényt kell használni, hogy az "
"egész számok átfordítását megfelelően kezeljük. A gazdaszoftver a 32 bites "
"órajeleket 64 bites órajelekké alakítja át azáltal, hogy hozzáadja az utolsó "
"kapott MCU időbélyegző magasrendű bitjeit. Egyetlen MCU-tól érkező üzenet "
"sem lehet 2^31 órajelnél több a jövőben vagy a múltban, így ez az átalakítás "
"soha nem félreérthető. A gazdagép a 64 bites órajelekről 32 bites órajelekre "
"konvertál a magasrendű bitek egyszerű lefaragásával. Annak érdekében, hogy "
"ez az átalakítás ne legyen kétértelmű, a **klippy/chelper/serialqueue.c** "
"kód addig puffereli az üzeneteket, amíg azok 2^31 órajelen belül vannak a "
"célidőhöz képest."

msgid ""
"Multiple micro-controllers: The host software supports using multiple micro-"
"controllers on a single printer. In this case, the \"MCU clock\" of each "
"micro-controller is tracked separately. The clocksync.py code handles clock "
"drift between micro-controllers by modifying the way it converts from "
"\"print time\" to \"MCU clock\". On secondary mcus, the mcu frequency that "
"is used in this conversion is regularly updated to account for measured "
"drift."
msgstr ""
"Több mikrovezérlő: A gazdaszoftver támogatja több mikrovezérlő használatát "
"egyetlen nyomtatón. Ebben az esetben minden mikrokontroller \"MCU órajelét\" "
"külön-külön követi. A clocksync.py kód kezeli a mikrovezérlők közötti "
"óraeltolódást a \"nyomtatási időről\" az \"MCU órára\" történő átalakítás "
"módjának módosításával. A másodlagos MCU-nál az ebben az átalakításban "
"használt MCU frekvencia rendszeresen frissül, hogy figyelembe vedd a mért "
"csúszást."

msgid ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 "
"stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"
msgstr ""
"Send: GET_POSITION\n"
"Recv: // mcu: stepper_a:-2060 stepper_b:-1169 stepper_c:-1613\n"
"Recv: // stepper: stepper_a:457.254159 stepper_b:466.085669 "
"stepper_c:465.382132\n"
"Recv: // kinematic: X:8.339144 Y:-3.131558 Z:233.347121\n"
"Recv: // toolhead: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode: X:8.338078 Y:-3.123175 Z:233.347878 E:0.000000\n"
"Recv: // gcode base: X:0.000000 Y:0.000000 Z:0.000000 E:0.000000\n"
"Recv: // gcode homing: X:0.000000 Y:0.000000 Z:0.000000\n"

#: docs/Code_Overview.md:block 1 (header)
msgid "Code overview"
msgstr "Kód áttekintése"

#: docs/Code_Overview.md:block 43 (paragraph)
msgid ""
"The \"mcu\" position (`stepper.get_mcu_position()` in the code) is the total "
"number of steps the micro-controller has issued in a positive direction "
"minus the number of steps issued in a negative direction since the micro-"
"controller was last reset. If the robot is in motion when the query is "
"issued then the reported value includes moves buffered on the micro-"
"controller, but does not include moves on the look-ahead queue."
msgstr ""
"Az \"MCU\" pozíció (`stepper.get_mcu_position()` a kódban) a mikrokontroller "
"által pozitív irányban kiadott lépések száma mínusz a mikrokontroller utolsó "
"resetelése óta negatív irányban kiadott lépések száma. Ha a gép a "
"lekérdezéskor mozgásban van, akkor a jelentett érték tartalmazza a "
"mikrokontrollerben pufferelt lépéseket, de nem tartalmazza a look-ahead "
"sorban lévő lépéseket."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Add support for timer dispatch from hardware interrupts. See Klipper [commit "
"970831ee](https://github.com/Klipper3d/klipper/"
"commit/970831ee0d3b91897196e92270d98b2a3067427f) as an example of steps 1-5 "
"done for the LPC176x architecture."
msgstr ""
"A hardveres megszakításokból történő időzítő küldés támogatásának "
"hozzáadása. Lásd a Klipper [commit 970831ee](https://github.com/Klipper3d/"
"klipper/commit/970831ee0d3b91897196e92270d98b2a3067427f) példáját az LPC176x "
"architektúra 1-5. lépéseivel."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up basic GPIO input and output support. See Klipper [commit c78b9076]"
"(https://github.com/Klipper3d/klipper/commit/"
"c78b90767f19c9e8510c3155b89fb7ad64ca3c54) as an example of this."
msgstr ""
"Alapvető GPIO bemeneti és kimeneti támogatás megjelenítése. Lásd a Klipper "
"[commit c78b9076](https://github.com/Klipper3d/klipper/commit/"
"c78b90767f19c9e8510c3155b89fb7ad64ca3c54) példáját erre."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"Bring up additional peripherals - for example see Klipper commit [65613aed]"
"(https://github.com/Klipper3d/klipper/"
"commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27), [c812a40a](https://github."
"com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5), and "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/"
"c381d03aad5c3ee761169b7c7bced519cc14da29)."
msgstr ""
"További perifériák felhozása. Lásd például a Klipper megbízásokat [65613aed]"
"(https://github.com/Klipper3d/klipper/"
"commit/65613aeddfb9ef86905cb1dade9e773a02ef3c27), [c812a40a](https://github."
"com/Klipper3d/klipper/commit/c812a40a3782415e454b04bf7bd2158a6f0ec8b5) és "
"[c381d03a](https://github.com/Klipper3d/klipper/commit/"
"c381d03aad5c3ee761169b7c7bced519cc14da29)."

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If the printer object defines a `get_status()` method then the module can "
"export [status information](Status_Reference.md) via [macros]"
"(Command_Templates.md) and via the [API Server](API_Server.md). The "
"`get_status()` method must return a Python dictionary with keys that are "
"strings and values that are integers, floats, strings, lists, dictionaries, "
"True, False, or None. Tuples (and named tuples) may also be used (these "
"appear as lists when accessed via the API Server). Lists and dictionaries "
"that are exported must be treated as \"immutable\" - if their contents "
"change then a new object must be returned from `get_status()`, otherwise the "
"API Server will not detect those changes."
msgstr ""
"Ha a nyomtató objektum definiál egy `get_status()` metódust, akkor a modul "
"[állapotinformációt](Status_Reference.md) exportálhat a [makrókon]"
"(Command_Templates.md) és az [API Szerveren](API_Server.md) keresztül. A "
"`get_status()` metódusnak egy Python szótárat kell visszaadnia, amelynek "
"kulcsai karakterláncok, értékei pedig egész számok, lebegő számok, "
"karakterláncok, listák, szótárak, True, False vagy None. Használhatók tuplik "
"(és nevesített tuplik) is (ezek az API-kiszolgálón keresztül történő "
"eléréskor listaként jelennek meg). Az exportált \"immutable\" listákat és "
"szótárakat. Ha tartalmuk megváltozik, akkor egy új objektumot kell "
"visszaküldeni a `get_status()` parancsból, különben az API-kiszolgáló nem "
"fogja észlelni a változásokat."

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"It is recommended to assign a value to all member variables in the Python "
"constructor of Python classes. (And therefore avoid utilizing Python's "
"ability to dynamically create new member variables.)"
msgstr ""
"Javasoljuk, hogy a Python osztályok Python konstruktorában minden "
"tagváltozóhoz értéket rendeljen. (És ezért kerülje a Python azon "
"képességének kihasználását, hogy dinamikusan hozzon létre új tagváltozókat.)"

#: docs/Code_Overview.md:block 30 (unordered list)
msgid ""
"If a Python variable is to store a floating point value then it is "
"recommended to always assign and manipulate that variable with floating "
"point constants (and never use integer constants). For example, prefer `self."
"speed = 1.` over `self.speed = 1`, and prefer `self.speed = 2. * x` over "
"`self.speed = 2 * x`. Consistent use of floating point values can avoid hard "
"to debug quirks in Python type conversions."
msgstr ""
"Ha egy Python változónak lebegőpontos értéket kell tárolnia, akkor ajánlott "
"mindig lebegőpontos konstansokkal hozzárendelni és kezelni a változót (és "
"soha ne használjunk egészértékű konstansokat). Például részesítsük előnyben "
"a `self.speed = 1.` értéket a `self.speed = 1` értékkel szemben, és "
"részesítsük előnyben a `self.speed = 2 értéket. * x` a `self.speed = 2 * x` "
"helyett. A lebegőpontos értékek következetes használatával elkerülhetők a "
"Python-típuskonverziók nehezen hibakereshető furcsaságai."

#: docs/Code_Overview.md:block 38 (ordered list)
msgid ""
"The first main coding task is to bring up communication support to the "
"target board. This is the most difficult step in a new port. Once basic "
"communication is working, the remaining steps tend to be much easier. It is "
"typical to use a UART type serial device during initial development as these "
"types of hardware devices are generally easier to enable and control. During "
"this phase, make liberal use of helper code from the src/generic/ directory "
"(check how src/simulator/Makefile includes the generic C code into the "
"build). It is also necessary to define timer_read_time() (which returns the "
"current system clock) in this phase, but it is not necessary to fully "
"support timer irq handling."
msgstr ""
"Az első fő kódolási feladat a kommunikációs támogatás felállítása az "
"alaplapnak. Ez a legnehezebb lépés egy új port esetében. Ha az alapvető "
"kommunikáció már működik, a további lépések általában sokkal könnyebbek. A "
"kezdeti fejlesztés során jellemzően UART típusú soros eszközt használunk, "
"mivel az ilyen típusú hardvereszközöket általában könnyebb engedélyezni és "
"vezérelni. Ebben a fázisban bőkezűen használja az src/generic/ könyvtárban "
"található segédkódot (ellenőrizze, hogy az src/simulator/Makefile hogyan "
"tartalmazza a generikus C kódot a felépítésben). Ebben a fázisban szükséges "
"definiálni a timer_read_time() funkciót is (amely visszaadja az aktuális "
"rendszerórát), de nem szükséges a timer irq kezelésének teljes támogatása."

#: docs/Code_Overview.md:block 39 (paragraph)
msgid "Additional coding tips:"
msgstr "További kódolási tippek:"

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Avoid using \"C bitfields\" to access IO registers; prefer direct read and "
"write operations of 32bit, 16bit, or 8bit integers. The C language "
"specifications don't clearly specify how the compiler must implement C "
"bitfields (eg, endianness, and bit layout), and it's difficult to determine "
"what IO operations will occur on a C bitfield read or write."
msgstr ""
"Kerülje a \"C bitfields\" használatát az IO regiszterek eléréséhez; "
"részesítse előnyben a 32 bites, 16 bites vagy 8 bites egész számok közvetlen "
"olvasási és írási műveleteit. A C nyelvi specifikációk nem határozzák meg "
"egyértelműen, hogy a fordítónak hogyan kell megvalósítania a C bitmezőket "
"(pl. endianness és bitkiosztás), és nehéz meghatározni, hogy milyen IO "
"műveletek történnek egy C bitmező olvasásakor vagy írásakor."

#: docs/Code_Overview.md:block 40 (ordered list)
msgid ""
"Prefer writing explicit values to IO registers instead of using read-modify-"
"write operations. That is, if updating a field in an IO register where the "
"other fields have known values, then it is preferable to explicitly write "
"the full contents of the register. Explicit writes produce code that is "
"smaller, faster, and easier to debug."
msgstr ""
"Inkább írjon explicit értékeket az IO regiszterekbe, minthogy olvasás-"
"módosítás-írás műveleteket használjon. Azaz, ha egy olyan IO-regiszterben "
"frissítünk egy mezőt, ahol a többi mező értékei ismertek, akkor előnyösebb a "
"regiszter teljes tartalmát explicit módon kiírni. Az explicit írások kisebb, "
"gyorsabb és könnyebben hibakereshető kódot eredményeznek."

#: docs/Code_Overview.md:block 14 (paragraph)
msgid ""
"Task, init, and command functions always run with interrupts enabled "
"(however, they can temporarily disable interrupts if needed). These "
"functions should avoid long pauses, delays, or do work that lasts a "
"significant time. (Long delays in these \"task\" functions result in "
"scheduling jitter for other \"tasks\" - delays over 100us may become "
"noticeable, delays over 500us may result in command retransmissions, delays "
"over 100ms may result in watchdog reboots.) These functions schedule work at "
"specific times by scheduling timers."
msgstr ""
"A feladat-, init- és parancsfüggvények mindig engedélyezett megszakításokkal "
"futnak (szükség esetén azonban ideiglenesen letilthatják a megszakításokat). "
"Ezeknek a függvényeknek kerülniük kell a hosszú szüneteket, késleltetéseket, "
"vagy olyan munkát kell végezniük, amely jelentős ideig tart. (A hosszú "
"késleltetések ezekben a \"task\" függvényekben más \"taskok\" ütemezési "
"zavarát eredményezik. A 100us-nál hosszabb késleltetések észrevehetővé "
"válhatnak, az 500us-nál hosszabb késleltetésű parancsok újraküldése, a 100ms-"
"nál hosszabb késleltetések pedig watchdog újraindításokat eredményezhetnek.) "
"Ezek a funkciók időzítőkkel ütemezik a munkát meghatározott időpontokra."

#~ msgid ""
#~ "Task, init, and command functions always run with interrupts enabled "
#~ "(however, they can temporarily disable interrupts if needed). These "
#~ "functions should never pause, delay, or do any work that lasts more than "
#~ "a few micro-seconds. These functions schedule work at specific times by "
#~ "scheduling timers."
#~ msgstr ""
#~ "A (task, init) és parancsfüggvények mindig engedélyezett megszakításokkal "
#~ "futnak (szükség esetén azonban ideiglenesen letilthatják a "
#~ "megszakításokat). Ezek a függvények soha nem tarthatnak szünetet, nem "
#~ "késleltethetnek, és nem végezhetnek olyan munkát, amely néhány "
#~ "mikroszekundumnál tovább tart. Ezek a függvények a munkát meghatározott "
#~ "időpontokra ütemezik időzítők segítségével."
