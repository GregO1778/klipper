# Zs.Antal <zsikaiantal@gmail.com>, 2022.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: yifeiding@protonmail.com\n"
"POT-Creation-Date: \n"
"PO-Revision-Date: 2022-09-25 10:15+0000\n"
"Last-Translator: Zs.Antal <zsikaiantal@gmail.com>\n"
"Language-Team: Hungarian <https://hosted.weblate.org/projects/klipper/"
"bootloaders/hu/>\n"
"Language: hu\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 4.14.1\n"

msgid ""
"This document provides information on common bootloaders found on micro-"
"controllers that Klipper supports."
msgstr ""
"Ez a dokumentum a Klipper által támogatott mikrovezérlőkön található gyakori "
"bootloaderekkel kapcsolatos információkat tartalmazza."

msgid ""
"The bootloader is 3rd-party software that runs on the micro-controller when "
"it is first powered on. It is typically used to flash a new application (eg, "
"Klipper) to the micro-controller without requiring specialized hardware. "
"Unfortunately, there is no industry wide standard for flashing a micro-"
"controller, nor is there a standard bootloader that works across all micro-"
"controllers. Worse, it is common for each bootloader to require a different "
"set of steps to flash an application."
msgstr ""
"A bootloader egy harmadik féltől származó szoftver, amely a mikrovezérlőn "
"fut, amikor az először bekapcsol. Általában egy új alkalmazás (pl. Klipper) "
"égetésére használják a mikrokontrollerre anélkül, hogy speciális hardverre "
"lenne szükség. Sajnos a mikrokontrollerek égetésére nincs iparági szabvány, "
"és nincs olyan szabványos bootloader sem, amely minden mikrokontrolleren "
"működik. Ami még rosszabb, hogy minden egyes bootloader más és más lépéseket "
"igényel az alkalmazás égetéséhez."

msgid ""
"If one can flash a bootloader to a micro-controller then one can generally "
"also use that mechanism to flash an application, but care should be taken "
"when doing this as one may inadvertently remove the bootloader. In contrast, "
"a bootloader will generally only permit a user to flash an application. It "
"is therefore recommended to use a bootloader to flash an application where "
"possible."
msgstr ""
"Ha egy mikrokontrollerre tudunk bootloadert égetni, akkor általában ezt a "
"mechanizmust használhatjuk egy alkalmazás égetésére is, de óvatosan kell "
"eljárni, mert véletlenül eltávolíthatjuk a bootloadert. Ezzel szemben a "
"bootloader általában csak egy alkalmazás égetését teszi lehetővé. Ezért "
"ajánlott, ha lehetséges, bootloadert használni egy alkalmazás égetésére."

msgid ""
"This document attempts to describe common bootloaders, the steps needed to "
"flash a bootloader, and the steps needed to flash an application. This "
"document is not an authoritative reference; it is intended as a collection "
"of useful information that the Klipper developers have accumulated."
msgstr ""
"Ez a dokumentum megpróbálja leírni a gyakori bootloadereket, a bootloader "
"égetéséhez szükséges lépéseket és az alkalmazás égetéséhez szükséges "
"lépéseket. Ez a dokumentum nem tekintélyes hivatkozás. A Klipper fejlesztői "
"által összegyűjtött hasznos információk gyűjteményének szánjuk."

msgid "AVR micro-controllers"
msgstr "AVR mikrovezérlők"

msgid ""
"To flash a bootloader itself, the AVR chips require an external hardware "
"flashing tool (which communicates with the chip using SPI). This tool can be "
"purchased (for example, do a web search for \"avr isp\", \"arduino isp\", or "
"\"usb tiny isp\"). It is also possible to use another Arduino or Raspberry "
"Pi to flash an AVR bootloader (for example, do a web search for \"program an "
"avr using raspberry pi\"). The examples below are written assuming an \"AVR "
"ISP Mk2\" type device is in use."
msgstr ""
"A bootloader égetéséhez az AVR chipekhez külső hardveres égető eszközre van "
"szükség (amely SPI segítségével kommunikál a chippel). Ez az eszköz "
"megvásárolható (például keressen rá az interneten az \"avr isp\", \"arduino "
"isp\" vagy \"usb tiny isp\" szavakra). Az is lehetséges, hogy egy másik "
"Arduino vagy Raspberry Pi segítségével égessen egy AVR bootloadert (például "
"keressen rá az interneten a \"program an avr using raspberry pi\" "
"kifejezésre). Az alábbi példákat egy \"AVR ISP Mk2\" típusú eszköz "
"használatát feltételezve írtuk."

msgid ""
"The \"avrdude\" program is the most common tool used to flash atmega chips "
"(both bootloader flashing and application flashing)."
msgstr ""
"Az \"avrdude\" program a leggyakrabban használt eszköz az atmega chipek "
"égetésére (mind a bootloader, mind az alkalmazások égetésére)."

msgid "Atmega2560"
msgstr "Atmega2560"

msgid ""
"This chip is typically found in the \"Arduino Mega\" and is very common in "
"3d printer boards."
msgstr ""
"Ez a chip jellemzően az \"Arduino Mega\" chipben található, és nagyon "
"gyakori a 3D nyomtató lapokban."

msgid "To flash the bootloader itself use something like:"
msgstr ""
"Magának a bootloadernek az égetéséhez használjon valami olyasmit, mint:"

msgid "To flash an application use something like:"
msgstr "Egy alkalmazás égetéséhez használjon valami olyasmit, mint:"

msgid "Atmega1280"
msgstr "Atmega1280"

msgid ""
"This chip is typically found in earlier versions of the \"Arduino Mega\"."
msgstr "Ez a chip jellemzően az \"Arduino Mega\" korábbi verzióiban található."

msgid "Atmega1284p"
msgstr "Atmega1284p"

msgid "This chip is commonly found in \"Melzi\" style 3d printer boards."
msgstr ""
"Ez a chip gyakran megtalálható a \"Melzi\" stílusú 3D nyomtató alaplapokban."

msgid ""
"Note that a number of \"Melzi\" style boards come preloaded with a "
"bootloader that uses a baud rate of 57600. In this case, to flash an "
"application use something like this instead:"
msgstr ""
"Megjegyzendő, hogy számos \"Melzi\" stílusú alaplap előre betöltött "
"bootloaderrel érkezik, amely 57600-as átviteli sebesség használatával "
"működik. Ebben az esetben egy alkalmazás égetéséhez használjon helyette "
"valami ilyesmit:"

msgid "At90usb1286"
msgstr "At90usb1286"

msgid ""
"This document does not cover the method to flash a bootloader to the "
"At90usb1286 nor does it cover general application flashing to this device."
msgstr ""
"Ez a dokumentum nem foglalkozik az At90usb1286 bootloader égetési "
"módszerével, és nem foglalkozik az általános alkalmazás égetésével sem."

msgid "Atmega168"
msgstr "Atmega168"

msgid ""
"The atmega168 has limited flash space. If using a bootloader, it is "
"recommended to use the Optiboot bootloader. To flash that bootloader use "
"something like:"
msgstr ""
"Az atmega168 korlátozott flash-tárhellyel rendelkezik. Ha bootloadert "
"használ, ajánlott az Optiboot bootloadert használni. A bootloader égetéséhez "
"használjon valami hasonlót:"

msgid "To flash an application via the Optiboot bootloader use something like:"
msgstr ""
"Az Optiboot bootloaderrel történő alkalmazás égetéséhez használjon valami "
"hasonlót:"

msgid "SAM3 micro-controllers (Arduino Due)"
msgstr "SAM3 mikrovezérlők (Arduino Due)"

msgid ""
"It is not common to use a bootloader with the SAM3 mcu. The chip itself has "
"a ROM that allows the flash to be programmed from 3.3V serial port or from "
"USB."
msgstr ""
"A SAM3 MCU-val nem szokás bootloadert használni. Maga a chip rendelkezik egy "
"ROM-mal, amely lehetővé teszi a flash programozását 3,3V-os soros portról "
"vagy USB-ről."

msgid ""
"To enable the ROM, the \"erase\" pin is held high during a reset, which "
"erases the flash contents, and causes the ROM to run. On an Arduino Due, "
"this sequence can be accomplished by setting a baud rate of 1200 on the "
"\"programming usb port\" (the USB port closest to the power supply)."
msgstr ""
"A ROM engedélyezéséhez az \"erase\" csapot magasan kell tartani a "
"visszaállítás során, ami törli a flash tartalmát, és a ROM-ot elindítja. Egy "
"Arduino Due-n ez a szekvencia úgy valósítható meg, hogy a \"programozó usb "
"port\" (a tápegységhez legközelebbi USB port) 1200-as baud sebességet állít "
"be."

msgid "SAM4 micro-controllers (Duet Wifi)"
msgstr "SAM4 mikrovezérlők (Duet Wifi)"

msgid ""
"It is not common to use a bootloader with the SAM4 mcu. The chip itself has "
"a ROM that allows the flash to be programmed from 3.3V serial port or from "
"USB."
msgstr ""
"A SAM4 MCU-val nem szokás bootloadert használni. Maga a chip rendelkezik egy "
"ROM-mal, amely lehetővé teszi a flash programozását 3,3V-os soros portról "
"vagy USB-ről."

msgid ""
"To enable the ROM, the \"erase\" pin is held high during a reset, which "
"erases the flash contents, and causes the ROM to run."
msgstr ""
"A ROM engedélyezéséhez az \"erase\" csapot magasan kell tartani a "
"visszaállítás során, ami törli a flash tartalmát, és a ROM-ot elindítja."

msgid "SAMD21 micro-controllers (Arduino Zero)"
msgstr "SAMD21 mikrovezérlők (Arduino Zero)"

msgid ""
"The SAMD21 bootloader is flashed via the ARM Serial Wire Debug (SWD) "
"interface. This is commonly done with a dedicated SWD hardware dongle. "
"Alternatively, one can use a [Raspberry Pi with OpenOCD](#running-openocd-on-"
"the-raspberry-pi)."
msgstr ""
"A SAMD21 bootloader az ARM Serial Wire Debug (SWD) interfészen keresztül "
"töltődik fel. Ez általában egy dedikált SWD hardver dongle segítségével "
"történik. Alternatívaként használhatunk egy [OpenOCD futtatást a Raspberry "
"PI-n](#az-openocd-futtatasa-a-raspberry-pi-n)."

msgid "To flash a bootloader with OpenOCD use the following chip config:"
msgstr ""
"A bootloader OpenOCD-vel történő égetéséhez használja a következő "
"chipkonfigurációt:"

msgid "Obtain a bootloader - for example:"
msgstr "Szerezzen be egy bootloadert - például:"

msgid "Flash with OpenOCD commands similar to:"
msgstr "Égetés az OpenOCD parancsokhoz hasonló parancsokkal:"

msgid ""
"The most common bootloader on the SAMD21 is the one found on the \"Arduino "
"Zero\". It uses an 8KiB bootloader (the application must be compiled with a "
"start address of 8KiB). One can enter this bootloader by double clicking the "
"reset button. To flash an application use something like:"
msgstr ""
"A SAMD21 leggyakoribb bootloadere az \"Arduino Zero\" -ban található. Ez egy "
"8KiB-es bootloadert használ (az alkalmazást 8KiB kezdőcímmel kell "
"lefordítani). Ebbe a bootloaderbe a reset gombra való dupla kattintással "
"lehet belépni. Egy alkalmazás égetéséhez használjon valami hasonlót:"

msgid ""
"In contrast, the \"Arduino M0\" uses a 16KiB bootloader (the application "
"must be compiled with a start address of 16KiB). To flash an application on "
"this bootloader, reset the micro-controller and run the flash command within "
"the first few seconds of boot - something like:"
msgstr ""
"Ezzel szemben az \"Arduino M0\" 16KiB bootloadert használ (az alkalmazást "
"16KiB kezdőcímmel kell lefordítani). Egy alkalmazás égetéséhez ezen a "
"bootloaderen, állítsd vissza a mikrokontrollert, és futtassa a flash "
"parancsot a bootolás első néhány másodpercében. Valami ilyesmi:"

msgid "SAMD51 micro-controllers (Adafruit Metro-M4 and similar)"
msgstr "SAMD51 mikrovezérlők (Adafruit Metro-M4 és hasonló)"

msgid ""
"Like the SAMD21, the SAMD51 bootloader is flashed via the ARM Serial Wire "
"Debug (SWD) interface. To flash a bootloader with [OpenOCD on a Raspberry Pi]"
"(#running-openocd-on-the-raspberry-pi) use the following chip config:"
msgstr ""
"A SAMD21-hez hasonlóan a SAMD51 bootloader is az ARM Serial Wire Debug (SWD) "
"interfészen keresztül töltődik fel. Az [OpenOCD futtatása a Raspberry PI-n]"
"(#az-openocd-futtatasa-a-raspberry-pi-n) bootloader égetéséhez használja a "
"következő chipkonfigurációt:"

msgid ""
"The SAMD51 uses a 16KiB bootloader (the application must be compiled with a "
"start address of 16KiB). To flash an application use something like:"
msgstr ""
"A SAMD51 16KiB-es bootloadert használ (az alkalmazást 16KiB kezdőcímmel kell "
"lefordítani). Egy alkalmazás égetéséhez használjon valami hasonlót:"

msgid "STM32F103 micro-controllers (Blue Pill devices)"
msgstr "STM32F103 mikrovezérlők (Blue Pill eszközök)"

msgid ""
"After flashing, set both \"boot 0\" and \"boot 1\" back to low so that "
"future resets boot from flash."
msgstr ""
"Az égetés után állítsd vissza a \"boot 0\" és a \"boot 1\" értéket "
"alacsonyra, hogy a jövőben az égetésről induló rendszer újrainduljon."

msgid "STM32F103 with stm32duino bootloader"
msgstr "STM32F103 stm32duino bootloaderrel"

msgid "This bootloader can be flashed via 3.3V serial with something like:"
msgstr ""
"Ez a bootloader 3,3V-os soros kapcsolaton keresztül égethető valami "
"hasonlóval:"

msgid ""
"This bootloader uses 8KiB of flash space (the application must be compiled "
"with a start address of 8KiB). Flash an application with something like:"
msgstr ""
"Ez a bootloader 8KiB-es flash memóriát használ (az alkalmazást 8KiB "
"kezdőcímmel kell lefordítani). Égessen egy alkalmazást valami ilyesmivel:"

msgid ""
"The bootloader typically runs for only a short period after boot. It may be "
"necessary to time the above command so that it runs while the bootloader is "
"still active (the bootloader will flash a board led while it is running). "
"Alternatively, set the \"boot 0\" pin to low and \"boot 1\" pin to high to "
"stay in the bootloader after a reset."
msgstr ""
"A bootloader általában csak rövid ideig fut a rendszerindítás után. Szükség "
"lehet arra, hogy a fenti parancsot úgy időzítsük, hogy az akkor fusson le, "
"amikor a bootloader még aktív (a bootloader üzem közben villogtat egy a "
"lapon lévő ledet). Alternatív megoldásként a \"boot 0\" csapot állítsd "
"alacsonyra, a \"boot 1\" csapot pedig magasra, hogy a bootloaderben maradjon "
"a reset után."

msgid "STM32F103 with HID bootloader"
msgstr "STM32F103 HID bootloaderrel"

msgid ""
"For generic STM32F103 boards such as the blue pill it is possible to flash "
"the bootloader via 3.3v serial using stm32flash as noted in the stm32duino "
"section above, substituting the file name for the desired hid bootloader "
"binary (ie: hid_generic_pc13.bin for the blue pill)."
msgstr ""
"Az általános STM32F103 alaplapok, mint például a blue pill esetében a "
"bootloader 3,3V-os soros égetése lehetséges az stm32flash használatával, "
"amint azt a fenti stm32duino szakaszban említettük, a kívánt hid bootloader "
"bináris fájlnevének behelyettesítésével (azaz: hid_generic_pc13.bin a blue "
"pillhez)."

msgid ""
"It is not possible to use stm32flash for the SKR Mini E3 as the boot0 pin is "
"tied directly to ground and not broken out via header pins. It is "
"recommended to use a STLink V2 with STM32Cubeprogrammer to flash the "
"bootloader. If you don't have access to a STLink it is also possible to use "
"a [Raspberry Pi and OpenOCD](#running-openocd-on-the-raspberry-pi) with the "
"following chip config:"
msgstr ""
"Az SKR Mini E3 esetében nem lehet stm32flash-t használni, mivel a boot0 láb "
"közvetlenül a földre van kötve, és nincs alaplapi tűkiállása. A bootloader "
"égetéséhez ajánlott STLink V2-t használni STM32Cube programozóval. Ha nincs "
"vagy nem fér hozzá egy STLinkhez, akkor lehetséges egy [OpenOCD futtatása a "
"Raspberry PI-n](#az-openocd-futtatasa-a-raspberry-pi-n) használata is a "
"következő chipkonfigurációval:"

msgid ""
"If you wish you can make a backup of the current flash with the following "
"command. Note that it may take some time to complete:"
msgstr ""
"Ha szeretné, a következő paranccsal készíthet biztonsági másolatot az "
"aktuális flash memóriáról. Vedd figyelembe, hogy ez némi időt vehet igénybe:"

msgid "finally, you can flash with commands similar to:"
msgstr "végül, a következő parancsokhoz hasonló parancsokkal égethet:"

msgid "NOTES:"
msgstr "MEGJEGYZÉSEK:"

msgid ""
"The example above erases the chip then programs the bootloader. Regardless "
"of the method chosen to flash it is recommended to erase the chip prior to "
"flashing."
msgstr ""
"A fenti példa törli a chipet, majd beprogramozza a bootloadert. Az égetéshez "
"választott módszertől függetlenül ajánlott a chipet az égetés előtt törölni."

msgid ""
"Prior flashing the SKR Mini E3 with this bootloader you should be aware that "
"you will no longer be able to update firmware via the sdcard."
msgstr ""
"Mielőtt az SKR Mini E3-at ezzel a bootloaderrel égetnéd, tudnod kell, hogy a "
"firmware frissítése már nem lesz lehetséges az SD-kártyán keresztül."

msgid ""
"This bootloader requires 2KiB of flash space (the application must be "
"compiled with a start address of 2KiB)."
msgstr ""
"Ez a bootloader 2KiB-os flash memóriát igényel (az alkalmazást 2KiB "
"kezdőcímmel kell lefordítani)."

msgid ""
"The hid-flash program is used to upload a binary to the bootloader. You can "
"install this software with the following commands:"
msgstr ""
"A hid-flash program egy bináris fájl feltöltésére szolgál a bootloaderre. "
"Ezt a szoftvert a következő parancsokkal telepítheti:"

msgid "If the bootloader is running you can flash with something like:"
msgstr "Ha a bootloader fut, akkor égethetsz valami olyasmivel, mint:"

msgid "alternatively, you can use `make flash` to flash klipper directly:"
msgstr ""
"alternatívaként használhatod a `make flash` parancsot a klipper közvetlen "
"égetéséhez:"

msgid "OR if klipper has been previously flashed:"
msgstr "VAGY ha a klippert korábban már égették:"

msgid ""
"It may be necessary to manually enter the bootloader, this can be done by "
"setting \"boot 0\" low and \"boot 1\" high. On the SKR Mini E3 \"Boot 1\" is "
"not available, so it may be done by setting pin PA2 low if you flashed "
"\"hid_btt_skr_mini_e3.bin\". This pin is labeld \"TX0\" on the TFT header in "
"the SKR Mini E3's \"PIN\" document. There is a ground pin next to PA2 which "
"you can use to pull PA2 low."
msgstr ""
"Szükség lehet a bootloader manuális belépésére, ezt a \"boot 0\" alacsony és "
"\"boot 1\" magas értékek beállításával lehet megtenni. Az SKR Mini E3 "
"esetében a \"Boot 1\" nem áll rendelkezésre, ezért a PA2 tű alacsonyra "
"állításával lehet elvégezni, ha a \"hid_btt_skr_mini_e3.bin\" fájlt égetjük. "
"Ez a tű az SKR Mini E3 \"PIN\" dokumentumban \"TX0\"-ként van jelölve a TFT "
"fejlécen. A PA2 mellett van egy földelt tű, amellyel a PA2-t alacsonyra "
"húzhatja."

msgid "STM32F4 micro-controllers (SKR Pro 1.1)"
msgstr "STM32F4 mikrovezérlők (SKR Pro 1.1)"

msgid ""
"Unless your board is DFU capable the most accessable flashing method is "
"likely via 3.3v serial, which follows the same procedure as [flashing the "
"STM32F103 using stm32flash](#stm32f103-micro-controllers-blue-pill-devices). "
"For example:"
msgstr ""
"Hacsak a lapod nem DFU-képes, a legkönnyebben elérhető égetési módszer "
"valószínűleg a 3,3V-os soros, amely ugyanazt az eljárást követi, mint [az "
"STM32F103 égetése az stm32flash segítségével](#stm32f103-mikrovezerlok-(blue-"
"pill-eszkozok). Például:"

msgid ""
"This bootloader requires 16Kib of flash space on the STM32F4 (the "
"application must be compiled with a start address of 16KiB)."
msgstr ""
"Ez a bootloader 16Kib-es flash memóriát igényel az STM32F4-en (az "
"alkalmazást 16KiB kezdőcímmel kell lefordítani)."

msgid ""
"As with the STM32F1, the STM32F4 uses the hid-flash tool to upload binaries "
"to the MCU. See the instructions above for details on how to build and use "
"hid-flash."
msgstr ""
"Az STM32F1-hez hasonlóan az STM32F4 is a hid-flash eszközt használja a "
"binárisok MCU-ra történő feltöltéséhez. A hid-flash elkészítésének és "
"használatának részletei a fenti utasításokban találhatók."

msgid ""
"It may be necessary to manually enter the bootloader, this can be done by "
"setting \"boot 0\" low, \"boot 1\" high and plugging in the device. After "
"programming is complete unplug the device and set \"boot 1\" back to low so "
"the application will be loaded."
msgstr ""
"Szükség lehet a bootloader manuális belépésére, ez a \"boot 0\" alacsony, "
"\"boot 1\" magas érték beállításával és az eszköz csatlakoztatásával "
"történhet. A programozás befejezése után húzza ki az eszközt, és állítsd "
"vissza a \"boot 1\" értéket alacsonyra, hogy az alkalmazás betöltődjön."

msgid "LPC176x micro-controllers (Smoothieboards)"
msgstr "LPC176x mikrovezérlők (Smoothieboards)"

msgid "Running OpenOCD on the Raspberry PI"
msgstr "Az OpenOCD futtatása a Raspberry PI-n"

msgid ""
"OpenOCD is a software package that can perform low-level chip flashing and "
"debugging. It can use the GPIO pins on a Raspberry Pi to communicate with a "
"variety of ARM chips."
msgstr ""
"Az OpenOCD egy olyan szoftvercsomag, amely képes alacsony szintű égetésekre "
"és hibakeresésre. A Raspberry Pi GPIO-tűit használhatod a különböző ARM-"
"chipekkel való kommunikációra."

msgid ""
"Begin by downloading and compiling the software (each step may take several "
"minutes and the \"make\" step may take 30+ minutes):"
msgstr ""
"Kezd a szoftver letöltésével és fordításával (minden lépés több percet vehet "
"igénybe, és a \"make\" lépés több mint 30 percet is igénybe vehet):"

msgid "Configure OpenOCD"
msgstr "Az OpenOCD konfigurálása"

msgid "Create an OpenOCD config file:"
msgstr "OpenOCD konfigurációs fájl létrehozása:"

msgid "Use a config similar to the following:"
msgstr "Használjon a következőhöz hasonló konfigurációt:"

msgid "Wire the Raspberry Pi to the target chip"
msgstr "A Raspberry Pi és a célchip összekötése"

msgid ""
"Poweroff both the the Raspberry Pi and the target chip before wiring! Verify "
"the target chip uses 3.3V prior to connecting to a Raspberry Pi!"
msgstr ""
"Kapcsolja ki mind a Raspberry Pi-t, mind a célchipet a kábelezés előtt! "
"Ellenőrizze, hogy a célchip 3,3V-ot használ-e a Raspberry Pi csatlakoztatása "
"előtt!"

msgid ""
"Connect GND, SWDCLK, SWDIO, and RST on the target chip to GND, GPIO25, "
"GPIO24, and GPIO18 respectively on the Raspberry Pi."
msgstr ""
"Csatlakoztassa a célchip GND, SWDCLK, SWDIO és RST értékeit a Raspberry Pi "
"GND, GPIO25, GPIO24 és GPIO18 értékéhez."

msgid "Then power up the Raspberry Pi and provide power to the target chip."
msgstr "Ezután kapcsolja be a Raspberry Pi-t, és táplálja a célchipet."

msgid "Run OpenOCD"
msgstr "OpenOCD futtatása"

msgid "Run OpenOCD:"
msgstr "Futtassa az OpenOCD-t:"

msgid ""
"The above should cause OpenOCD to emit some text messages and then wait (it "
"should not immediately return to the Unix shell prompt). If OpenOCD exits on "
"its own or if it continues to emit text messages then double check the "
"wiring."
msgstr ""
"A fentieknek hatására az OpenOCD-nek ki kell adnia néhány szöveges üzenetet, "
"majd várnia kell (nem szabad azonnal visszatérnie az Unix shell prompthoz). "
"Ha az OpenOCD magától kilép, vagy ha továbbra is szöveges üzeneteket ad ki, "
"akkor ellenőrizze kétszer a kábelezést."

msgid ""
"Once OpenOCD is running and is stable, one can send it commands via telnet. "
"Open another ssh session and run the following:"
msgstr ""
"Ha az OpenOCD fut és stabilan működik, akkor telneten keresztül parancsokat "
"küldhetünk neki. Nyissunk egy másik SSH munkamenetet, és futtassuk a "
"következőket:"

msgid ""
"(One can exit telnet by pressing ctrl+] and then running the \"quit\" "
"command.)"
msgstr ""
"(A telnetből a ctrl+] billentyűkombinációval, majd a \"quit\" parancs "
"futtatásával lehet kilépni.)"

msgid "OpenOCD and gdb"
msgstr "OpenOCD és gdb"

msgid ""
"It is possible to use OpenOCD with gdb to debug Klipper. The following "
"commands assume one is running gdb on a desktop class machine."
msgstr ""
"Lehetőség van az OpenOCD és a gdb használatára a Klipper hibakeresésére. A "
"következő parancsok feltételezik, hogy a gdb egy asztali gépen fut."

msgid "Add the following to the OpenOCD config file:"
msgstr "Add hozzá a következőket az OpenOCD konfigurációs fájljához:"

msgid ""
"Restart OpenOCD on the Raspberry Pi and then run the following Unix command "
"on the desktop machine:"
msgstr ""
"Indítsa újra az OpenOCD-t a Raspberry Pi-n, majd futtassa a következő Unix "
"parancsot az asztali gépen:"

msgid "Within gdb run:"
msgstr "A gdb futtatása:"

msgid ""
"(Replace \"octopi\" with the host name of the Raspberry Pi.) Once gdb is "
"running it is possible to set breakpoints and to inspect registers."
msgstr ""
"(Cserélje ki a \"octopi\" -t a Raspberry Pi gazdagép nevére.) Ha a gdb fut, "
"lehetőség van töréspontok beállítására és a regiszterek vizsgálatára."

msgid ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/"
"bootloaders/stk500v2/stk500boot_v2_mega2560.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:"
"m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:"
"stk500boot_v2_mega2560.hex\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/"
"bootloaders/stk500v2/stk500boot_v2_mega2560.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:"
"m -U efuse:w:0xFD:m -U hfuse:w:0xD8:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U flash:w:"
"stk500boot_v2_mega2560.hex\n"
"avrdude -cavrispv2 -patmega2560 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/"
"klipper.elf.hex:i\n"
msgstr ""
"avrdude -cwiring -patmega2560 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/"
"klipper.elf.hex:i\n"

msgid ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/"
"bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:"
"m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:"
"ATmegaBOOT_168_atmega1280.hex\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/"
"bootloaders/atmega/ATmegaBOOT_168_atmega1280.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:"
"m -U efuse:w:0xF5:m -U hfuse:w:0xDA:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U flash:w:"
"ATmegaBOOT_168_atmega1280.hex\n"
"avrdude -cavrispv2 -patmega1280 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/"
"klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega1280 -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/"
"klipper.elf.hex:i\n"

msgid ""
"wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/"
"optiboot_atmega1284p.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:"
"w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:"
"optiboot_atmega1284p.hex\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/Lauszus/Sanguino/raw/1.0.2/bootloaders/optiboot/"
"optiboot_atmega1284p.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -e -u -U lock:"
"w:0x3F:m -U efuse:w:0xFD:m -U hfuse:w:0xDE:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U flash:w:"
"optiboot_atmega1284p.hex\n"
"avrdude -cavrispv2 -patmega1284p -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/"
"klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/"
"klipper.elf.hex:i\n"

msgid ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/"
"klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega1284p -P/dev/ttyACM0 -b57600 -D -Uflash:w:out/"
"klipper.elf.hex:i\n"

msgid "teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v\n"
msgstr "teensy_loader_cli --mcu=at90usb1286 out/klipper.elf.hex -v\n"

msgid ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/"
"bootloaders/optiboot/optiboot_atmega168.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:"
"m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:"
"optiboot_atmega168.hex\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"
msgstr ""
"wget 'https://github.com/arduino/Arduino/raw/1.8.5/hardware/arduino/avr/"
"bootloaders/optiboot/optiboot_atmega168.hex'\n"
"\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -e -u -U lock:w:0x3F:"
"m -U efuse:w:0x04:m -U hfuse:w:0xDD:m -U lfuse:w:0xFF:m\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U flash:w:"
"optiboot_atmega168.hex\n"
"avrdude -cavrispv2 -patmega168 -P/dev/ttyACM0 -b115200 -U lock:w:0x0F:m\n"

msgid ""
"avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/"
"klipper.elf.hex:i\n"
msgstr ""
"avrdude -carduino -patmega168 -P/dev/ttyACM0 -b115200 -D -Uflash:w:out/"
"klipper.elf.hex:i\n"

msgid ""
"bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b\n"
"bossac -U -p /dev/ttyACM0 -R\n"
msgstr ""
"bossac -U -p /dev/ttyACM0 -a -e -w out/klipper.bin -v -b\n"
"bossac -U -p /dev/ttyACM0 -R\n"

msgid "bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin\n"
msgstr "bossac --port=/dev/ttyACM0 -b -U -e -w -v -R out/klipper.bin\n"

msgid "source [find target/at91samdXX.cfg]\n"
msgstr "forrás [find target/at91samdXX.cfg]\n"

msgid ""
"wget 'https://github.com/arduino/ArduinoCore-samd/raw/1.8.3/bootloaders/zero/"
"samd21_sam_ba.bin'\n"
msgstr ""
"wget 'https://github.com/arduino/ArduinoCore-samd/raw/1.8.3/bootloaders/zero/"
"samd21_sam_ba.bin'\n"

msgid ""
"at91samd bootloader 0\n"
"program samd21_sam_ba.bin verify\n"
msgstr ""
"at91samd bootloader 0\n"
"program samd21_sam_ba.bin verify\n"

msgid "bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R\n"
msgstr ""
"bossac -U -p /dev/ttyACM0 --offset=0x2000 -w out/klipper.bin -v -b -R\n"

msgid ""
"avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u -Uflash:w:out/klipper."
"elf.hex:i\n"
msgstr ""
"avrdude -c stk500v2 -p atmega2560 -P /dev/ttyACM0 -u -Uflash:w:out/klipper."
"elf.hex:i\n"

msgid "source [find target/atsame5x.cfg]\n"
msgstr "forrás [find target/atsame5x.cfg]\n"

msgid ""
"wget 'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/"
"bootloader-itsybitsy_m4-v3.7.0.bin'\n"
msgstr ""
"wget 'https://github.com/adafruit/uf2-samdx1/releases/download/v3.7.0/"
"bootloader-itsybitsy_m4-v3.7.0.bin'\n"

msgid ""
"at91samd bootloader 0\n"
"program bootloader-itsybitsy_m4-v3.7.0.bin verify\n"
"at91samd bootloader 16384\n"
msgstr ""
"at91samd bootloader 0\n"
"program bootloader-itsybitsy_m4-v3.7.0.bin verify\n"
"at91samd bootloader 16384\n"

msgid "bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"
msgstr ""
"bossac -U -p /dev/ttyACM0 --offset=0x4000 -w out/klipper.bin -v -b -R\n"

msgid "stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0\n"
msgstr "stm32flash -w out/klipper.bin -v -g 0 /dev/ttyAMA0\n"

msgid ""
"wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/"
"master/binaries/generic_boot20_pc13.bin'\n"
"\n"
"stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0\n"
msgstr ""
"wget 'https://github.com/rogerclarkmelbourne/STM32duino-bootloader/raw/"
"master/binaries/generic_boot20_pc13.bin'\n"
"\n"
"stm32flash -w generic_boot20_pc13.bin -v -g 0 /dev/ttyAMA0\n"

msgid "dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin\n"
msgstr "dfu-util -d 1eaf:0003 -a 2 -R -D out/klipper.bin\n"

msgid "source [find target/stm32f1x.cfg]\n"
msgstr "forrás [find target/stm32f1x.cfg]\n"

msgid "flash read_bank 0 btt_skr_mini_e3_backup.bin\n"
msgstr "flash read_bank 0 btt_skr_mini_e3_backup.bin\n"

msgid ""
"stm32f1x mass_erase 0\n"
"program hid_btt_skr_mini_e3.bin verify 0x08000000\n"
msgstr ""
"stm32f1x mass_erase 0\n"
"program hid_btt_skr_mini_e3.bin verify 0x08000000\n"

msgid ""
"You may need to hold down the reset button on the board while launching "
"OpenOCD. It should display something like:Open On-Chip Debugger "
"0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00)\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"DEPRECATED! use 'adapter speed' not 'adapter_khz'\n"
"Info : BCM2835 GPIO JTAG/SWD bitbang driver\n"
"Info : JTAG and SWD modes enabled\n"
"Info : clock speed 40 kHz\n"
"Info : SWD DPIDR 0x1ba01477\n"
"Info : stm32f1x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"Info : stm32f1x.cpu: external reset detected\n"
"Info : starting gdb server for stm32f1x.cpu on 3333\n"
"Info : Listening on port 3333 for gdb connections\n"
msgstr ""
"Előfordulhat, hogy az OpenOCD indítása közben nyomva kell tartania a reset "
"gombot az alaplapon. Valami olyasmit kell megjelenítenie, mint:Open On-Chip "
"Debugger 0.10.0+dev-01204-gc60252ac-dirty (2020-04-27-16:00)\n"
"GNU GPL v2 licensz alatt\n"
"A hibajelentésekhez olvassa el\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"ELAVULT! használd az 'adapter speed' helyett a 'adapter_khz'\n"
"Info : BCM2835 GPIO JTAG/SWD bitbang vezérlő\n"
"Info : JTAG és SWD módok engedélyezve\n"
"Info : órajel sebesség 40 kHz\n"
"Info : SWD DPIDR 0x1ba01477\n"
"Info : stm32f1x.cpu: a hardver 6 töréspontot és 4 figyelési pontot "
"tartalmaz.\n"
"Info : stm32f1x.cpu: külső reset észlelve\n"
"Info : gdb szerver indítása az stm32f1x.cpu számára a 3333-as rendszeren.\n"
"Info : Figyel a 3333-as porton a gdb kapcsolatokra.\n"

msgid "After which you can release the reset button."
msgstr "Ezt követően elengedheti a reset gombot."

msgid ""
"sudo apt install libusb-1.0\n"
"cd ~/klipper/lib/hidflash\n"
"make\n"
msgstr ""
"sudo apt install libusb-1.0\n"
"cd ~/klipper/lib/hidflash\n"
"make\n"

msgid "~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin\n"
msgstr "~/klipper/lib/hidflash/hid-flash ~/klipper/out/klipper.bin\n"

msgid "make flash FLASH_DEVICE=1209:BEBA\n"
msgstr "make flash FLASH_DEVICE=1209:BEBA\n"

msgid "make flash FLASH_DEVICE=/dev/ttyACM0\n"
msgstr "make flash FLASH_DEVICE=/dev/ttyACM0\n"

msgid ""
"wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-"
"beta/hid_bootloader_SKR_PRO.bin\n"
"\n"
"stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0\n"
msgstr ""
"wget https://github.com/Arksine/STM32_HID_Bootloader/releases/download/v0.5-"
"beta/hid_bootloader_SKR_PRO.bin\n"
"\n"
"stm32flash -w hid_bootloader_SKR_PRO.bin -v -g 0 /dev/ttyAMA0\n"

msgid ""
"sudo apt-get update\n"
"sudo apt-get install autoconf libtool telnet\n"
"mkdir ~/openocd\n"
"cd ~/openocd/\n"
"git clone http://openocd.zylin.com/openocd\n"
"cd openocd\n"
"./bootstrap\n"
"./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/"
"openocd/install\n"
"make\n"
"make install\n"
msgstr ""
"sudo apt-get update\n"
"sudo apt-get install autoconf libtool telnet\n"
"mkdir ~/openocd\n"
"cd ~/openocd/\n"
"git clone http://openocd.zylin.com/openocd\n"
"cd openocd\n"
"./bootstrap\n"
"./configure --enable-sysfsgpio --enable-bcm2835gpio --prefix=/home/pi/"
"openocd/install\n"
"make\n"
"make install\n"

msgid "nano ~/openocd/openocd.cfg\n"
msgstr "nano ~/openocd/openocd.cfg\n"

msgid ""
"# Uses RPi pins: GPIO25 for SWDCLK, GPIO24 for SWDIO, GPIO18 for nRST\n"
"source [find interface/raspberrypi2-native.cfg]\n"
"bcm2835gpio_swd_nums 25 24\n"
"bcm2835gpio_srst_num 18\n"
"transport select swd\n"
"\n"
"# Use hardware reset wire for chip resets\n"
"reset_config srst_only\n"
"adapter_nsrst_delay 100\n"
"adapter_nsrst_assert_width 100\n"
"\n"
"# Specify the chip type\n"
"source [find target/atsame5x.cfg]\n"
"\n"
"# Set the adapter speed\n"
"adapter_khz 40\n"
"\n"
"# Connect to chip\n"
"init\n"
"targets\n"
"reset halt\n"
msgstr ""
"# RPi tűket használ: GPIO25 az SWDCLK-hoz, GPIO24 az SWDIO-hoz, GPIO18 az "
"nRST-hez.\n"
"forrás [find interface/raspberrypi2-native.cfg]\n"
"bcm2835gpio_swd_nums 25 24\n"
"bcm2835gpio_srst_num 18\n"
"szállítás kiválasztása swd\n"
"\n"
"# Hardveres reset vezeték használata a chip reseteléséhez\n"
"reset_config srst_only\n"
"adapter_nsrst_delay 100\n"
"adapter_nsrst_assert_width 100\n"
"\n"
"# A chip típusának megadása\n"
"source [find target/atsame5x.cfg]\n"
"\n"
"# Add meg az adapter sebességét\n"
"adapter_khz 40\n"
"\n"
"# Csatlakozás a chiphez\n"
"init\n"
"targets\n"
"reset halt\n"

msgid ""
"cd ~/openocd/\n"
"sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg\n"
msgstr ""
"cd ~/openocd/\n"
"sudo ~/openocd/install/bin/openocd -f ~/openocd/openocd.cfg\n"

msgid "telnet 127.0.0.1 4444\n"
msgstr "telnet 127.0.0.1 4444\n"

msgid ""
"bindto 0.0.0.0\n"
"gdb_port 44444\n"
msgstr ""
"bindto 0.0.0.0\n"
"gdb_port 44444\n"

msgid ""
"cd /path/to/klipper/\n"
"gdb out/klipper.elf\n"
msgstr ""
"cd /path/to/klipper/\n"
"gdb out/klipper.elf\n"

msgid "target remote octopi:44444\n"
msgstr "target remote octopi:44444\n"

#: docs/Bootloaders.md:block 1 (header)
msgid "Bootloaders"
msgstr "Bootloaderek"

#: docs/Bootloaders.md:block 7 (paragraph)
msgid ""
"In general, the Arduino project is a good reference for bootloaders and "
"flashing procedures on the 8-bit Atmel Atmega micro-controllers. In "
"particular, the \"boards.txt\" file: <https://github.com/arduino/Arduino/"
"blob/1.8.5/hardware/arduino/avr/boards.txt> is a useful reference."
msgstr ""
"Általánosságban az Arduino projekt jó referencia a 8 bites Atmel Atmega "
"mikrovezérlők bootloadereiről és a égetési eljárásokról. Különösen a "
"\"boards.txt\" fájl: <https://github.com/arduino/Arduino/blob/1.8.5/hardware/"
"arduino/avr/boards.txt> hasznos referencia."

#: docs/Bootloaders.md:block 32 (paragraph)
msgid ""
"The Teensy++ device from pjrc.com comes with a proprietary bootloader. It "
"requires a custom flashing tool from <https://github.com/PaulStoffregen/"
"teensy_loader_cli>. One can flash an application with it using something "
"like:"
msgstr ""
"A pjrc.com Teensy++ eszköze saját bootloaderrel rendelkezik. Ehhez egy "
"egyedi égető eszközre van szükség a <https://github.com/PaulStoffregen/"
"teensy_loader_cli> oldalról. Egy alkalmazást lehet vele égetni valami "
"ilyesmivel:"

#: docs/Bootloaders.md:block 42 (paragraph)
msgid ""
"The code at <https://github.com/shumatech/BOSSA> can be used to program the "
"SAM3. It is recommended to use version 1.9 or later."
msgstr ""
"A <https://github.com/shumatech/BOSSA> alatti kód használható a SAM3 "
"programozásához. Az 1.9-es vagy újabb verzió használata ajánlott."

#: docs/Bootloaders.md:block 48 (paragraph)
msgid ""
"The code at <https://github.com/shumatech/BOSSA> can be used to program the "
"SAM4. It is necessary to use version `1.8.0` or higher."
msgstr ""
"A <https://github.com/shumatech/BOSSA> kód használható a SAM4 "
"programozásához. Szükséges az `1.8.0` vagy magasabb verzió használata."

#: docs/Bootloaders.md:block 66 (paragraph)
msgid ""
"Obtain a bootloader - several bootloaders are available from <https://github."
"com/adafruit/uf2-samdx1/releases/latest>. For example:"
msgstr ""
"Szerezzen be egy bootloadert. Számos bootloader elérhető a <https://github."
"com/adafruit/uf2-samdx1/releases/latest> oldalon. Például:"

#: docs/Bootloaders.md:block 78 (paragraph)
msgid ""
"The \"stm32duino\" project has a USB capable bootloader - see: <https://"
"github.com/rogerclarkmelbourne/STM32duino-bootloader>"
msgstr ""
"Az \"stm32duino\" projekt rendelkezik USB-képes bootloaderrel. Lásd: "
"<https://github.com/rogerclarkmelbourne/STM32duino-bootloader>"

#: docs/Bootloaders.md:block 113 (paragraph)
msgid ""
"This document does not describe the method to flash a bootloader itself - "
"see: <http://smoothieware.org/flashing-the-bootloader> for further "
"information on that topic."
msgstr ""
"Ez a dokumentum nem írja le a bootloader égetésének módszerét. Lásd: <http://"
"smoothieware.org/flashing-the-bootloader> a témával kapcsolatos további "
"információkért."

#: docs/Bootloaders.md:block 114 (paragraph)
msgid ""
"It is common for Smoothieboards to come with a bootloader from: <https://"
"github.com/triffid/LPC17xx-DFU-Bootloader>. When using this bootloader the "
"application must be compiled with a start address of 16KiB. The easiest way "
"to flash an application with this bootloader is to copy the application file "
"(eg, `out/klipper.bin`) to a file named `firmware.bin` on an SD card, and "
"then to reboot the micro-controller with that SD card."
msgstr ""
"A Smoothieboardok általában a következő bootloaderrel érkeznek: <https://"
"github.com/triffid/LPC17xx-DFU-Bootloader>. Ha ezt a bootloadert használjuk, "
"az alkalmazást 16KiB kezdőcímmel kell lefordítani. Az alkalmazás égetésének "
"legegyszerűbb módja ezzel a bootloaderrel az alkalmazásfájl (pl. `out/"
"klipper.bin`) másolása egy SD-kártyán lévő `firmware.bin` nevű fájlra, majd "
"a mikrokontroller újraindítása ezzel az SD-kártyával."

#: docs/Bootloaders.md:block 117 (paragraph)
msgid ""
"This section describes how one can install and launch OpenOCD. It is derived "
"from the instructions at: <https://learn.adafruit.com/programming-"
"microcontrollers-using-openocd-on-raspberry-pi>"
msgstr ""
"Ez a szakasz leírja, hogyan lehet telepíteni és elindítani az OpenOCD-t. A "
"következő oldalon található utasításokból származik: <https://learn.adafruit."
"com/programming-microcontrollers-using-openocd-on-raspberry-pi>"

#: docs/Bootloaders.md:block 75 (paragraph)
msgid ""
"Note that if one is using a Raspberry Pi for the 3.3V serial, the stm32flash "
"protocol uses a serial parity mode which the Raspberry Pi's \"mini UART\" "
"does not support. See <https://www.raspberrypi.com/documentation/computers/"
"configuration.html#configuring-uarts> for details on enabling the full uart "
"on the Raspberry Pi GPIO pins."
msgstr ""
"Vedd figyelembe, hogy ha Raspberry Pi-t használ a 3,3V-os soros "
"kapcsolathoz, az stm32flash protokoll olyan soros paritásmódot használ, "
"amelyet a Raspberry Pi \"mini UART\" nem támogat. Lásd <https://www."
"raspberrypi.com/documentation/computers/configuration.html#configuring-"
"uarts> a teljes uart engedélyezéséről a Raspberry Pi GPIO tűin."

#: docs/Bootloaders.md:block 85 (paragraph)
msgid ""
"The [HID bootloader](https://github.com/Serasidis/STM32_HID_Bootloader) is a "
"compact, driverless bootloader capable of flashing over USB. Also available "
"is a [fork with builds specific to the SKR Mini E3 1.2](https://github.com/"
"Arksine/STM32_HID_Bootloader/releases/latest)."
msgstr ""
"A [HID bootloader](https://github.com/Serasidis/STM32_HID_Bootloader) egy "
"kompakt, driver nélküli bootloader, amely képes USB-n keresztül égetni. "
"Szintén elérhető egy [fork az SKR Mini E3 1.2 specifikus buildekkel](https://"
"github.com/Arksine/STM32_HID_Bootloader/releases/latest)."

#: docs/Bootloaders.md:block 106 (paragraph)
msgid ""
"STM32F4 microcontrollers come equipped with a built-in system bootloader "
"capable of flashing over USB (via DFU), 3.3v Serial, and various other "
"methods (see STM Document AN2606 for more information). Some STM32F4 boards, "
"such as the SKR Pro 1.1, are not able to enter the DFU bootloader. The HID "
"bootloader is available for STM32F405/407 based boards should the user "
"prefer flashing over USB over using the sdcard. Note that you may need to "
"configure and build a version specific to your board, a [build for the SKR "
"Pro 1.1 is available here](https://github.com/Arksine/STM32_HID_Bootloader/"
"releases/latest)."
msgstr ""
"Az STM32F4 mikrokontrollerek beépített rendszerbetöltővel rendelkeznek, "
"amely képes USB-n keresztül (DFU-n keresztül), 3,3V-os soros és különböző "
"más módszerekkel is égetni (további információkért lásd az STM AN2606 "
"dokumentumát). Egyes STM32F4 lapok, mint például az SKR Pro 1.1, nem képesek "
"belépni a DFU bootloaderbe. A HID bootloader elérhető az STM32F405/407 alapú "
"lapokhoz, amennyiben a felhasználó az USB-n keresztül történő égetést "
"részesíti előnyben az SD-kártya használatával szemben. Ne feledd, hogy "
"szükség lehet egy, az alaplapodnak specifikus verzió konfigurálására és "
"szerkesztésére, egy [az SKR Pro 1.1-es lapra vonatkozó verzió elérhető "
"itt](https://github.com/Arksine/STM32_HID_Bootloader/releases/latest)."

#: docs/Bootloaders.md:block 105 (header)
msgid "STM32F103/STM32F072 with MSC bootloader"
msgstr "STM32F103/STM32F072 MSC bootloaderrel"

#: docs/Bootloaders.md:block 106 (paragraph)
msgid ""
"The [MSC bootloader](https://github.com/Telekatz/MSC-stm32f103-bootloader) "
"is a driverless bootloader capable of flashing over USB."
msgstr ""
"Az [MSC bootloader](https://github.com/Telekatz/MSC-stm32f103-bootloader) "
"egy USB-n keresztül égethető, driver nélküli bootloader."

#: docs/Bootloaders.md:block 107 (paragraph)
msgid ""
"It is possible to flash the bootloader via 3.3v serial using stm32flash as "
"noted in the stm32duino section above, substituting the file name for the "
"desired MSC bootloader binary (ie: MSCboot-Bluepill.bin for the blue pill)."
msgstr ""
"Lehetőség van a bootloader 3,3V-os soros égetésére az stm32flash "
"használatával, ahogyan azt a fenti stm32duino szakaszban említettük, a "
"kívánt MSC bootloader bináris fájlnevének behelyettesítésével (azaz: MSCboot-"
"Bluepill.bin a Bluepill-hez)."

#: docs/Bootloaders.md:block 108 (paragraph)
msgid ""
"For STM32F072 boards it is also possible to flash the bootloader over USB "
"(via DFU) with something like:"
msgstr ""
"Az STM32F072 lapok esetében a bootloader USB-n keresztül (DFU-n keresztül) "
"is égethető, például a következőkkel:"

#: docs/Bootloaders.md:block 109 (code)
msgid ""
" dfu-util -d 0483:df11 -a 0 -R -D  MSCboot-STM32F072.bin -s0x08000000:leave\n"
msgstr ""
" dfu-util -d 0483:df11 -a 0 -R -D  MSCboot-STM32F072.bin -s0x08000000:leave\n"

#: docs/Bootloaders.md:block 110 (paragraph)
msgid ""
"This bootloader uses 8KiB or 16KiB of flash space, see description of the "
"bootloader (the application must be compiled with with the corresponding "
"starting address)."
msgstr ""
"Ez a bootloader 8KiB vagy 16KiB flash helyet használ, lásd a bootloader "
"leírását (az alkalmazást a megfelelő kezdőcímmel kell lefordítani)."

#: docs/Bootloaders.md:block 111 (paragraph)
msgid ""
"The bootloader can be activated by pressing the reset button of the board "
"twice. As soon as the bootloader is activated, the board appears as a USB "
"flash drive onto which the klipper.bin file can be copied."
msgstr ""
"A bootloader a kártya reset gombjának kétszeri megnyomásával aktiválható. "
"Amint a bootloader aktiválódik, a kártya USB flash meghajtóként jelenik meg, "
"amelyre a klipper.bin fájl másolható."

#: docs/Bootloaders.md:block 73 (paragraph)
msgid ""
"The STM32F103 devices have a ROM that can flash a bootloader or application "
"via 3.3V serial. Typically one would wire the PA10 (MCU Rx) and PA9 (MCU Tx) "
"pins to a 3.3V UART adapter. To access the ROM, one should connect the "
"\"boot 0\" pin to high and \"boot 1\" pin to low, and then reset the device. "
"The \"stm32flash\" package can then be used to flash the device using "
"something like:"
msgstr ""
"Az STM32F103 eszközök rendelkeznek egy ROM-mal, amely 3,3 V-os soros "
"kapcsolaton keresztül képes bootloadert vagy alkalmazást égetni. Általában a "
"PA10 (MCU Rx) és PA9 (MCU Tx) tűket egy 3,3V-os UART adapterhez kell "
"csatlakoztatni. A ROM eléréséhez a \"boot 0\" tűt magasra, a \"boot 1\" tűt "
"pedig alacsonyra kell kapcsolni, majd vissza kell állítani az eszközt. Az "
"\"stm32flash\" csomagot ezután használhatjuk az eszköz égetésére, például a "
"következőkkel:"

#: docs/Bootloaders.md:block 112 (header)
msgid "STM32F103/STM32F0x2 with CanBoot bootloader"
msgstr "STM32F103/STM32F0x2 CanBoot bootloaderrel"

#: docs/Bootloaders.md:block 113 (paragraph)
msgid ""
"The [CanBoot](https://github.com/Arksine/CanBoot) bootloader provides an "
"option for uploading Klipper firmware over the CANBUS. The bootloader itself "
"is derived from Klipper's source code. Currently CanBoot supports the "
"STM32F103, STM32F042, and STM32F072 models."
msgstr ""
"A [CanBoot](https://github.com/Arksine/CanBoot) bootloader lehetőséget "
"biztosít a Klipper firmware feltöltésére CANBUS-on keresztül. Maga a "
"bootloader a Klipper forráskódjából származik. A CanBoot jelenleg az "
"STM32F103, STM32F042 és STM32F072 modelleket támogatja."

#: docs/Bootloaders.md:block 114 (paragraph)
msgid ""
"It is recommended to use a ST-Link Programmer to flash CanBoot, however it "
"should be possible to flash using `stm32flash` on STM32F103 devices, and "
"`dfu-util` on STM32F042/STM32F072 devices. See the previous sections in this "
"document for instructions on these flashing methods, substituting `canboot."
"bin` for the file name where appropriate. The CanBoot repo linked above "
"provides instructions for building the bootloader."
msgstr ""
"A CanBoot égetéséhez ajánlott ST-Link programozót használni, azonban "
"STM32F103 eszközökön az `stm32flash`, STM32F103 eszközökön pedig a `dfu-"
"util` használatával is lehet égetni. A dokumentum korábbi szakaszaiban "
"találhatók az utasítások ezekre az égetési módszerekre vonatkozóan, adott "
"esetben a fájlnevet `canboot.bin`-el helyettesítve. A fentebb linkelt "
"CanBoot repo tartalmaz utasításokat a bootloader elkészítéséhez."

#: docs/Bootloaders.md:block 115 (paragraph)
msgid ""
"The first time CanBoot has been flashed it should detect that no application "
"is present and enter the bootloader. If this doesn't occur it is possible to "
"enter the bootloader by pressing the reset button twice in succession."
msgstr ""
"A CanBoot első égetésénél észlelned kell, hogy nincs jelen alkalmazás, és be "
"kell lépned a bootloaderbe. Ha ez nem történik meg, akkor a reset gomb "
"kétszer egymás utáni megnyomásával lehet belépni a bootloaderbe."

#: docs/Bootloaders.md:block 116 (paragraph)
msgid ""
"The `flash_can.py` utility supplied in the `lib/canboot` folder may be used "
"to upload Klipper firmware. The device UUID is necessary to flash. If you do "
"not have a UUID it is possible to query nodes currently running the "
"bootloader:"
msgstr ""
"A Klipper firmware feltöltéséhez a `flash_can.py` segédprogram használható, "
"amely a `lib/canboot` mappában található. Az égetéshez szükséges az eszköz "
"UUID azonosítója. Ha nincs meg az UUID, akkor a bootloadert jelenleg futtató "
"csomópontok lekérdezése lehetséges:"

#: docs/Bootloaders.md:block 117 (code)
msgid "python3 flash_can.py -q\n"
msgstr "python3 flash_can.py -q\n"

#: docs/Bootloaders.md:block 118 (paragraph)
msgid ""
"This will return UUIDs for all connected nodes not currently assigned a "
"UUID. This should include all nodes currently in the bootloader."
msgstr ""
"Ez visszaadja az összes olyan csatlakoztatott csomópont UUID-jét, amelyhez "
"jelenleg nem tartozik UUID. Ennek tartalmaznia kell a jelenlegi "
"bootloaderben lévő összes csomópontot."

#: docs/Bootloaders.md:block 119 (paragraph)
msgid "Once you have a UUID, you may upload firmware with following command:"
msgstr "Ha megvan az UUID, a következő paranccsal tölthet fel firmware-t:"

#: docs/Bootloaders.md:block 120 (code)
msgid ""
"python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff\n"
msgstr ""
"python3 flash_can.py -i can0 -f ~/klipper/out/klipper.bin -u aabbccddeeff\n"

#: docs/Bootloaders.md:block 121 (paragraph)
msgid ""
"Where `aabbccddeeff` is replaced by your UUID. Note that the `-i` and `-f` "
"options may be omitted, they default to `can0` and `~/klipper/out/klipper."
"bin` respectively."
msgstr ""
"Ahol `aabbccddeeff` helyébe az Ön UUID-je lép. Vedd figyelembe, hogy a `-i` "
"és `-f` opciók elhagyhatók, ezek alapértelmezett értéke `can0` és `~/klipper/"
"out/klipper.bin`."

#: docs/Bootloaders.md:block 122 (paragraph)
msgid ""
"When building Klipper for use with CanBoot, select the 8 KiB Bootloader "
"option."
msgstr ""
"Amikor a Klippert a CanBoot-al való használatra építi, válassza a 8 KiB-os "
"bootloader opciót."

#~ msgid ""
#~ "The STM32F103 devices have a ROM that can flash a bootloader or "
#~ "application via 3.3V serial. To access this ROM, one should connect the "
#~ "\"boot 0\" pin to high and \"boot 1\" pin to low, and then reset the "
#~ "device. The \"stm32flash\" package can then be used to flash the device "
#~ "using something like:"
#~ msgstr ""
#~ "Az STM32F103 eszközök rendelkeznek egy ROM-mal, amely 3,3V-os soros "
#~ "kapcsolaton keresztül képes bootloadert vagy alkalmazást égetni. A ROM "
#~ "eléréséhez a \"boot 0\" csapot magasra, a \"boot 1\" csapot pedig "
#~ "alacsonyra kell kapcsolni, majd vissza kell állítani az eszközt. Az "
#~ "\"stm32flash\" csomagot ezután használhatjuk az eszköz égetéséhez, "
#~ "például a következőkkel:"
